<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccENTArithmeticEncodeStart.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccENTArithmeticEncodeStart, QccENTArithmeticEncodeEnd, QccENTArithmeticEncode, 
QccENTArithmeticEncodeFlush, QccENTArithmeticDecodeStart, QccENTArithmeticDecodeRestart, 
QccENTArithmeticDecode - arithmetic encoding and decoding  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include 
"libQccPack.h"</B>  <P>
<B>QccENTArithmeticModel *QccENTArithmeticEncodeStart(const 
int *</B><I>num_symbols</I><B>, int </B><I>num_contexts</I><B>, QccENTArithmeticGetContext </B><I>context_function</I><B>, 
int </B><I>target_num_bits</I><B>);</B>  <BR>
<B>int QccENTArithmeticEncodeEnd(QccENTArithmeticModel 
*</B><I>model</I><B>, int </B><I>final_context</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>);</B>  <BR>
<B>int QccENTArithmeticEncode(const 
int *</B><I>symbol_stream</I><B>, int </B><I>symbol_stream_length</I><B>, QccENTArithmeticModel *</B><I>model</I><B>, 
QccBitBuffer *</B><I>output_buffer</I><B>);</B>  <BR>
<B>int QccENTArithmeticEncodeFlush(QccENTArithmeticModel 
*</B><I>model</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>);</B>  <BR>
<B>QccENTArithmeticModel *QccENTArithmeticDecodeStart(QccBitBuffer 
*</B><I>input_buffer</I><B>, const int *</B><I>num_symbols</I><B>, int </B><I>num_contexts</I><B>, QccENTArithmeticGetContext 
</B><I>context_function</I><B>, int </B><I>target_num_bits</I><B>);</B>  <BR>
<B>int QccENTArithmeticDecodeRestart(QccBitBuffer 
*</B><I>input_buffer</I><B>, QccENTArithmeticModel *</B><I>model</I><B>, int </B><I>target_num_bits</I><B>);</B>  <BR>
<B>int 
QccENTArithmeticDecode(QccBitBuffer *</B><I>input_buffer</I><B>, QccENTArithmeticModel 
*</B><I>model</I><B>, int *</B><I>symbol_stream</I><B>, int </B><I>symbol_stream_length</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
QccPack 
provides multiple-context adaptive and nonadaptive arithmetic coding with 
an arbitrary number of symbols. For both encoding and decoding, an arithmetic 
coding model of type <B><A HREF="QccENTArithmeticModel.3.html">QccENTArithmeticModel</B>(3)</A>
 is allocated. This model 
contains the probability models for the different contexts which are, 
by default, adapted as coding and decoding progresses. The  <B><A HREF="QccENTArithmeticModel.3.html">QccENTArithmeticModel</B>(3)</A>
 
structure can also contain a pointer to a callback function which is used 
to obtain the context of the current symbol during encoding and decoding, 
and the adaptiveness of the model can be enabled and disabled via calls 
to <B><A HREF="QccENTArithmeticSetModelAdaption.3.html">QccENTArithmeticSetModelAdaption</B>(3)</A>
. <P>
In general, in both encoding and 
decoding, a <I>num_contexts</I> value is specified at the time of arithmetic-coding 
model creation, and this value indicates the number of contexts to be 
used for coding and decoding. <I>num_contexts</I> must be 1 or greater. Additionally, 
an array, <I>num_symbols</I>, is also passed at the time of model creation. <I>num_symbols</I> 
is an array of <I>num_context</I> integers which indicates the number of symbols 
for each context. Finally, during encoding and decoding, valid symbols 
for context <I>i</I> are integers greater than or equal to 0, and less than or 
equal <I>num_symbols</I>[<I>i</I>] - 1. The contexts themselves are assumed to be numbered 
from 0 up to, and including, <I>num_contexts</I> - 1.  
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<B>QccENTArithmeticEncodeStart()</B> 
should be the first function called in the arithmetic-encoding process. 
<B>QccENTArithmeticEncodeStart()</B> allocates a <B><A HREF="QccENTArithmeticModel.3.html">QccENTArithmeticModel</B>(3)</A>
 structure, 
initializes the probability models for each context in the model, and 
returns a pointer to the model. <I>num_contexts</I> gives the number of contexts 
for encoding, <I>num_symbols</I> gives the number of symbols for each context, 
and <I>context_function</I> is a pointer to a callback function of type <B><A HREF="QccENTArithmeticGetContext.3.html">QccENTArithmeticGetContext</B>(3)</A>
 
which is called to obtain the current context. <I>context_function</I> can be 
the <B>NULL</B> pointer, in which case the <I>current_context</I> field of the arithmetic 
model is used to set the current context directly by a calling routine. 
If <I>target_num_bits</I> is different from <B>QCCENT_ANYNUMBITS</B>, then the arithmetic 
coder can be forced to stop outputting bits when the total number of bits 
output to the bitstream (i.e.,  <I>output_buffer</I>-&gt;<I>bit_cnt</I>) is equal to <I>target_num_bits</I>. 
Note that this is a global stopping point; i.e., any bits output before 
the call to <B>QccENTArithmeticEncodeStart()</B> are included when comparing 
the bits output to <I>target_num_bits</I>. For example, when a binary header via 
calls to functions like <B><A HREF="QccBitBufferPutChar.3.html">QccBitBufferPutChar</B>(3)</A>
 is output before starting 
the arithmetic coder, these header bits are included in the total number 
of bits counted. If  <I>target_num_bits</I> is set to <B>QCCENT_ANYNUMBITS</B>, then 
the arithmetic encoded output can have any number of bits output and should 
be explicitly terminated via a call to <B>QccENTArithmeticEncodeEnd()</B>. <P>
<B>QccENTArithmeticEncode()</B> 
performs arithmetic encoding of the stream of symbols, <I>symbol_stream</I>, 
which is an array of valid symbols. <I>symbol_stream_length</I> gives the length 
of the stream to be encoded, while <I>model</I> is the pointer to the  <B>QccENTArithmeticModel</B> 
structure previously returned by the call to <B>QccENTArithmeticEncodeStart()</B>. 
Finally, <I>output_buffer</I> is a pointer to a <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
 structure; this 
<I>output_buffer</I> must already be opened for writing via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. 
If <I>target_num_bits</I>, as set during the initial call to <B>QccENTArithmeticEncodeStart()</B>, 
is not equal to <B>QCCENT_ANYNUMBITS</B>, then <B>QccENTArithmeticEncode()</B> will 
stop outputting bits and return prematurely when <I>output_buffer</I>-&gt;<I>bit_cnt</I> 
is equal to <I>target_num_bits</I>, regardless of whether all symbols in <I>symbol_stream</I> 
have been processed or not. If <I>target_num_bits</I> is equal to <B>QCCENT_ANYNUMBITS</B>, 
then <B>QccENTArithmeticEncode()</B> will return only when all symbols in <I>symbol_stream</I> 
have been processed. If <B>QccENTArithmeticEncode()</B> returns prematurely due 
to <I>target_num_bits</I> being output, then <B>QccENTArithmeticEncode()</B> returns 
with a value of 2; otherwise, it returns a 0 on success, or a 1 on failure. 
<P>
<B>QccENTArithmeticEncodeEnd()</B> terminates arithmetic encoding by encoding 
a special EOF symbol to the bitstream, and then calling <B>QccENTArithmeticEncodeFlush()</B>. 
<I>final_context</I> is the context that is to be used for the EOF symbol. If 
the <I>num_contexts</I> in the arithmetic model is 1 (i.e., single-context coding), 
the value of <I>final_context</I> is ignored. <P>
<B>QccENTArithmeticEncodeFlush()</B> flushes 
the state of the arithmetic encoder. Usually, after the last symbol is 
processed by <B>QccENTArithmeticEncode()</B>, there are several bits that remain 
to be output from the arithmetic encoder. <B>QccENTArithmeticEncodeFlush()</B> 
forces these bits to be output, and then calls <B><A HREF="QccBitBufferFlush.3.html">QccBitBufferFlush</B>(3)</A>
 to 
guarantee that the bits are actually written to the output file. After 
a call to <B>QccENTArithmeticEncodeFlush()</B>, subsequent bits output will start 
on the next byte boundary of the output file; consequently, one can follow 
a call to <B>QccENTArithmeticEncodeFlush()</B> with a subsequent call to <B>QccENTArithmeticEncode()</B> 
to force encoded "blocks" to be "byte-aligned." Note: if such byte-alignment 
is done during encoding, during decoding, the decoder must be "restart" 
at the start of each block with a call to <B>QccENTArithmeticDecodeRestart()</B> 
(see below).  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<B>QccENTArithmeticDecodeStart()</B> should be the first 
function called in the arithmetic-decoding process. For the decoding to 
make sense, the values of <I>num_contexts</I>, and <I>num_symbols</I> should be the 
same as used in encoding, and <I>context_function</I> should be the same function 
used in encoding. <I>target_num_bits</I> can be used to force <B>QccENTArithmeticDecode()</B> 
to return prematurely when  <I>input_buffer</I>-&gt;<I>bit_cnt</I> meets or exceeds <I>target_num_bits</I>. 
<P>
<B>QccENTArithmeticDecode()</B> attempts to decode <I>symbol_stream_length</I> symbols 
from <I>input_buffer</I>. The decoded symbols are placed in the array <I>symbol_stream</I> 
which must be allocated with space sufficient for <I>symbol_stream_length</I> 
symbols prior to the call to <B>QccENTArithmeticDecode()</B>. If <I>target_num_bits</I> 
was not equal to <B>QCCENT_ANYNUMBITS</B> with the immediately preceding call 
to <B>QccENTArithmeticDecodeStart()</B> or <B>QccENTArithmeticDecodeRestart()</B>, then 
<B>QccENTArithmeticDecode()</B> will return prematurely when the <I>input_buffer</I>-&gt;<I>bit_cnt</I> 
meets or exceeds  <I>target_num_bits</I>. That is, <B>QccENTArithmeticDecode()</B> will 
not read past the <I>target_num_bits</I> bit in the bitstream, even if <I>symbol_stream_length</I> 
symbols have not been decoded. If, on the other hand, <I>target_num_bits</I> is 
equal to <B>QCCENT_ANYNUMBITS</B>, <B>QccENTArithmeticDecode()</B> will return when 
<I>symbol_stream_length</I> symbols are decoded. <B>QccENTArithmeticDecode()</B> returns 
2 if the special EOF  symbol is encountered while decoding; 1 if the end 
of the bitstream is reached while decoding; 1 if the <I>target_num_bits</I> bit 
limit is reached; or 0 if no error occurs. <P>
<B>QccENTArithmeticDecodeRestart()</B> 
can be used to start the arithmetic decoder on any byte boundary. That 
is, if, during encoding, <B>QccENTArithmeticEncodeFlush()</B> is used to force 
byte alignment of "blocks" of bits, then one can use  <B><A HREF="fseek.3.html">fseek</B>(3)</A>
 to position 
the bitstream to the byte at the start of the block, and then call <B>QccENTArithmeticDecodeRestart()</B> 
to restart the decoder at the byte-aligned boundary. In this case, <I>target_num_bits</I> 
can be set to <I>input_buffer</I> -&gt; bit_cnt  plus the length (in bits) of the 
block to stop the decoder again after the block has been decoded.  
<H2><A NAME="sect5" HREF="#toc5">MODEL 
ADAPTION </A></H2>
Arithmetic coding can be either adaptive, in which the frequency-count 
information in the arithmetic model is updated after each symbol is encoded, 
or nonadaptive, in which the frequency counts stay static. By default, 
when a model is created, it is set to be an adaptive model, but one can 
enable or disable adaption at any time via calls to <B><A HREF="QccENTArithmeticSetModelAdaption.3.html">QccENTArithmeticSetModelAdaption</B>(3)</A>
. 
<P>
For a nonadaptive model, one can explicitly ("manually") change the frequency-count 
information in the model by passing a probability distribution to the 
model via a call to <B><A HREF="QccENTArithmeticSetModelProbabilities.3.html">QccENTArithmeticSetModelProbabilities</B>(3)</A>
.  
<H2><A NAME="sect6" HREF="#toc6">RETURN VALUE 
</A></H2>
<B>QccENTArithmeticEncode()</B> returns 0 on success, 1 on failure, or 2 in the 
case that encoding is terminated prematurely due to <I>target_num_bits</I> being 
output. <P>
<B>QccENTArithmeticDecode()</B> returns 0 on success, 1 on failure to 
read all requested symbols, or 2 if the special EOF symbol is encountered. 
<P>
<B>QccENTArithmeticEncodeStart()</B> and <B>QccENTArithmeticDecodeStart()</B> return 
 <B>NULL</B> on error, or a pointer to a <B><A HREF="QccENTArithmeticModel.3.html">QccENTArithmeticModel</B>(3)</A>
 structure on 
success. <P>
<B>QccENTArithmeticDecodeRestart()</B> and <B>QccENTArithmeticEncodeFlush()</B> 
return 0 on success, and 1 on failure.  
<H2><A NAME="sect7" HREF="#toc7">EXAMPLES </A></H2>
 
<H3><A NAME="sect8" HREF="#toc8">Single-Context Adaptive 
Arithmetic Coding </A></H3>
Straightforward single-context adaptive encoding.  <BR>
 <P>
Encoder: 
 <blockquote><P>
 /*  ENCODER  */ <BR>
 <P>
 #include "QccPack.h" <BR>
 <P>
 main(int argc, char *argv[]) 
<BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; <BR>
   QccBitBuffer output_buffer; 
<BR>
   QccENTArithmeticModel *model = NULL; <BR>
    <BR>
   QccInit(argc, argv); <BR>
  
 QccBitBufferInitialize(&amp;output_buffer); <BR>
    <BR>
   /*  obtain symbols here 
*/ <BR>
    <BR>
   output_buffer.type = QCCBITBUFFER_OUTPUT; <BR>
   if (QccBitBufferStart(&amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if ((model = QccENTArithmeticEncodeStart(&amp;NUM_SYMBOLS, <BR>
             
                               1, <BR>
                                    
        NULL, <BR>
                                            QCCENT_ANYNUMBITS)) 
== NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticEncodeStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if (QccENTArithmeticEncode(symbol_stream,  <BR>
                        
      SYMBOL_STREAM_LENGTH, <BR>
                              model, <BR>
     
                         &amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticEncodeEnd(model, 
<BR>
                                 0, <BR>
                                 &amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticEncodeEnd()"); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 <P>
 <P>
 <P>
Decoder: 
 <blockquote><P>
 /*  DECODER  */ <BR>
 <P>
 #include "QccPack.h" <BR>
 <P>
 main(int argc, char *argv[]) 
<BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; <BR>
   QccBitBuffer input_buffer; 
<BR>
   QccENTArithmeticModel *model = NULL; <BR>
    <BR>
   QccInit(argc, argv); <BR>
  
 QccBitBufferInitialize(&amp;input_buffer); <BR>
    <BR>
   input_buffer.type = QCCBITBUFFER_INPUT; 
<BR>
   if (QccBitBufferStart(&amp;input_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferStart()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if ((model = QccENTArithmeticDecodeStart(&amp;input_buffer, 
<BR>
                                            &amp;NUM_SYMBOLS, <BR>
             
                               1, <BR>
                                    
        NULL, <BR>
                                            QCCENT_ANYNUMBITS)) 
== NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticDecodeStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if (QccENTArithmeticDecode(&amp;input_buffer, <BR>
                          
    model, <BR>
                              symbol_stream,  <BR>
             
                 SYMBOL_STREAM_LENGTH)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;input_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   /*  output symbols stream 
here  */ <BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 
<H3><A NAME="sect9" HREF="#toc9">Simple Multiple-Context Adaptive Arithmetic 
Coding </A></H3>
Multiple-context adaptive arithmetic coding in which there are two 
contexts, each with the same number of symbols. In this example, the symbols 
are coded in two blocks; the first block is encoded with the first context, 
and the second block is encoded with the second context. The trailing EOF 
symbol is output in the second context.  <BR>
 <P>
Encoder:  <blockquote><P>
 /*  ENCODER  */ <BR>
 <P>
 
#include "QccPack.h" <BR>
 <P>
 #define FIRST_CONTEXT 0 <BR>
 #define SECOND_CONTEXT 
1 <BR>
 <P>
 main(int argc, char *argv[]) <BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; 
<BR>
   QccBitBuffer output_buffer; <BR>
   QccENTArithmeticModel *model = NULL; 
<BR>
    <BR>
   int num_contexts = 2; <BR>
   int num_symbols[2]; <BR>
 <P>
   QccInit(argc, 
argv); <BR>
   QccBitBufferInitialize(&amp;output_buffer); <BR>
    <BR>
   for (context = 
0; context &lt; 2; context++) <BR>
     num_symbols[context] = NUM_SYMBOLS; <BR>
   
     <BR>
   /*  obtain symbols here */ <BR>
    <BR>
   output_buffer.type = QCCBITBUFFER_OUTPUT; 
<BR>
   if (QccBitBufferStart(&amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferStart()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if ((model = QccENTArithmeticEncodeStart(num_symbols, 
<BR>
                                            2, <BR>
                       
                     NULL, <BR>
                                           
 QCCENT_ANYNUMBITS)) == NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error 
calling QccENTArithmeticEncodeStart()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticSetModelContext(model, 
FIRST_CONTEXT)) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelContext()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
 <P>
   
if (QccENTArithmeticEncode(symbol_stream,  <BR>
                           
   FIRST_BLOCK_LENGTH, <BR>
                              model, <BR>
          
                    &amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticSetModelContext(model, 
SECOND_CONTEXT)) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelContext()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
 <P>
   
if (QccENTArithmeticEncode(&amp;symbol_stream[FIRST_BLOCK_LENGTH],  <BR>
       
                       SECOND_BLOCK_LENGTH, <BR>
                          
    model, <BR>
                              &amp;output_buffer)) <BR>
     { <BR>
      
 QccErrorAddMessage("%s: Error calling QccENTArithmeticEncode()", <BR>
    
                      argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if 
(QccENTArithmeticEncodeEnd(model, <BR>
                                 SECOND_CONTEXT, 
<BR>
                                 &amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncodeEnd()"); <BR>
       QccErrorExit(); <BR>
  
   } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferEnd()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   QccENTArithmeticFreeModel(model); 
<BR>
    <BR>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 <P>
 <P>
 <P>
Decoder:  <blockquote><P>
 /*  DECODER  */ <BR>
 <P>
 #include "QccPack.h" 
<BR>
 <P>
 #define FIRST_CONTEXT 0 <BR>
 #define SECOND_CONTEXT 1 <BR>
 <P>
 main(int argc, char 
*argv[]) <BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; <BR>
   QccBitBuffer 
input_buffer; <BR>
   QccENTArithmeticModel *model = NULL; <BR>
    <BR>
   int num_contexts 
= 2; <BR>
   int num_symbols[2]; <BR>
 <P>
   QccInit(argc, argv); <BR>
   QccBitBufferInitialize(&amp;input_buffer); 
<BR>
    <BR>
   for (context = 0; context &lt; 2; context++) <BR>
     num_symbols[context] 
= NUM_SYMBOLS; <BR>
        <BR>
   input_buffer.type = QCCBITBUFFER_INPUT; <BR>
   if 
(QccBitBufferStart(&amp;input_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferStart()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if ((model = QccENTArithmeticDecodeStart(&amp;input_buffer, 
<BR>
                                            num_symbols, <BR>
             
                               2, <BR>
                                    
        NULL, <BR>
                                            QCCENT_ANYNUMBITS)) 
== NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticDecodeStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if (QccENTArithmeticSetModelContext(model, FIRST_CONTEXT)) <BR>
     { <BR>
 
      QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelContext()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
 <P>
   
if (QccENTArithmeticDecode(&amp;input_buffer, <BR>
                             
 model, <BR>
                              symbol_stream,  <BR>
                
              FIRST_BLOCK_LENGTH)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticSetModelContext(model, 
SECOND_CONTEXT)) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelContext()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
 <P>
   
if (QccENTArithmeticDecode(&amp;input_buffer, <BR>
                             
 model, <BR>
                              &amp;symbol_stream[FIRST_BLOCK_LENGTH], 
 <BR>
                              SECOND_BLOCK_LENGTH)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;input_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   /*  output symbols stream 
here  */ <BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 
<H3><A NAME="sect10" HREF="#toc10">Multiple-Context Adaptive Arithmetic Coding 
</A></H3>
Multiple-context adaptive arithmetic coding in which the previous symbol 
is used as the context of the current symbol. This coder would be a reasonable 
choice for a Markov process. Note that the number of contexts is equal 
to the number of symbols.  <BR>
 <P>
Encoder:  <blockquote><P>
 /*  ENCODER  */ <BR>
 <P>
 #include "QccPack.h" 
<BR>
 <P>
 int get_current_context(const int *symbol_stream, <BR>
                  
       int current_symbol) <BR>
 { <BR>
   if ((symbol_stream == NULL) || (current_symbol 
&lt;= 0)) <BR>
     return(0); <BR>
 <P>
   return(symbol_stream[current_symbol - 1]); <BR>
 } 
<BR>
 <P>
 <P>
 main(int argc, char *argv[]) <BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; 
<BR>
   QccBitBuffer output_buffer; <BR>
   QccENTArithmeticModel *model = NULL; 
<BR>
    <BR>
   int num_contexts = NUM_SYMBOLS; <BR>
   int num_symbols[NUM_SYMBOLS]; 
<BR>
    <BR>
   QccInit(argc, argv); <BR>
   QccBitBufferInitialize(&amp;output_buffer); 
<BR>
    <BR>
   for (context = 0; context &lt; NUM_SYMBOLS; context++) <BR>
     num_symbols[context] 
= NUM_SYMBOLS; <BR>
        <BR>
   /*  obtain symbols here */ <BR>
    <BR>
   output_buffer.type 
= QCCBITBUFFER_OUTPUT; <BR>
   if (QccBitBufferStart(&amp;output_buffer)) <BR>
     { 
<BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferStart()", <BR>
   
                       argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   
if ((model = QccENTArithmeticEncodeStart(num_symbols, <BR>
                
                            num_contexts, <BR>
                            
                get_current_context, <BR>
                                 
           QCCENT_ANYNUMBITS)) == NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncodeStart()", <BR>
                        
  argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticEncode(symbol_stream, 
 <BR>
                              SYMBOL_STREAM_LENGTH, <BR>
                 
             model, <BR>
                              &amp;output_buffer)) <BR>
    
 { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticEncode()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if (QccENTArithmeticEncodeEnd(model, <BR>
                              
   0, <BR>
                                 &amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncodeEnd()"); <BR>
       QccErrorExit(); <BR>
  
   } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferEnd()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   QccENTArithmeticFreeModel(model); 
<BR>
    <BR>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 <P>
 <P>
 <P>
Decoder:  <blockquote><P>
 /*  DECODER  */ <BR>
 <P>
 #include "QccPack.h" 
<BR>
 <P>
 int get_current_context(const int *symbol_stream, <BR>
                  
       int current_symbol) <BR>
 { <BR>
   if ((symbol_stream == NULL) || (current_symbol 
&lt;= 0)) <BR>
     return(0); <BR>
 <P>
   return(symbol_stream[current_symbol - 1]); <BR>
 } 
<BR>
 <P>
 <P>
 main(int argc, char *argv[]) <BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; 
<BR>
   QccBitBuffer input_buffer; <BR>
   QccENTArithmeticModel *model = NULL; 
<BR>
 <P>
   int num_contexts = NUM_SYMBOLS; <BR>
   int num_symbols[NUM_SYMBOLS]; <BR>
 
   <BR>
   QccInit(argc, argv); <BR>
   QccBitBufferInitialize(&amp;input_buffer); <BR>
  
  <BR>
   for (context = 0; context &lt; NUM_SYMBOLS; context++) <BR>
     num_symbols[context] 
= NUM_SYMBOLS; <BR>
        <BR>
   input_buffer.type = QCCBITBUFFER_INPUT; <BR>
   if 
(QccBitBufferStart(&amp;input_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccBitBufferStart()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if ((model = QccENTArithmeticDecodeStart(&amp;input_buffer, 
<BR>
                                            num_symbols, <BR>
             
                               num_contexts, <BR>
                         
                   get_current_context, <BR>
                              
              QCCENT_ANYNUMBITS)) == NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecodeStart()", <BR>
                        
  argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticDecode(&amp;input_buffer, 
<BR>
                              model, <BR>
                              symbol_stream, 
 <BR>
                              SYMBOL_STREAM_LENGTH)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;input_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   /*  output symbols stream 
here  */ <BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 
<H3><A NAME="sect11" HREF="#toc11">Single-Context Nonadaptive Arithmetic Coding 
</A></H3>
Straightforward single-context nonadaptive encoding. Note that adaptive 
coding is used by default, so we merely need to disable adaption before 
coding begins.  <BR>
 <P>
Encoder:  <blockquote><P>
 /*  ENCODER  */ <BR>
 <P>
 #include "QccPack.h" <BR>
 <P>
 main(int 
argc, char *argv[]) <BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; <BR>
   
QccBitBuffer output_buffer; <BR>
   QccENTArithmeticModel *model = NULL; <BR>
  
 double probabilities[NUM_SYMBOLS]; <BR>
    <BR>
   QccInit(argc, argv); <BR>
   QccBitBufferInitialize(&amp;output_buffer); 
<BR>
    <BR>
   /*  obtain symbols and their probabilities somehow here */ <BR>
    
<BR>
   output_buffer.type = QCCBITBUFFER_OUTPUT; <BR>
   if (QccBitBufferStart(&amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if ((model = QccENTArithmeticEncodeStart(&amp;NUM_SYMBOLS, <BR>
             
                               1, <BR>
                                    
        NULL, <BR>
                                            QCCENT_ANYNUMBITS)) 
== NULL) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticEncodeStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticSetModelAdaption(model, QCCENT_NONADAPTIVE); <BR>
   if 
(QccENTArithmeticSetModelProbabilities(model, <BR>
                        
                     probabilities, <BR>
                                  
           0)) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelProbabilities()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   if (QccENTArithmeticEncode(symbol_stream,  <BR>
                        
      SYMBOL_STREAM_LENGTH, <BR>
                              model, <BR>
     
                         &amp;output_buffer)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticEncode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccENTArithmeticEncodeEnd(model, 
<BR>
                                 0, <BR>
                                 &amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticEncodeEnd()"); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;output_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 <P>
 <P>
 <P>
Decoder: 
 <blockquote><P>
 /*  DECODER  */ <BR>
 <P>
 #include "QccPack.h" <BR>
 <P>
 main(int argc, char *argv[]) 
<BR>
 { <BR>
   int symbol_stream[SYMBOL_STREAM_LENGTH]; <BR>
   QccBitBuffer input_buffer; 
<BR>
   QccENTArithmeticModel *model = NULL; <BR>
   double probabilities[NUM_SYMBOLS]; 
<BR>
    <BR>
   QccInit(argc, argv); <BR>
   QccBitBufferInitialize(&amp;input_buffer); <BR>
 
   <BR>
   /*  obtain symbol probabilities somehow here */ <BR>
 <P>
   input_buffer.type 
= QCCBITBUFFER_INPUT; <BR>
   if (QccBitBufferStart(&amp;input_buffer)) <BR>
     { <BR>
 
      QccErrorAddMessage("%s: Error calling QccBitBufferStart()", <BR>
    
                      argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if 
((model = QccENTArithmeticDecodeStart(&amp;input_buffer, <BR>
                  
                          &amp;NUM_SYMBOLS, <BR>
                               
             1, <BR>
                                            NULL, <BR>
    
                                        QCCENT_ANYNUMBITS)) == NULL) <BR>
 
    { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticDecodeStart()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticSetModelAdaption(model, QCCENT_NONADAPTIVE); <BR>
   if 
(QccENTArithmeticSetModelProbabilities(model, <BR>
                        
                     probabilities, <BR>
                                  
           0)) <BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccENTArithmeticSetModelProbabilities()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
 <P>
   
if (QccENTArithmeticDecode(&amp;input_buffer, <BR>
                             
 model, <BR>
                              symbol_stream,  <BR>
                
              SYMBOL_STREAM_LENGTH)) <BR>
     { <BR>
       QccErrorAddMessage("%s: 
Error calling QccENTArithmeticDecode()", <BR>
                          argv[0]); 
<BR>
       QccErrorExit(); <BR>
     } <BR>
    <BR>
   if (QccBitBufferEnd(&amp;input_buffer)) 
<BR>
     { <BR>
       QccErrorAddMessage("%s: Error calling QccBitBufferEnd()", 
<BR>
                          argv[0]); <BR>
       QccErrorExit(); <BR>
     } <BR>
    
<BR>
   QccENTArithmeticFreeModel(model); <BR>
    <BR>
   /*  output symbols stream 
here  */ <BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
 
<H2><A NAME="sect12" HREF="#toc12">NOTES </A></H2>
If <B>QccENTArithmetocEncodeStart()</B> is 
called using <I>target_num_bits</I> equal to other than <B>QCCENT_ANYNUMBITS</B> in 
order to output exactly  <I>target_num_bits</I> (in which case, <B>QccENTArithmeticEncodeEnd()</B> 
is usually <I>not</I> called at the end of the bitstream), then the last few 
symbols decoded by <B>QccENTArithmeticDecode()</B> as it nears the end of the 
bitstream will be valid symbols, but may not be exactly the same as the 
last few symbols passed to <B>QccENTArithmeticEncode()</B>. This discrepancy is 
due to the fact that the arithmetic encoder probably had not completely 
flushed its state to the bitstream when the <I>target_num_bits</I> threshold 
was reached. Thus, the decoder may decode a few symbols erroneously before 
it realizes that it has encountered the end of the bitstream, since the 
decoder needs the complete encoder state (which is unknown because it 
was not flushed to the bitstream) to decode accurately. Usually, this is 
not a problem in applications since the <I>target_num_bits</I> capability is 
most likely only of use in lossy compression, and the erroneously decoded 
symbols at the end of the bitstream can be viewed as contributing negligible 
additional distortion to the lossy representation.  
<H2><A NAME="sect13" HREF="#toc13">SEE ALSO </A></H2>
<B><A HREF="QccENTArithmeticModel.3.html">QccENTArithmeticModel</B>(3)</A>
, 
<B><A HREF="QccENTArithmeticGetContext.3.html">QccENTArithmeticGetContext</B>(3)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccPackENT.3.html">QccPackENT</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 
<P>
I. H. Witten, R. M. Neal, and J. G. Cleary, "Arithmetic Coding for Data Compression," 
<I>Communications of the ACM</I>, vol. 30, no. 6, pp. 520-540, June 1987.  
<H2><A NAME="sect14" HREF="#toc14">AUTHOR 
</A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">MODEL ADAPTION</A></LI>
<LI><A NAME="toc6" HREF="#sect6">RETURN VALUE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">EXAMPLES</A></LI>
<UL>
<LI><A NAME="toc8" HREF="#sect8">Single-Context Adaptive Arithmetic Coding</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Simple Multiple-Context Adaptive Arithmetic Coding</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Multiple-Context Adaptive Arithmetic Coding</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Single-Context Nonadaptive Arithmetic Coding</A></LI>
</UL>
<LI><A NAME="toc12" HREF="#sect12">NOTES</A></LI>
<LI><A NAME="toc13" HREF="#sect13">SEE ALSO</A></LI>
<LI><A NAME="toc14" HREF="#sect14">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
