<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccENTExponentialGolombDecode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccENTExponentialGolombEncode, QccENTExponentialGolombDecode, QccENTExponentialGolombEncodeSymbol, 
QccENTExponentialGolombDecodeSymbol -  exponential-Golomb encoding and decoding 
 
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccENTExponentialGolombEncode(QccBitBuffer 
*</B><I>output_buffer</I><B>, const int *</B><I>symbols</I><B>, int </B><I>num_symbols</I><B>, int </B><I>signed_symbols</I><B>);</B> 
 <BR>
<B>int QccENTExponentialGolombDecode(QccBitBuffer *</B><I>input_buffer</I><B>, int *</B><I>symbols</I><B>, 
int </B><I>num_symbols</I><B>, int </B><I>signed_symbols</I><B>);</B>  <P>
<B>int QccENTExponentialGolombEncodeSymbol(QccBitBuffer 
*</B><I>output_buffer</I><B>, int </B><I>symbol</I><B>, int </B><I>signed_symbol</I><B>);</B>  <BR>
<B>int QccENTExponentialGolombDecodeSymbol(QccBitBuffer 
*</B><I>input_buffer</I><B>, int *</B><I>symbol</I><B>, int </B><I>signed_symbol</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccENTExponentialGolombEncode()</B> 
performs exponential-Golomb coding of the symbol stream in <I>symbols</I>, outputting 
the binary codewords to <I>output_buffer</I>. <I>num_symbols</I> indicates how many symbols 
are in the symbol stream (which can be as short as one symbol). <I>signed_symbols</I> 
indicates whether the symbols in the symbol stream are signed integers 
(<I>signed_symbols</I> = 1)<I></I> or unsigned integers (<I>signed_symbols</I> = 0).<I></I> <I>output_buffer</I> 
must be a <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
 that has been opened for writing prior to calling 
<B>QccENTExponentialGolombEncode()</B>. After calling <B>QccENTExponentialGolombEncode()</B>, 
<B><A HREF="QccBitBufferFlush.3.html">QccBitBufferFlush</B>(3)</A>
 must be called to ensure that the last few bits of 
the bitstream are actually written to the output file. <P>
<B>QccENTExponentialGolombDecode()</B> 
performs exponential-Golomb decoding of the bits in the bitstream <I>input_buffer</I>, 
producing an output stream of symbols that are stored in <I>symbols</I>. The  
<I>symbols</I> array must be allocated with space sufficient for holding <I>num_symbols</I> 
integers; this allocation must be done prior to calling <B>QccENTExponentialGolombDecode()</B>. 
Additionally, <I>input_buffer</I> must be opened for reading prior to calling 
<B>QccENTExponentialGolombDecode()</B>. <P>
<B>QccENTExponentialGolombEncodeSymbol()</B> 
and <B>QccENTExponentialGolombDecodeSymbol()</B> encode and decode a single symbol. 
<B>QccENTExponentialGolombEncode()</B> and <B>QccENTExponentialGolombDecode()</B> are 
implemented simply as repeated calls to <B>QccENTExponentialGolombEncodeSymbol()</B> 
and <B>QccENTExponentialGolombDecodeSymbol()</B>, respectively.  
<H2><A NAME="sect3" HREF="#toc3">NOTES </A></H2>
Golomb 
coding was originally proposed by Golomb in 1966, and a special case of 
Golomb coding with the Golomb-coding parameter constrained to be a power 
of 2 was proposed independently by Rice in 1979, with these latter codes 
often called Rice codes or Golomb-Rice codes. Exponential-Golomb codes were 
proposed by Teuhola as another variant of Golomb codes similar to Rice 
codes with the property that the number of codes with a given length grows 
exponentially with the length. The implementation of exponential-Golomb 
coding follows that described in the H.264 standard (Sec. 9.1). Although the 
codeword lengths produced by this implementation are exactly the same 
as in H.264, the actual codewords are somewhat different.  
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUE 
</A></H2>
These routines return 0 on success, and 1 on failure.  
<H2><A NAME="sect5" HREF="#toc5">SEE ALSO </A></H2>
<B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, 
<B><A HREF="QccPackENT.3.html">QccPackENT</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
S. W. Golomb, "Run-Length Encodings," <I>IEEE Transactions 
on Information Theory</I>, vol. 12, pp. 399-401, July 1966. <P>
R. F. Rice, "Some Practical 
Universal Noiseless Coding Techniques," Tech. Rep. JPL-79-22, Jet Propulsion 
Laboratory, Pasadena, CA, March 1979. <P>
J. Teuhola, "A Compression Method 
for Clustered Bit-Vectors," <I>Information Processing Letters</I>, vol. 7, pp. 308-311, 
October 1978. <P>
ITU-T, <I>Advanced Video Coding for Generic Audiovisual Services</I>, 
May 2003, ITU-T Recommendation H.264.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 1997-2016  James 
E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">NOTES</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUE</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
