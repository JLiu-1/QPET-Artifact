<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccMatrixRowExchange.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccMatrixAlloc, QccMatrixFree, QccMatrixZero, QccMatrixResize, QccMatrixCopy, 
QccMatrixMaxValue, QccMatrixMinValue, QccMatrixPrint, QccMatrixRowExchange, 
QccMatrixColExchange, QccMatrixIdentity, QccMatrixTranpose, QccMatrixAdd, 
QccMatrixSubtract, QccMatrixMean, QccMatrixMaxSignalPower - miscellaneous 
matrix routines  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>QccMatrix QccMatrixAlloc(int 
</B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>void QccMatrixFree(QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>);</B> 
 <BR>
 <P>
<B>int QccMatrixZero(QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>QccMatrix 
QccMatrixResize(QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>new_num_rows</I><B>, 
int </B><I>new_num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixCopy(QccMatrix </B><I>matrix1</I><B>, const QccMatrix 
</B><I>matrix2</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>double QccMatrixMaxValue(const 
QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>double QccMatrixMinValue(const 
QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixPrint(const 
QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixRowExchange(QccMatrix 
</B><I>matrix</I><B>, int </B><I>num_cols</I><B>, int </B><I>row1</I><B>, int </B><I>row2</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixColExchange(QccMatrix 
</B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>col1</I><B>, int </B><I>col2</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixIdentity(QccMatrix 
</B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixTranspose(const QccMatrix 
</B><I>matrix1</I><B>, QccMatrix </B><I>matrix2</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixAdd(QccMatrix 
</B><I>matrix1</I><B>, const QccMatrix </B><I>matrix2</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>int QccMatrixSubtract(QccMatrix 
</B><I>matrix1</I><B>, const QccMatrix </B><I>matrix2</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>double 
QccMatrixMean(const QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B>  <BR>
 <P>
<B>double 
QccMatrixVariance(const QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>);</B> 
 <BR>
 <P>
<B>double QccMatrixMaxSignalPower(const QccMatrix </B><I>matrix</I><B>, int </B><I>num_rows</I><B>, 
int </B><I>num_cols</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
QccPack library routines use two-dimensional 
matrices of type  <B>QccMatrix</B> which is defined as  <blockquote>typedef QccVector *QccMatrix; 
<BR>
  </blockquote>
<P>
<B>QccMatrixAlloc()</B> allocates a <B>QccMatrix</B> consisting of  <I>num_rows</I> vectors; 
each vector is of type <B>QccVector</B> and has dimension <I>num_cols</I>. <B>QccMatrixAlloc()</B> 
returns a <B>NULL</B> pointer if the allocation fails. <P>
<B>QccMatrixFree()</B> frees a 
<B>QccMatrix</B> previously allocated by <B>QccMatrixAlloc()</B>. <P>
<B>QccMatrixZero()</B> makes 
each element of  <I>matrix</I> zero. <P>
<B>QccMatrixResize()</B> changes the size of <I>matrix</I> 
from <I>num_rows</I> x <I>num_cols</I> to <I>new_num_rows</I> x <I>new_num_cols</I> by calling <B><A HREF="realloc.3.html">realloc</B>(3)</A>
 
and <B><A HREF="QccVectorResize.3.html">QccVectorResize</B>(3)</A>
. Upon success, the new matrix is returned; a <B>NULL</B> 
pointer is returned if  <B><A HREF="realloc.3.html">realloc</B>(3)</A>
 or <B><A HREF="QccVectorResize.3.html">QccVectorResize</B>(3)</A>
 fails. If <I>matrix</I> 
is <B>NULL</B>, <B>QccMatrixAlloc()</B> is called. In any case, all elements added to 
<I>matrix</I> are zero. <P>
<B>QccMatrixCopy()</B> copies <I>matrix2</I> to <I>matrix1</I>. <P>
<B>QccMatrixMaxValue()</B> 
returns the largest element in <I>matrix</I>. <P>
<B>QccMatrixMinValue()</B> returns the 
smallest element in <I>matrix</I>. <P>
<B>QccMatrixPrint()</B> prints the elements of <I>matrix</I> 
to stdout. <P>
<B>QccMatrixRowExchange()</B> exchanges rows <I>row1</I> and <I>row2</I> in <I>matrix</I>. 
<P>
<B>QccMatrixColExchange()</B> exchanges columns <I>col1</I> and <I>col2</I> in <I>matrix</I>. <P>
<B>QccMatrixIdentity()</B> 
sets all entries of <I>matrix</I> to 0, except along the diagonal, where the 
diagonal entries are set to 1. In the case that <I>num_rows</I> and  <I>num_cols</I> 
are equal (i.e., the matrix is square), <I>matrix</I> will be the <I>num_rows</I> by <I>num_rows</I> 
identity matrix. <P>
<B>QccMatrixTranspose()</B> computes the transpose of <I>matrix1</I>, 
storing the result as <I>matrix2</I>, which must be previously allocated. It is 
assumed that  <I>matrix2</I> is of the proper size (i.e., <I>num_cols</I> rows by <I>num_rows</I> 
columns). <P>
<B>QccMatrixAdd()</B> adds each component of <I>matrix1</I>  to the corresponding 
component of <I>matrix2</I>, returning the resulting matrix in <I>matrix1</I>. <I>matrix1</I> 
and <I>matrix2</I> must be the same size. <P>
<B>QccMatrixSubtract()</B> subtracts each component 
of <I>matrix2</I> from the corresponding component of <I>matrix1</I>, returning the 
resulting matrix in <I>matrix1</I>. <I>matrix1</I> and <I>matrix2</I> must be the same size. 
<P>
<B>QccMatrixMean()</B> calculates the mean of the elements in <I>matrix</I>. <P>
<B>QccMatrixVariance()</B> 
calculates the variance of the elements in <I>matrix</I>. <P>
<B>QccMatrixMaxSignalPower()</B> 
calculates the squared norm of each row vector in <I>matrix</I> and returns the 
largest one.  
<H2><A NAME="sect3" HREF="#toc3">SEE ALSO </A></H2>
<B><A HREF="QccVector.3.html">QccVector</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
  
<H2><A NAME="sect4" HREF="#toc4">AUTHOR </A></H2>
Copyright (C) 1997-2016 
 James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">SEE ALSO</A></LI>
<LI><A NAME="toc4" HREF="#sect4">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
