<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccFifoFlush.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccFifo - data structure for bitstream fifo  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccFifoInitialize(QccFifo *</B><I>fifo</I><B>);</B>  <BR>
<B>int QccFifoStart(QccFifo *</B><I>fifo</I><B>);</B> 
 <BR>
<B>int QccFifoEnd(QccFifo *</B><I>fifo</I><B>);</B>  <BR>
<B>int QccFifoFlush(QccFifo *</B><I>fifo</I><B>);</B>  <BR>
<B>int 
QccFifoRestart(QccFifo *</B><I>fifo</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
QccPack provides the <B>QccFifo</B> 
data structure to provide first-in, first-out operation on bitstreams. That 
is, a bitstream can be written to <I>fifo</I> and then read from <I>fifo</I> with the 
bits read out in the same order they were written in.  
<H2><A NAME="sect3" HREF="#toc3">DATA STRUCTURE </A></H2>
The 
<B>QccFifo</B> data structure is defined as:  <blockquote><P>
 typedef struct <BR>
 { <BR>
   QccBitBuffer 
output_buffer; <BR>
   QccBitBuffer input_buffer; <BR>
 } QccFifo; <BR>
  </blockquote>
<P>
The fields 
of <B>QccFifo</B> are as follows: 
<DL>

<DT><I>output_buffer</I>  </DT>
<DD>The <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
 structure 
to which the bitstream is written. </DD>

<DT><I>input_buffer</I>  </DT>
<DD>The <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
 structure 
from which the bitstream is read. </DD>
</DL>
 
<H2><A NAME="sect4" HREF="#toc4">ROUTINES </A></H2>
<B>QccFifoInitialize()</B> should 
be called before any use of a <B>QccFifo</B> structure. <B>QccFifoInitialize()</B> initializes 
the <I>input_buffer</I> and <I>output_buffer</I> fields via calls to <B><A HREF="QccBitBufferInitialize.3.html">QccBitBufferInitialize</B>(3)</A>
. 
<P>
<B>QccFifoStart()</B> starts both <I>input_buffer</I> and <I>output_buffer</I> via calls to 
<B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccFifoEnd()</B> should be called after all accesses 
(read or write) to <I>fifo</I> are complete. <B>QccFifoEnd()</B> calls <B><A HREF="QccBitBufferEnd.3.html">QccBitBufferEnd</B>(3)</A>
 
to stop both buffers. <P>
<B>QccFifoFlush()</B> should be called at the end of writing 
a bitstream after all bits have been written but before  <B>QccFifoEnd()</B> 
is called. <B>QccFifoFlush()</B> ensures that the last byte being packed with 
bits, which may not be full, is output to the fifo by calling <B><A HREF="QccBitBufferFlush.3.html">QccBitBufferFlush</B>(3)</A>
 
on both buffers. <P>
Once <B><A HREF="QccFifoStart.3.html">QccFifoStart</B>(3)</A>
 has been called, any of the usual 
bit-buffer routines for reading (e.g., <B><A HREF="QccBitBufferReadChar.3.html">QccBitBufferReadChar</B>(3)</A>
, <B><A HREF="QccBitBufferReadInt.3.html">QccBitBufferReadInt</B>(3)</A>
) 
or writing (e.g., <B><A HREF="QccBitBufferWriteChar.3.html">QccBitBufferWriteChar</B>(3)</A>
, <B><A HREF="QccBitBufferWriteInt.3.html">QccBitBufferWriteInt</B>(3)</A>
) can 
be called on the <I>input_buffer</I> and <I>output_buffer</I> fields of the fifo. The 
bits are read out of <I>input_buffer</I> in the same order they were written 
into <I>output_buffer</I>, so one or more calls to write to <I>output_buffer</I> should 
precede the first call to read from <I>input_buffer</I>. <P>
<B>QccFifoRestart()</B> restarts 
<I>fifo</I> by calling <B>QccFifoEnd()</B> and <B>QccFifoStart()</B> in succession. Any data 
currently held in <I>fifo</I> is lost; that is, the <I>fifo</I> is emptied.  
<H2><A NAME="sect5" HREF="#toc5">IMPLEMENTATION 
</A></H2>
The fifo operation within the <B>QccFifo</B> structure is implemented with a 
pipe created by a call to <B><A HREF="pipe.2.html">pipe</B>(2)</A>
 during the call to <B>QccFifoStart()</B>. Specifically, 
<I>fileptr</I> of <I>output_buffer</I> is set to the write end of the pipe, while <I>fileptr</I> 
of <I>input_buffer</I> is set to the read end. Consequently, <I>input_buffer</I> is joined 
to <I>output_buffer</I> through this pipe. <B><A HREF="QccFileDescriptorOpen.3.html">QccFileDescriptorOpen</B>(3)</A>
 is called 
to create file streams for the file descriptors returned by <B><A HREF="pipe.2.html">pipe</B>(2)</A>
, and 
<B><A HREF="fcntl.2.html">fcntl</B>(2)</A>
 is used to set both ends of the pipe to non-blocking. <P>
As a consequence 
of the use of <B><A HREF="pipe.2.html">pipe</B>(2)</A>
 to implement the fifo, there is a limit to amount 
of bits that may be held in the fifo at any given time. Unfortunately, 
this limit is system-dependent. On POSIX-compliant systems, the pipe is required 
to be capable of holding at least <B>PIPE_BUF</B> bytes, and <B>PIPE_BUF</B> must be 
at least 512 bytes. This means that, on a POSIX-compliant system, at least 
4096 bits can be written to a <B>QccFifo</B> structure before bits must be read 
out. <P>
Attempts to write to a full fifo (one already containing the system-dependent 
maximum number of bits) will return in error, as will attempts to read 
from an empty fifo. It is the responsibility of the calling application 
to avoid fifo overflow and underflow, and the calling application should 
do so without trying to determine the maximum size of the fifo, as there 
does not seem to be a reliable system-independent way of doing so.  
<H2><A NAME="sect6" HREF="#toc6">RETURN 
VALUE </A></H2>
Each of these routines return 0 upon successful completion, 1 on 
error.  
<H2><A NAME="sect7" HREF="#toc7">SEE ALSO </A></H2>
<B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccFileDescriptorOpen.3.html">QccFileDescriptorOpen</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
, 
<B><A HREF="pipe.2.html">pipe</B>(2)</A>
, <B><A HREF="fcntl.2.html">fcntl</B>(2)</A>
  
<H2><A NAME="sect8" HREF="#toc8">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">DATA STRUCTURE</A></LI>
<LI><A NAME="toc4" HREF="#sect4">ROUTINES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">IMPLEMENTATION</A></LI>
<LI><A NAME="toc6" HREF="#sect6">RETURN VALUE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">SEE ALSO</A></LI>
<LI><A NAME="toc8" HREF="#sect8">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
