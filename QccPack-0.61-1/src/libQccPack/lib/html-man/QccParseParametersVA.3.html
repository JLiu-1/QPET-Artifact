<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccParseParametersVA.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccParseParameters - parsing of command-line parameters  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS 
</A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccParseParameters(int </B><I>argc</I><B>, char *</B><I>argv</I><B>[], 
const char *</B><I>format</I><B>, ...);</B>  <BR>
<B>int QccParseParametersVA(int </B><I>argc</I><B>, char *</B><I>argv</I><B>[], 
const char *</B><I>format</I><B>, va_list </B><I>ap</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccParseParameters()</B> parses 
the command-line parameters passed to it via <I>argc</I> and  <I>argv</I> according to 
a <I>format</I> string. Pointers, which follow  <I>format</I>  and are accessed via the 
variable-length argument facilities of <B><A HREF="stdarg.3.html">stdarg</B>(3)</A>
, point to the storage 
locations for values of the parsed parameters; the composition of <I>format</I> 
describes the type and sizes of these parameter values. <P>
<B>QccParseParametersVA()</B> 
functions indentically to <B>QccParseParameters()</B>, except that <B>QccParseParametersVA()</B> 
can be called from a function whose own argument list contains a variable 
number of arguments implemented via the variable-length argument facilities 
of <B><A HREF="stdarg.3.html">stdarg</B>(3)</A>
.  
<H2><A NAME="sect3" HREF="#toc3">FORMAT STRING </A></H2>
<I>format</I> is a null-terminated string that specifies 
the sequence of expected command-line parameters. The <I>format</I> string consists 
of the specification of zero or more optional parameters followed by the 
specification of zero or more mandatory parameters.  
<H3><A NAME="sect4" HREF="#toc4">OPTIONAL PARAMETERS 
</A></H3>
The normal usage of an optional-parameter specification in <I>format</I> is to 
denote that a switch may appear on the command line followed by a value 
(e.g.,  <B>-num_levels 32</B> or <B>-filename foo.bar</B>). An optional parameter is specified 
in the <I>format</I> string by giving the switch expected on the command-line 
 (e.g., <B>-num_levels</B>, <B>-filename</B>), and indicating the type  (<B>float</B>, <B>int</B>, etc.) 
of the value associated with the switch. It is assumed that the corresponding 
pointer (in the variable-length argument list that follows <I>format)</I> points 
memory that is already allocated in the size needed to accommodate the 
storage of a value of the specified type. <P>
Optional parameters can be given 
in any order on the command line. <B>QccParseParameters()</B> will search through 
all optional-parameter specifications in <I>format</I> and store the value given 
on the command line in the location pointed to by the appropriate pointer. 
Note: if an optional parameter is not found on the command line, <B>QccParseParameters()</B> 
leaves the value pointed to by the pointer unchanged. <P>
An optional parameter 
is specified in  <I>format</I>  in the following form: <B>[-</B><I>switch</I><B> </B><I>flag</I><B>:</B><I>name</I><B>]</B> <P>
<I>switch</I> 
is the option that appears on the command line (preceded by a `-') to indicate 
the presence of the optional parameter. <P>
<I>name</I> is an optional label for the 
value of the parameter; In the case of an error, <I>name</I> will be used to 
denote the value of the parameter in a usage statement. <P>
<I>switch</I> and <I>name</I> 
can contain any sequence of characters, except `-', `%', `*', `[', `]', `:', `.', tabs, 
newlines, carriage returns, single quotes, double quotes, or spaces. <P>
<I>flag</I> 
indicates the type of the parameter value. Possible <I>flag</I> values are given 
below.  
<H3><A NAME="sect5" HREF="#toc5">MANDATORY PARAMETERS </A></H3>
Whereas optional parameters may or may not 
appear on the command line, the presence of mandatory parameters is required. 
The specification of all mandatory parameters must follow that of all 
optional parameters in <I>format</I>. The mandatory parameters must appear on 
the command line in exactly the order that they are specified in  <I>format</I> 
or an error will be generated. <P>
A mandatory parameter is specified in <I>format</I> 
in the following form: <I>flag</I><B>:</B><I>name</I> <P>
<P>
<I>name</I> is an optional label for the value 
of the parameter; In the case of an error, <I>name</I> will be used to denote 
the value of the parameter in a usage statement. <I>name</I> can contain any sequence 
of characters, except `-', `%', `*', `[', `]', `:', `.', tabs, newlines, carriage returns, 
single quotes, double quotes, or spaces. <P>
<I>flag</I> indicates the type of the 
parameter value. Possible <I>flag</I> values are given below.  
<H3><A NAME="sect6" HREF="#toc6">FLAGS </A></H3>
Possible <I>flag</I> 
values for both optional and mandatory parameters are as follows: 
<DL>

<DT><B>%d</B>  
</DT>
<DD>optionally signed integer. The corresponding pointer must be a pointer 
to <B>int</B>. </DD>

<DT><B>%u</B>  </DT>
<DD>unsigned integer. The corresponding pointer must be a pointer 
to <B>unsigned int</B>. </DD>

<DT><B>%f</B>, <B>%e</B>, <B>%g</B>  </DT>
<DD>optionally signed floating-point number. The 
corresponding pointer must be a pointer to <B>float</B>. </DD>

<DT><B>%s</B>  </DT>
<DD>a sequence of non-white-space 
characters. The corresponding pointer must of type <B>QccString</B> (i.e., a pointer 
to <B>char</B>) and the array must be large enough to accept the whole sequence 
plus the terminating <B>NULL</B> character (i.e.,  <B>QCCSTRING + 1</B> characters long). 
Strings appearing on the command line (i.e., in  <I>argv</I>)<I></I> are truncated by 
<B>QccParseParameters</B> to a maximum length of  <B>QCCSTRINGLEN</B> characters; consequently, 
it is safe to pass a variable of type <B>QccString</B> (see <B><A HREF="QccConvertToQccString.3.html">QccConvertToQccString</B>(3)</A>
) 
to <B>QccParseParameters()</B> without fear of a buffer overrun. </DD>

<DT><B>%</B>  </DT>
<DD>presence indicator. 
The presence indicator,  a single <B>%</B> as <I>flag</I>, is valid only for optional 
parameters and indicates merely whether the optional parameter was found 
on the command line; there is no value associated with the parameter. Instead, 
a pointer to  <B>int</B> must be given in the variable-length argument list. Upon 
return of <B>QccParseParameters()</B>, this integer value will be set to 1 if 
the optional parameter appears on the command-line; otherwise, it is left 
unchanged. <I>name</I> is normally not specified for presence-indicator arguments. 
</DD>
</DL>
<P>
Once the command-line parameters given in <I>argv</I> are matched to the optional 
and mandatory parameters specified in  <I>format,</I> <B>QccParseParameters()</B> uses 
<B><A HREF="sscanf.3.html">sscanf</B>(3)</A>
 in conjunction with the flags above to convert the strings in 
<I>argv</I> to the appropriate types and to store the resulting values in the 
appropriate locations.  
<H3><A NAME="sect7" HREF="#toc7">MULTIPLE PARAMETER </A></H3>
The last mandatory parameter 
may be a multiple parameter. A multiple parameter allows the user to specify 
one or more parameters of the same type at the end of the command line. 
<B>QccParseParameters()</B> will figure out how many parameters are specified; 
the number of parameters, as well as an array of the parameter values, 
is returned to the calling routine via the variable-length argument list. 
For example, a multiple-parameter designation is useful for allowing the 
user to specify a list of files without restricting the number of these 
files. <P>
A multiple parameter is specified by using one of any of the <I>flag</I> 
values above with a `*' immediately after the `%' in the last mandatory parameter. 
 For example, a  <B>%*d</B> indicates that there may be one or more integer parameters 
given at the end of the command line. <P>
For normal optional and mandatory 
parameters, <B>QccParseParameters() </B> expects a pointer to the appropriate 
type and that memory has already been allocated. On the other hand, for 
a multiple parameter, <B>QccParseParameters()</B> expects a pointer to <B>int</B> followed 
by  a pointer to a pointer to the appropriate type. The number of multiple 
parameters found on the command line is stored in the integer; <B>QccParseParameters()</B> 
will automatically allocate an array of the appropriate size consisting 
of the appropriate number of entries of the appropriate type. For example, 
for a  <B>%*d</B> multiple parameter will require a pointer of type <B>(int *)</B> followed 
by a pointer of type <B>(int **)</B> passed to <B>QccParseParameters()</B> in the variable-length 
argument list. <B>QccParseParameters()</B> will store the number of values found 
on the command line in the location pointed to by the first pointer and 
the values themselves in the array pointed to by the second pointer. <P>
As 
described above, strings appearing on the command line are truncated to 
<B>QCCSTRINGLEN</B> characters; consequently, for the  <B>%*s</B> multiple parameter, 
one passes a pointer of type <B>(QccString **)</B> to <B>QccParseParameters()</B>. <P>
See 
the examples below for some ideas as to how to use a multiple parameter. 
 
<H2><A NAME="sect8" HREF="#toc8">RETURN VALUE </A></H2>
For a successful parsing of the command line, <B>QccParseParameters()</B> 
returns a value of 0; all parameter values are returned in the locations 
 indicated by the corresponding pointers. <P>
If an error occurs during parsing, 
 <B>QccParseParameters()</B> prints a usage statement (which is generated from 
the <I>format</I> string passed to <B>QccParseParameters()</B>), in addition to an message 
identifying the QccPack library (as produced by <B><A HREF="QccPrintQccPackVersion.3.html">QccPrintQccPackVersion</B>(3)</A>
) 
and an optional user header (if so set by a call to <B><A HREF="QccSetUserHeader.3.html">QccSetUserHeader</B>(3)</A>
), 
and returns a value of 1.  The following conditions will generate a  parsing 
error: 
<OL>
<LI>A mandatory parameter is specified in <I>format</I> but is not found on 
the command line. </LI><LI>An optional parameter is given on the command line but 
its <I>switch</I> is not found in <I>format</I>. </LI><LI>An optional parameter requires a value 
to follow the <I>switch</I> (such as  <B>%d</B> or <B>%s</B>) but no value is present on the 
command line. </LI>
</OL>
 
<H2><A NAME="sect9" HREF="#toc9">EXAMPLES </A></H2>
Assume that each of the following code segments 
is in the file <B>prog.c</B> which produces executable <B>prog</B>.  
<H3><A NAME="sect10" HREF="#toc10">TYPICAL USE </A></H3>
The typical 
use of <B>QccParseParameters()</B> is illustrated below.  <blockquote><P>
 <P>
 #define USG_STRING 
"[-V %:] [-nl %d:num_levels] [-l %f:lambda] %s:filename" <BR>
 <P>
 int NumLevels 
= 10; <BR>
 QccString Filename; <BR>
 int Verbose = 0; <BR>
 float Lambda = 4.5; <BR>
 <P>
 int 
main(int argc, char *argv[]) <BR>
 { <BR>
   QccInit(&amp;argc, argv); <BR>
 <P>
   if (QccParseParameters(argc, 
argv, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; USG_STRING, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;Verbose, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;NumLevels, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;Lambda, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; Filename)) <BR>
   
  QccErrorExit(); <BR>
 <P>
   printf("Verbose: %d, NumLevels: %d\n", <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp; Verbose, 
NumLevels); <BR>
   printf("Lambda: %f, Filename: %s\n", <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp; Lambda, Filename); 
<BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
Examples of various command lines and the corresponding 
program output are illustrated below. Note that the last two command-line 
examples generate error messages. The first of these error messages occurs 
because the mandatory parameter  (<I>filename</I>)<I></I> is missing. The second error 
message occurs because  <B>-h</B> is not a valid option for the program.  <blockquote><P>
 % prog 
file1.txt <BR>
 Verbose: 0, NumLevels: 10 <BR>
 Lambda: 4.500000, Filename: file1.txt 
<BR>
 <P>
 % prog -V file1.txt <BR>
 Verbose: 1, NumLevels: 10 <BR>
 Lambda: 4.500000, Filename: 
file1.txt <BR>
 <P>
 % prog -nl 123 file1.txt <BR>
 Verbose: 0, NumLevels: 123 <BR>
 Lambda: 
4.500000, Filename: file1.txt <BR>
 <P>
 % prog -l 11.5 -nl 123 file1.txt <BR>
 Verbose: 0, 
NumLevels: 123 <BR>
 Lambda: 11.500000, Filename: file1.txt <BR>
 <P>
 % prog -l 11.5 -nl 
123 -V file1.txt <BR>
 Verbose: 1, NumLevels: 123 <BR>
 Lambda: 11.500000, Filename: 
file1.txt <BR>
 <P>
 % prog  <BR>
 QccPack Version X.X xx-xxx-xxxx, <BR>
 Copyright (C) 1997, 
1998 James E. Fowler, <BR>
 <P>
 *ERROR* Usage: prog [-V ] [-nl num_levels] [-l lambda] 
filename <BR>
 <P>
 % prog -h 45 file1.txt <BR>
 QccPack Version X.X xx-xxx-xxxx, <BR>
 Copyright 
(C) 1997, 1998 James E. Fowler, <BR>
 <P>
 *ERROR* Usage: prog [-V ] [-nl num_levels] 
[-l lambda] filename <BR>
 <P>
  </blockquote>
 
<H3><A NAME="sect11" HREF="#toc11">MULTIPLE-PARAMETER EXAMPLE </A></H3>
The following code shows 
how to use the multiple-parameter capability of <B>QccParseParameters()</B> to 
parse a list of files where the number of files can vary. <B>QccParseParameters()</B> 
automatically handles the allocation of the array of strings of type <B>QccString</B>, 
where each string in the array is allocated to size <B>(QCCSTRINGLEN + 1)</B> 
characters.  <blockquote><P>
 #include "libQccPack.h" <BR>
 <P>
 #define USG_STRING "[-nl %d:num_levels] 
%*s:filenames..." <BR>
 <P>
 int NumLevels = 10; <BR>
 int NumFiles; <BR>
 QccString *Filenames; 
<BR>
 <P>
 int main(int argc, char *argv[]) <BR>
 { <BR>
   int i; <BR>
 <P>
   QccInit(&amp;argc, argv); 
<BR>
 <P>
   if (QccParseParameters(argc, argv, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; USG_STRING, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;NumLevels, <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;NumFiles, 
<BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp; &amp;Filenames)) <BR>
     QccErrorExit(); <BR>
 <P>
   printf("NumLevels: %d, NumFiles: 
%d\nFiles:\n", <BR>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp; NumLevels, NumFiles); <BR>
   for (i = 0; i &lt; NumFiles; i++) 
<BR>
     printf("%s\n", Filenames[i]); <BR>
 <P>
   QccExit; <BR>
 } <BR>
 <P>
  </blockquote>
Example output is 
 <blockquote><P>
 % prog -nl 123 file1.txt file2.txt file3.txt <BR>
 NumLevels: 123, NumFiles: 
3 <BR>
 Files: <BR>
 file1.txt <BR>
 file2.txt <BR>
 file3.txt <BR>
 <P>
  </blockquote>
<P>
  
<H2><A NAME="sect12" HREF="#toc12">NOTES </A></H2>
<P>
Optional parameters 
can appear in any order in the <I>format</I> string; however, all optional parameters 
must appear before the first mandatory parameter. <P>
<B>QccParseParameters()</B> 
does not do any type checking; that is, parameter values given in <I>argv</I> 
are not checked to see if they are "compatible" with the type definitions 
as implied by <I>format</I>. <P>
When using presence indicators (a single  <B>%</B> for <I>flag</I>), 
it is the responsibility of the calling routine to initialize the corresponding 
integer value to 0 before calling <B>QccParseParameters()</B>; that is,  <B>QccParseParameters()</B> 
leaves the integer value unchanged if the optional parameter does not 
appear on the command line. <P>
Any string of non-white-space characters in  
<I>format</I> that is not preceded by a `[' or a `%' is ignored. <P>
<B><A HREF="QccInit.3.html">QccInit</B>(3)</A>
 should 
be called as the first statement in the <B>main()</B> routine in all application 
programs using the QccPack library routines; in particular,  <B><A HREF="QccInit.3.html">QccInit</B>(3)</A>
 
should be called before <B>QccParseParameters()</B>. See <B><A HREF="QccInit.3.html">QccInit</B>(3)</A>
 for more details. 
In addition, if a user header is to be defined in the program, <B><A HREF="QccSetUserHeader.3.html">QccSetUserHeader</B>(3)</A>
 
must be called before <B>QccParseParameters()</B>.  
<H2><A NAME="sect13" HREF="#toc13">SEE ALSO </A></H2>
<B><A HREF="QccConvertToQccString.3.html">QccConvertToQccString</B>(3)</A>
, 
<B><A HREF="QccInit.3.html">QccInit</B>(3)</A>
, <B><A HREF="QccPrintQccPackVersion.3.html">QccPrintQccPackVersion</B>(3)</A>
, <B><A HREF="QccSetUserHeader.3.html">QccSetUserHeader</B>(3)</A>
, <B><A HREF="sscanf.3.html">sscanf</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
  
<H2><A NAME="sect14" HREF="#toc14">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">FORMAT STRING</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">OPTIONAL PARAMETERS</A></LI>
<LI><A NAME="toc5" HREF="#sect5">MANDATORY PARAMETERS</A></LI>
<LI><A NAME="toc6" HREF="#sect6">FLAGS</A></LI>
<LI><A NAME="toc7" HREF="#sect7">MULTIPLE PARAMETER</A></LI>
</UL>
<LI><A NAME="toc8" HREF="#sect8">RETURN VALUE</A></LI>
<LI><A NAME="toc9" HREF="#sect9">EXAMPLES</A></LI>
<UL>
<LI><A NAME="toc10" HREF="#sect10">TYPICAL USE</A></LI>
<LI><A NAME="toc11" HREF="#sect11">MULTIPLE-PARAMETER EXAMPLE</A></LI>
</UL>
<LI><A NAME="toc12" HREF="#sect12">NOTES</A></LI>
<LI><A NAME="toc13" HREF="#sect13">SEE ALSO</A></LI>
<LI><A NAME="toc14" HREF="#sect14">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
