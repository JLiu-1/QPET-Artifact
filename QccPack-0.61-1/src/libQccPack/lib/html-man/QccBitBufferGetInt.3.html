<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccBitBufferGetInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccBitBuffer - generic data structure for bitstream packing  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS 
</A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccBitBufferInitialize(QccBitBuffer *</B><I>bit_buffer</I><B>);</B> 
 <BR>
<B>int QccBitBufferStart(QccBitBuffer *</B><I>bit_buffer</I><B>);</B>  <BR>
<B>int QccBitBufferEnd(QccBitBuffer 
*</B><I>bit_buffer</I><B>);</B>  <BR>
<B>int QccBitBufferFlush(QccBitBuffer *</B><I>bit_buffer</I><B>);</B>  <BR>
<B>int QccBitBufferCopy(QccBitBuffer 
*</B><I>output_buffer</I><B>, QccBitBuffer *</B><I>input_buffer</I><B>, int </B><I>num_bits</I><B>);</B>  <BR>
<B>int QccBitBufferPutBit(QccBitBuffer 
*</B><I>bit_buffer</I><B>, int </B><I>bit_value</I><B>);</B>  <BR>
<B>int QccBitBufferGetBit(QccBitBuffer *</B><I>bit_buffer</I><B>, 
int *</B><I>bit_value</I><B>);</B>  <BR>
<B>int QccBitBufferPutBits(QccBitBuffer *</B><I>bit_buffer</I><B>, int 
</B><I>val</I><B>, int </B><I>num_bits</I><B>);</B>  <BR>
<B>int QccBitBufferGetBits(QccBitBuffer *</B><I>bit_buffer</I><B>, 
int *</B><I>val</I><B>, int </B><I>num_bits</I><B>);</B>  <BR>
<B>int QccBitBufferPutChar(QccBitBuffer *</B><I>bit_buffer</I><B>, 
unsigned char </B><I>val</I><B>);</B>  <BR>
<B>int QccBitBufferGetChar(QccBitBuffer *</B><I>bit_buffer</I><B>, 
unsigned char *</B><I>val</I><B>);</B>  <BR>
<B>int QccBitBufferPutInt(QccBitBuffer *</B><I>bit_buffer</I><B>, 
int </B><I>val</I><B>);</B>  <BR>
<B>int QccBitBufferGetInt(QccBitBuffer *</B><I>bit_buffer</I><B>, int *</B><I>val</I><B>);</B> 
 <BR>
<B>int QccBitBufferPutDouble(QccBitBuffer *</B><I>bit_buffer</I><B>, double </B><I>val</I><B>);</B>  <BR>
<B>int 
QccBitBufferGetDouble(QccBitBuffer *</B><I>bit_buffer</I><B>, double *</B><I>val</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
When one writes a stream of bits to a file, it is necessary for the bits 
to be "packed" into byte-sized characters, as the byte is the smallest 
input/output unit supported by the operating system. Likewise, bit "unpacking" 
from byte-sized characters is necessary to read a bitstream from a file. 
QccPack provides the <B>QccBitBuffer</B> data structure to facilitate reading 
and writing bitstreams. For writing,  the <B>QccBitBuffer</B> structure and related 
routines automatically handle the packing of consecutive bits into a character 
and the writing of the resulting character, when full, to the file. For 
reading, bits are unpacked from the current character; when no more bits 
remain to be read from the character, the next character from the file 
is read automatically. Consequently, from the user's point of view, the 
<B>QccBitBuffer</B> structure and related routines provided bit-level access to 
files. Additional routines allow  <B>int</B> and <B>double</B> types to be read/written 
from/to the bitstream without regard to the byte alignment usually required 
by the operating system.  
<H2><A NAME="sect3" HREF="#toc3">DATA STRUCTURE </A></H2>
The <B>QccBitBuffer</B> data structure 
is defined as:  <blockquote><P>
 typedef unsigned char QccBitBufferChar; <BR>
 typedef struct 
<BR>
 { <BR>
   QccString          filename; <BR>
   FILE               *fileptr; <BR>
   
int                type; <BR>
   int                bit_cnt; <BR>
   int        
        byte_cnt; <BR>
   int                bits_to_go; <BR>
   QccBitBufferChar 
  buffer; <BR>
 } QccBitBuffer; <BR>
  </blockquote>
<P>
The fields of <B>QccBitBuffer</B> are as follows: 

<DL>

<DT><I>filename</I>  </DT>
<DD>The name of the file to which the bitstream is to be read/written. 
</DD>

<DT><I>fileptr</I>  </DT>
<DD>The <B>FILE</B> pointer to the file. </DD>

<DT><I>type</I>  </DT>
<DD>Indicates whether the buffer 
is output (bitstream is written to file) or input (bitstream is read from 
file).  Takes values <B>QCCBITBUFFER_OUTPUT</B> or <B>QCCBITBUFFER_INPUT</B>, respectively. 
</DD>

<DT><I>bit_cnt</I>  </DT>
<DD>Number of bits read from or written to buffer so far. </DD>

<DT><I>byte_cnt</I> 
 </DT>
<DD>Number of bytes read from or written to the file associated to the buffer. 
</DD>

<DT><I>bits_to_go</I>  </DT>
<DD>Number of bits remaining to pack/unpack into/from current 
character. For internal use in QccPack routines only. </DD>

<DT><I>buffer</I>  </DT>
<DD>The current 
character being packed/unpacked. </DD>
</DL>
 
<H2><A NAME="sect4" HREF="#toc4">FILE FORMAT </A></H2>
The file written or read 
by <B>QccBitBuffer</B> routines is merely a sequence of the packed characters 
representing the bitstream. The order that the bits of the bitstream are 
packed into the characters is least-significant bit (LSB) to most-significant 
bit (MSB). There is no header information stored in the file.  
<H2><A NAME="sect5" HREF="#toc5">ROUTINES 
</A></H2>
<B>QccBitBufferInitialize()</B> should be called before any use of a <B>QccBitBuffer</B> 
structure. <B>QccBitBufferInitialize()</B> initializes the fields of <I>bit_buffer</I> 
to the following values:  <blockquote><P>
 <I>filename</I>: <B>NULL</B> string  <BR>
<I>fileptr</I>: <B>NULL</B>  <BR>
<I>type</I>: 
<B>QCCBITBUFFER_OUTPUT</B>  <BR>
<I>bit_cnt</I>: 0  <BR>
<I>bits_to_go</I>: 8  <BR>
<I>buffer</I>: 0  </blockquote>
<P>
<B>QccBitBufferStart()</B> 
starts a read or write on <I>bit_buffer</I>. <I>bit_buffer</I>-&gt;<I>type</I> must be set to indicate 
whether  <I>bit_buffer</I> will read a file (<B>QCCBITBUFFER_INPUT</B>) or write a file 
(<B>QCCBITBUFFER_OUTPUT</B>). If  <I>bit_buffer</I>-&gt;<I>fileptr</I> is <B>NULL</B>, the file indicated 
by <I>bit_buffer</I>-&gt;<I>filename</I> is opened and the resulting <B>FILE</B> pointer is returned 
in <I>bit_buffer</I>-&gt;<I>fileptr</I>. Otherwise, it is assumed that the file is already 
opened properly for reading or writing as appropriate, and is properly 
positioned to the start of binary data in the file (thus, <B>QccBitBufferStart()</B> 
permits the reading of, say, an ASCII header by some external procedure 
before the reading of binary data commences). In either case, if <I>bit_buffer</I> 
is being started for reading,  <I>bit_buffer</I>-&gt;<I>buffer</I> is primed by reading the 
first character of the file. <P>
<B>QccBitBufferEnd()</B> should be called after all 
accesses (read or write) to <I>bit_buffer</I> are complete. <B>QccBitBufferEnd()</B> 
closes  <I>bit_buffer</I>-&gt;<I>fileptr</I>. <P>
<B>QccBitBufferFlush()</B> should be called at the 
end of writing a bitstream after all bits have been written but before 
 <B>QccBitBufferEnd()</B> is called. <B>QccBitBufferFlush()</B> ensures that the last 
byte being packed with bits, which may not be full, is output to the file. 
If any bits are output after a call to <B>QccBitBufferFlush()</B>, they will 
be written to the next byte of the file; i.e., <B>QccBitBufferFlush()</B> can be 
used to align output to byte boundaries in the file. <B>QccBitBufferFlush()</B> 
is usually called only for buffers opened for output. In the case of an 
input buffer, <B>QccBitBufferFlush()</B> will cause the next bit read to come 
from the next byte of the file; i.e., on input, <B>QccBitBufferFlush()</B> can 
be used to enforce alignment to byte boundaries during reading the file. 
On output, <B>QccBitBufferFlush()</B> calls <B><A HREF="QccFileFlush.3.html">QccFileFlush</B>(3)</A>
 to ensure that all 
stream buffers are flushed. <P>
<B>QccBitBufferCopy()</B> copies <I>num_bits</I> from <I>input_buffer</I> 
to <I>output_buffer</I> by calling <B>QccBitBufferGetBit()</B> on <I>input_buffer</I> and <B>QccBitBufferPutBit()</B> 
on <I>output_buffer</I> <I>num_bits</I> times. <P>
<B>QccBitBufferPutBit()</B> outputs a bit, <I>bit_value</I>, 
to output buffer <I>bit_buffer</I>. The bit is packed into the current byte, and, 
if this byte is full, it is written to the file. <I>bit_value</I> gives the value 
of the bit; <I>bit_value</I>  should be zero to denote a 0 bit and nonzero to 
denote a 1 bit. <P>
<B>QccBitBufferGetBit()</B> inputs a bit, <I>bit_value</I>, from an input 
buffer <I>bit_buffer</I>. If the current byte is empty, the next byte is read 
from the file. Then, a bit is unpacked from the byte. The bit is returned 
in <I>bit_value</I>; a 0 is returned for a 0 bit, a 1 is returned for a 1 bit. 
If the <I>bit_value</I> pointer is <B>NULL</B>, then the bit is read from <I>input_buffer</I> 
but not returned. <P>
<B>QccBitBufferPutBits()</B> outputs the least-significant <I>num_bits</I> 
bits of <I>val</I> to <I>bit_buffer</I> via <I>num_bits</I> consecutive calls to <B>QccBitBufferPutBit()</B>. 
The bits are output starting with the least-significant bit of <I>val</I>. <P>
<B>QccBitBufferGetBits()</B> 
inputs <I>num_bits</I> bits from <I>bit_buffer</I> to the least-significant bits of <I>val</I> 
via <I>num_bits</I> consecutive calls to <B>QccBitBufferGetBit()</B>. The bits are placed 
into <I>val</I> starting with the least-significant bit first. If the <I>val</I> pointer 
is <B>NULL</B>, then the bits are read from <I>input_buffer</I> but not returned. <P>
<B>QccBitBufferPutChar()</B> 
and <B>QccBitBufferGetChar()</B> write or read, respectively, an <B>unsigned char</B> 
to or from the file.  That is, these two routines effectuate 8 consecutive 
bit writes or reads via <B>QccBitBufferPutBit()</B> or <B>QccBitBufferGetBit()</B>. If 
the <I>val</I> pointer is <B>NULL</B>, then <B>QccBitBufferGetBit()</B> reads the character 
from <I>input_buffer</I>, but it is not returned. <P>
<B>QccBitBufferPutInt()</B> and <B>QccBitBufferGetInt()</B> 
use <B><A HREF="QccBinaryIntToChar.3.html">QccBinaryIntToChar</B>(3)</A>
 and <B><A HREF="QccBinaryChartoInt.3.html">QccBinaryChartoInt</B>(3)</A>
 to convert between 
an <B>int</B> and four characters.  These four characters are read from or written 
to the file via four calls to <B>QccBitBufferPutChar()</B> or <B>QccBitBufferGetChar()</B>. 
If the <I>val</I> pointer is <B>NULL</B>, then <B>QccBitBufferGetInt()</B> reads the integer 
from <I>input_buffer</I>, but it is not returned. <P>
<B>QccBitBufferPutDouble()</B> and 
<B>QccBitBufferGetDouble()</B> use <B><A HREF="QccBinaryFloatToChar.3.html">QccBinaryFloatToChar</B>(3)</A>
 and <B><A HREF="QccBinaryChartoFloat.3.html">QccBinaryChartoFloat</B>(3)</A>
 
to convert between a <B>double</B> and four characters.  These four characters 
are read from or written to the file via four calls to <B>QccBitBufferPutChar()</B> 
or <B>QccBitBufferGetChar()</B>. <B>QccBitBufferPutDouble()</B> and <B>QccBitBufferGetDouble()</B> 
actually read and write  <B>double</B> as <B>float</B>; consequently, these routines 
may incur a loss of precision. If the <I>val</I> pointer is <B>NULL</B>, then <B>QccBitBufferGetDouble()</B> 
reads the value from <I>input_buffer</I>, but it is not returned.  
<H2><A NAME="sect6" HREF="#toc6">RETURN VALUE 
</A></H2>
Each of these routines return 0 upon successful completion, 1 on error. 
 
<H2><A NAME="sect7" HREF="#toc7">SEE ALSO </A></H2>
<B><A HREF="QccBinaryIntToChar.3.html">QccBinaryIntToChar</B>(3)</A>
, <B><A HREF="QccBinaryChartoInt.3.html">QccBinaryChartoInt</B>(3)</A>
, <B><A HREF="QccBinaryFloatToChar.3.html">QccBinaryFloatToChar</B>(3)</A>
, 
<B><A HREF="QccBinaryChartoFloat.3.html">QccBinaryChartoFloat</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
  
<H2><A NAME="sect8" HREF="#toc8">NOTES </A></H2>
Because bitstreams are stored 
in raw format files with no headers, the routines that read these files 
(e.g., <B>QccBitBufferGetBit()</B>) do not know a priori how long the bitstream 
is. Since a bitstream may end in the middle of a byte, the end of the file 
may not correspond to the end of the bitstream. It is the user's responsibility 
to ensure that data is not read from beyond the end of the bitstream. <P>
On 
a related note, <I>bit_buffer</I>-&gt;<I>bit_cnt</I> stores the number of bits actually put 
into or got out of the buffer. On the other hand, <I>bit_buffer</I>-&gt;<I>byte_cnt</I> stores 
the number of bytes that have been read from or written to the file associated 
to the buffer. Calls to <B>QccBitBufferFlush()</B> may cause these two to appear 
to be "out of sync." For example, when the last byte of a file is written, 
if this last byte is not completely full, <I>bit_buffer</I>-&gt;<I>bit_cnt</I> is incremented 
by only the number of bits actually put into the buffer (something less 
than 8), while <I>bit_buffer</I>-&gt;<I>byte_cnt</I> is incremented once indicating that 
a byte (8 bits) was written to the file.  In this case, <I>bit_buffer</I>-&gt;<I>bit_cnt</I> 
will not be equal to 8 times <I>bit_buffer</I>-&gt;<I>byte_cnt</I> as might have been expected. 
This issue is important to keep in mind should <B>QccBitBufferFlush()</B> be 
called multiple times during reading or writing in order to align to byte 
boundaries; in this case, the bits in the file that are "skipped" to get 
to the start of the next byte are not included in the <I>bit_buffer</I>-&gt;<I>bit_cnt</I> 
count.  
<H2><A NAME="sect9" HREF="#toc9">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">DATA STRUCTURE</A></LI>
<LI><A NAME="toc4" HREF="#sect4">FILE FORMAT</A></LI>
<LI><A NAME="toc5" HREF="#sect5">ROUTINES</A></LI>
<LI><A NAME="toc6" HREF="#sect6">RETURN VALUE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">SEE ALSO</A></LI>
<LI><A NAME="toc8" HREF="#sect8">NOTES</A></LI>
<LI><A NAME="toc9" HREF="#sect9">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
