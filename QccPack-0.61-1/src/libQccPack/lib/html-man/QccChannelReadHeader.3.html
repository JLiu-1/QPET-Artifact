<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccChannelReadHeader.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccChannelReadWholefile, QccChannelReadHeader, QccChannelStartRead, 
QccChannelEndRead, QccChannelReadBlock - reading of QccChannel structures 
from CHN-format files  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccChannelReadWholefile(QccChannel 
*</B><I>channel</I><B>);</B>  <BR>
<B>int QccChannelReadHeader(QccChannel *</B><I>channel</I><B>);</B>  <BR>
<B>int QccChannelStartRead(QccChannel 
*</B><I>channel</I><B>);</B>  <BR>
<B>int QccChannelEndRead(QccChannel *</B><I>channel</I><B>);</B>  <BR>
<B>int QccChannelReadBlock(QccChannel 
*</B><I>channel</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
These routines implement the reading of <B>QccChannel</B> 
channels from <B>CHN</B>-format files. There are two distinct modes in which the 
channel-symbol data in channels may be read: the whole file may be read 
at once, or the file may be read in non-overlapping blocks. <P>
<B>QccChannelReadWholefile()</B> 
reads the <B>CHN</B>-format file whose filename is given by <I>channel</I>-&gt;<I>filename</I>. The 
entire file is read, including the header, and the symbols are returned 
in the  <I>channel</I>-&gt;<I>channel_symbols</I>. If  <I>channel</I>-&gt;<I>channel_symbols</I> is <B>NULL</B>, <I>channel</I>-&gt;<I>channel_symbols</I> 
is allocated via a call to <B>QccChannelAlloc() </B> prior to reading; otherwise, 
it is assumed that sufficient space has already been allocated. <P>
<B>QccChannelReadHeader()</B> 
reads the header information of the <B>CHN</B>-format file pointed to by <I>channel</I>-&gt;<I>fileptr</I>, 
which must be already open and positioned at the start of the file. Information 
read from the header is returned in the fields of <I>channel</I>. <P>
<B>QccChannelStartRead()</B> 
must be called before any block-based read of <I>channel</I>. <B>QccChannelStartRead()</B> 
opens the file with  <B><A HREF="QccFileOpen.3.html">QccFileOpen</B>(3)</A>
, reads the file's header with <B><A HREF="QccChannelReadHeader.3.html">QccChannelReadHeader</B>(3)</A>
, 
and allocates storage space, if needed, for the channel symbols by calling 
<B><A HREF="QccChannelAlloc.3.html">QccChannelAlloc</B>(3)</A>
 (note that allocation is performed only if  <I>channel</I>-&gt;<I>channel_symbols</I> 
is  <B>NULL).</B> Prior to calling <B>QccChannelStartRead()</B>, <I>channel</I>-&gt;<I>filename</I> must 
contain the name of the file and <I>channel</I>-&gt;<I>access_block_size</I> must give the 
block size desired for subsequent block-based reads. The remaining fields 
of <I>channel</I> are filled in from the file's header. After <B>QccChannelStartRead()</B> 
returns, <I>channel</I>-&gt;<I>fileptr</I> contains the <B>FILE</B> pointer to the open file, and 
the file is positioned at the start of the channel-symbol data, ready for 
reading the first block of symbols. <P>
<B>QccChannelEndRead()</B> closes a channel 
file opened by a previous call to <B>QccChannelStartRead()</B>; additionally, 
the symbol array, <I>channel</I>-&gt;<I>channel_symbols</I>, is freed with a call to  <B><A HREF="QccChannelFree.3.html">QccChannelFree</B>(3)</A>
. 
<P>
<B>QccChannelReadBlock()</B> reads the next block of symbols in the channel. <I>channel</I> 
must be prepared by a prior call to <B>QccChannelStartRead()</B>; that is,  <I>channel</I>-&gt;<I>fileptr</I> 
must point to an open file, <I>channel</I>-&gt;<I>access_block_size</I> must contain the 
size of the block of symbols to read, and <I>channel</I>-&gt;<I>channel_symbols</I> must 
be allocated with space sufficient for storing the block of symbols. <B>QccChannelReadBlock()</B> 
reads non-overlapping blocks of data from the file; after <B>QccChannelReadBlock()</B> 
returns, the file is positioned at the start of the subsequent block.  

<H2><A NAME="sect3" HREF="#toc3">RETURN VALUE </A></H2>
These routines return 0 on successful completion, 1 if an 
error occurs while reading the file.  
<H2><A NAME="sect4" HREF="#toc4">SEE ALSO </A></H2>
<B><A HREF="QccChannelWrite.3.html">QccChannelWrite</B>(3)</A>
, <B><A HREF="QccChannel.3.html">QccChannel</B>(3)</A>
, 
<B><A HREF="QccFileOpen.3.html">QccFileOpen</B>(3)</A>
, <B><A HREF="QccChannel.3.html">QccChannel</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
  
<H2><A NAME="sect5" HREF="#toc5">AUTHOR </A></H2>
Copyright (C) 1997-2016 
 James E. Fowler <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">RETURN VALUE</A></LI>
<LI><A NAME="toc4" HREF="#sect4">SEE ALSO</A></LI>
<LI><A NAME="toc5" HREF="#sect5">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
