.TH QCCVOLUME 3 "QCCPACK" ""
.SH NAME
QccVolumeAlloc,
QccVolumeFree,
QccVolumeZero,
QccVolumeResize,
QccVolumeCopy,
QccVolumeMaxValue,
QccVolumeMinValue,
QccVolumePrint,
QccVolumeAdd,
QccVolumeSubtract,
QccVolumeMean
QccVolumeVariance
\- miscellaneous volume routines
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "QccVolume QccVolumeAlloc(int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "void QccVolumeFree(QccVolume " volume ", int " num_frames ", int " num_rows );
.br
.sp
.BI "int QccVolumeZero(QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "QccVolume QccVolumeResize(QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols ", int " new_num_frames ", int " new_num_rows ", int " new_num_cols );
.br
.sp
.BI "int QccVolumeCopy(QccVolume " volume1 ", const QccVolume " volume2 ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "double QccVolumeMaxValue(const QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "double QccVolumeMinValue(const QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "int QccVolumePrint(const QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "int QccVolumeAdd(QccVolume " volume1 ", const QccVolume " volume2 ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "int QccVolumeSubtract(QccVolume " volume1 ", const QccVolume " volume2 ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "double QccVolumeMean(const QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.br
.sp
.BI "double QccVolumeVariance(const QccVolume " volume ", int " num_frames ", int " num_rows ", int " num_cols );
.SH DESCRIPTION
QccPack library routines use three-dimensional arrays of type 
.B QccVolume
which is defined as
.RS
.nf
typedef QccMatrix *QccVolume;
.fi
.RE
.LP
Although volumes can represent data from various applications, throughout
QccPack, the following terminology, which arises in the video-coding
application, is adopted. Volumes are described as consisting of a collection
of 2D "frames" distributed in the temporal direction. Each frame describes
a 2D spatial region, and is indexed by row and column in the two spatial
directions.
.LP
.B QccVolumeAlloc()
allocates a
.B QccVolume
consisting of 
.I num_frames
matrices; each matrix is a two-dimensional array of type
.B QccMatrix
and has dimensions
.IR num_rows
by
.IR num_cols .
.B QccVolumeAlloc()
returns a
.B NULL
pointer if the allocation fails.
.LP
.B QccVolumeFree()
frees a
.B QccVolume
previously allocated by
.BR QccVolumeAlloc() .
.LP
.B QccVolumeZero()
makes each element of 
.I volume
zero.
.LP
.B QccVolumeResize()
changes the size of
.I volume
from
.IR num_frames " x " num_rows " x " num_cols 
to
.IR new_num_frames " x " new_num_rows " x " new_num_cols 
by calling
.BR realloc (3)
and
.BR QccMatrixResize (3).
Upon success, the new volume is returned; a
.B NULL
pointer is returned if 
.BR realloc (3)
or
.BR QccMatrixResize (3)
fails. If
.I volume
is
.BR NULL ,
.BR QccVolumeAlloc()
is called. In any case, all elements added to
.I volume
are zero.
.LP
.BR QccVolumeCopy()
copies
.I volume2
to
.IR volume1 .
.LP
.B QccVolumeMaxValue()
returns the largest element in
.IR volume .
.LP
.B QccVolumeMinValue()
returns the smallest element in
.IR volume .
.LP
.B QccVolumePrint()
prints the elements of
.I volume
to stdout.
.LP
.B QccVolumeAdd()
adds each component of
.I volume1 
to the corresponding component of
.IR volume2 ,
returning the resulting volume in
.IR volume1 .
.I volume1
and
.I volume2
must be the same size.
.LP
.B QccVolumeSubtract()
subtracts each component of
.I volume2
from the corresponding component of
.IR volume1 ,
returning the resulting volume in
.IR volume1 .
.I volume1
and
.I volume2
must be the same size.
.LP
.B QccVolumeMean()
calculates the mean of the elements in
.LP
.B QccVolumeVariance()
calculates the variance of the elements in
.IR volume .
.SH "SEE ALSO"
.BR QccVector (3),
.BR QccMatrix (3),
.BR QccPack (3)
.SH AUTHOR
Written by Justin T. Rucker <jtr9@msstate.edu>

Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
