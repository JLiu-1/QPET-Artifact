.TH QCCVECTOR 3 "QCCPACK" ""
.SH NAME
QccVectorAlloc,
QccVectorFree,
QccVectorZero,
QccVectorResize,
QccVectorMean,
QccVectorVariance,
QccVectorAdd,
QccVectorSubtract,
QccVectorScalarMult,
QccVectorCopy,
QccVectorNorm,
QccVectorNormalize,
QccVectorDotProduct,
QccVectorAngle,
QccVectorSquareDistance,
QccVectorSumComponents,
QccVectorMaxValue,
QccVectorMinValue,
QccVectorPrint
\- miscellaneous vector routines
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "QccVector QccVectorAlloc(int " vector_dimension );
.br
.sp
.BI "void QccVectorFree(QccVector " vector );
.br
.sp
.BI "int QccVectorZero(QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "QccVector QccVectorResize(QccVector " vector ", int " vector_dimension ", int " new_vector_dimension );
.br
.sp
.BI "double QccVectorMean(const QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "double QccVectorVariance(const QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "int QccVectorAdd(QccVector " vector1 ", const QccVector " vector2 ", int " vector_dimension );
.br
.sp
.BI "int QccVectorSubtract(QccVector " vector1 ", const QccVector " vector2 ", int " vector_dimension );
.br
.sp
.BI "int QccVectorScalarMult(QccVector " vector ", double " s ", int " vector_dimension );
.br
.sp
.BI "int QccVectorCopy(QccVector " vector1 ", const QccVector " vector2 ", int " vector_dimension );
.br
.sp
.BI "double QccVectorNorm(const QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "double QccVectorNormalize(QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "double QccVectorDotProduct(const QccVector " vector1 ", const QccVector " vector2 ", int "vector_dimension );
.br
.sp
.BI "double QccVectorAngle(const QccVector " vector1 ", const QccVector " vector2 ", int " vector_dimension ", int " degrees );
.br
.sp
.BI "double QccVectorSquareDistance(const QccVector " vector1 ", const QccVector " vector2 ", int " vector_dimension );
.br
.sp
.BI "double QccVectorSumComponents(const QccVector " vector ", int " vector_dimension );
.br
.sp
.BI "double QccVectorMaxValue(const QccVector " vector ", int " vector_dimension ", int *" winner );
.br
.sp
.BI "double QccVectorMinValue(const QccVector " vector ", int " vector_dimension ", int *" winner );
.br
.sp
.BI "int QccVectorPrint(const QccVector " vector ", int " vector_dimension );
.SH DESCRIPTION
The QccPack library routines use a one-dimensional
vector type defined as follows:
.RS
.nf

typedef double *QccVector;
.fi
.RE
.LP
.B QccVectorAlloc()
allocates space for a 
.B QccVector
of dimension
.IR vector_dimension .
.B QccVectorAlloc()
returns a
.B NULL
pointer if the allocation fails.
.LP
.B QccVectorFree()
frees the space previously allocated via
.B QccVectorAlloc()
.LP
.B QccVectorZero()
makes each component of
.IR vector
zero.
.B QccVectorZero()
returns 0 on success, 1 on failure.
.LP
.B QccVectorResize()
changes the dimension of
.I vector
from
.I vector_dimension 
to
.I new_vector_dimension 
by calling
.BR realloc (3).
Upon success, the new vector is returned; a
.B NULL
pointer is returned if 
.BR realloc (3)
fails. If
.I vector
is
.BR NULL ,
.BR QccVectorAlloc()
is called. In any case, all elements added to
.I vector
are zero.
.LP
.B QccVectorMean()
returns the mean value of all the components
of
.IR vector .
In the case that
.I vector
is
.BR NULL ,
.B QccVectorMean()
returns 0.0.
.LP
.B QccVectorVariance()
returns the variance of the components
of
.IR vector .
In the case that
.I vector
is
.BR NULL ,
.B QccVectorVariance()
returns 0.0.
.LP
.B QccVectorSum()
returns the sum of all the components of
.IR vector .
In the case that
.I vector
is
.BR NULL ,
.B QccVectorSum()
returns 0.0.
.LP
.B QccVectorAdd()
adds each component of
.I vector1
to the corresponding component of
.I vector2
(vector addition).
The resulting vector is returned in
.IR vector1 .
Both
.I vector1
and
.I vector2
must have the same vector dimension,
.IR vector_dimension .
.B QccVectorAdd()
returns 0 on success, 1 on failure.
.LP
.B QccVectorSubtract()
subtracts each component of 
.I vector2
from the corresponding component of
.IR vector1 .
The resulting vector is returned in
.IR vector1 .
Both
.I vector1
and
.I vector2
must have the same vector dimension,
.IR vector_dimension .
.B QccVectorSubtract()
returns 0 on success, 1 on failure.
.LP
.B QccVectorScalarMult()
multiplies vector
.I vector
by the scalar
.IR s ;
that is, each component of
.I vector 
is multiplied by the
.B double
.IR s ,
and the resulting vector is returned in
.IR vector .
.B QccVectorScalarMult()
returns 0 on success,
1 on failure.
.LP
.B QccVectorCopy()
copies
.I vector2
to
.IR vector1 .
.B QccVectorCopy()
returns 0 on success,
1 on failure.
.LP
.B QccVectorNorm()
calculates the norm (square root of dot product) of
.IR vector .
If 
.I vector
is
.BR NULL ,
0.0 is returned.
.LP
.B QccVectorNormalize()
divides 
.I vector
by its nonzero norm as calculated by
.BR QccVectorNorm() .
The resulting vector, which has unit length, is returned in
.IR vector .
If, on the other hand, the vector norm is originally zero, 
.I vector
is not changed.
.LP
.B QccVectorDotProduct()
calculates and returns the dot product of vectors
.I vector1
and
.IR vector2 .
Both
.I vector1
and
.I vector2
must have the same vector dimension,
.IR vector_dimension .
If either
.I vector1
or
.I vector2
is
.BR NULL ,
0.0 is returned.
.LP
.B QccVectorAngle()
calculates and returns the angle between vectors
.I vector1
and
.IR vector2 .
Both
.I vector1
and
.I vector2
must have the same vector dimension,
.IR vector_dimension .
If either
.I vector1
or
.I vector2
is
.BR NULL ,
0.0 is returned.
If
.IR degrees
is nonzero, the angle is return is degrees; otherwise, it is
returned in radians.
.B QccVectorAngle()
calls
.BR QccVectorDotProduct() and
.BR QccVectorNorm() ;
the angle is the
.BR acos (3)
of the dot product divided by the two vector norms.
If either vector has zero norm, 0.0 is returned.
.LP
.B QccVectorSquareDistance()
calculates the squared Euclidean distance between vectors
.I vector1
and
.IR vector2 .
That is, 
.I vector2
is subtracted from
.I vector1
and the dot product of the difference vector is returned.
Both
.I vector1
and
.I vector2
must have the same vector dimension,
.IR vector_dimension .
If either
.I vector1
or
.I vector2
is
.BR NULL ,
0.0 is returned.
.LP
.B QccVectorSumComponents()
adds all the components of 
.I vector
together and returns the sum.
.LP
.B QccVectorMaxValue()
returns the value of the largest component of
.IR vector .
If
.I winner
is not a 
.B NULL
pointer, the index (0 through
.I vector_dimension
- 1) of the maximum component is returned in the
.B int
pointed to by 
.IR winner .
.LP
.B QccVectorMinValue()
returns the value of the smallest component of
.IR vector .
If
.I winner
is not a 
.B NULL
pointer, the index (0 through
.I vector_dimension
- 1) of the minimum component is returned in the
.B int
pointed to by 
.IR winner .
.LP
.B QccVectorPrint()
prints the components of
.I vector
to stdout.
.SH "SEE ALSO"
.BR QccPack (3)
.SH NOTES
Except as noted above,
these vector routines accept 
.B NULL
vector pointers,
in which case
these routines return immediately without generating an error or performing
any operations.
.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
