.TH QCCVIDRDWTBLOCKENCODE 1 "QCCPACK" ""
.SH NAME
QccVIDRDWTBlockEncode, QccVIDRDWTBlockDecode \-
encode/decode an image sequence using the RDWT-block algorithm
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccVIDRDWTBlockEncode(QccIMGImageSequence *" image_sequence ", const QccFilter *" filter1 ", const QccFilter *" filter2 ", const QccFilter *" filter3 ", int " subpixel_accuracy ", QccBitBuffer *" output_buffer ", int " blocksize ", int " num_levels ", int " target_bit_cnt ", const QccWAVWavelet *" wavelet ", const QccString " mv_filename ", int " read_motion_vectors ", int " quiet );
.sp
.BI "int QccVIDRDWTBlockDecodeHeader(QccBitBuffer *" input_buffer ", int *" num_rows ", int *" num_cols ", int *" start_frame_num ", int *" end_frame_num ", int *" blocksize ", int *" num_levels ", int *" target_bit_cnt );
.sp
.BI "int QccVIDRDWTBlockDecode(QccIMGImageSequence *" image_sequence ", const QccFilter *" filter1 ", const QccFilter *" filter2 ", const QccFilter *" filter3 ", int " subpixel_accuracy ", QccBitBuffer *" input_buffer ", int " target_bit_cnt ", int " blocksize ", int " num_levels ", const QccWAVWavelet *" wavelet ", const QccString " mv_filename ", int " quiet );
.SH DESCRIPTION
.SS Encoding
.LP
.B QccVIDRDWTBlockEncode()
encodes an
.I image_sequence
using the RDWT-block video-coding algorithm by Park and Kim.
Essentially, the RDWT-block algorithm involves traditional
block-based motion estimation and motion compensation wherein
the redundant phases of the RDWT of the reference frame are used
to circumvent the shift variance of the wavelet transform; see "ALGORITHM"
below for greater detail.
.LP
.I image_sequence
is the image sequence to be coded and
should indicate a collection of grayscale images of the same size stored
as separate, numbered files; the
filename indicated by
.I image_sequence
must contain one 
.BR printf (3)-style
numerical descriptor which will then be filled in the current
frame number (e.g., football.%03d.pgm will become
football.000.pgm, football.001.pgm, etc.; see
.BR QccPackIMG (3)).
Each frame of
.I image_sequence
must have a size which is an integer multiple of
.I blocksize
both horizontally and vertically.
Both the
.I start_frame_num
and
.I end_frame_num
fields of
.I image_sequence
should indicate the desired starting and stopping frames, respectively,
for the encoding;
these should either be set manually or via a call to
.BR QccIMGImageSequenceFindFrameNums (3)
prior to calling
.BR QccVIDRDWTBlockEncode() .
.LP
.IR filter1 ,
.IR filter2 ,
and
.IR filter3 
are interpolation filters for supporting the subpixel accuracy specified by
.IR subpixel_accuracy
which can be one of
.BR QCCVID_ME_FULLPIXEL ,
.BR QCCVID_ME_HALFPIXEL ,
.BR QCCVID_ME_QUARTERPIXEL ,
or 
.BR QCCVID_ME_EIGHTHPIXEL ,
indicating full-, half-, quarter-, or eighth-pixel accuracy, respectively.
See "SUBPIXEL ACCURACY" below.
.LP
.I output_buffer
is the output bitstream
which must be of
.B QCCBITBUFFER_OUTPUT
type and opened via a prior call to
.BR QccBitBufferStart (3).
.LP
.I num_levels
gives the number of levels of dyadic wavelet decomposition to perform,
and
.I wavelet
is the wavelet to use for decomposition.
.LP
When encoding the current frame,
.BR QccVIDRDWTBlockEncode()
will first output to
.IR output_buffer
all the motion vectors for the frame, and then
an embedded intraframe encoding of the motion-compensated residual.
.I target_bit_cnt
is the desired number of bits to output for each frame,
including motion vectors and motion-compensated residual.
After
.I target_num_bits
have been produced for the current frame,
.BR QccVIDRDWTBlockEncode()
will call
.BR QccBitBufferFlush (3)
to flush the bit-buffer contents to the output bitstream.
Encoding of the next frame starts on the next byte boundary
of the output bitstream.
.LP
.I mv_filename
gives the filename for files of motion vectors.
If
.I read_motion_vectors
is
.BR FALSE ,
then the motion-vectors are written to
.I mv_filename
via
.BR QccVIDMotionVectorsWriteFile (3).
.I mv_filename
should have a
.BR printf (3)-style
numerical descriptor which will then be filled in with
the current frame number before writing, so that motion vectors
are separated into multiple files, one file per frame.
On the other hand, if
.I read_motion_vectors
is
.BR TRUE ,
then motion vectors are read from
.IR mv_filename
via
.BR QccVIDMotionVectorsReadFile (3),
in which case
.BR QccVIDRDWTBlockEncode()
performs no motion estimation itself, using simply the
motion vectors read from the files for coding.
.LP
If
.IR quiet 
= 0,
.BR QccVIDRDWTBlockEncode()
will print to stdout a number of statistics concerning each frame as it
is encoding.
If
.I quiet
= 1,
this verbose output is suppressed.
.SS Decoding
.BR QccVIDRDWTBlockDecodeHeader()
decodes the header information in a bitstream produced by
.BR QccVIDRDWTBlockEncode() .
The input bitstream is
.I input_buffer
which must be of
.I QCCBITBUFFER_INPUT
type and open via a prior call to
.BR QccBitBufferStart (3).
The header information is returned in
.I num_rows
(vertical size of image-sequence frames),
.I num_cols
(horizontal size of image-sequence frames),
.I start_frame_num
(number of the first frame of the sequence),
.I end_frame_num
(number of the last frame of the sequence),
.I num_levels
(number of wavelet-transform levels),
and
.I target_bit_cnt
(number of bits encoded for each frame).
.LP
.B QccVIDRDWTBlockDecode()
decodes the bitstream
.IR input_buffer ,
reconstructing each image of the output image sequence and writing it
to a separate, numbered grayscale-image file.
The filename denoted by
.IR image_sequence
must contain one
.BR printf (3)-style
numerical descriptor which is filled in with the number of the current
frame being decoded.
The bitstream must already have had its header read by a prior call to
.BR QccVIDRDWTBlockDecodeHeader()
(i.e., you call
.BR QccVIDRDWTBlockDecodeHeader()
first and then
.BR QccVIDRDWTBlockDecode() ).
If
.IR quiet
= 0, then
.BR QccVIDRDWTBlockDecode()
prints a brief message to stdout after decoding each frame; if
.IR quiet
= 1, then this message is suppressed.
.LP
.IR filter1 ,
.IR filter2 ,
and
.IR filter3 
are interpolation filters for supporting the subpixel accuracy specified by
.IR subpixel_accuracy
which can be one of
.BR QCCVID_ME_FULLPIXEL ,
.BR QCCVID_ME_HALFPIXEL ,
.BR QCCVID_ME_QUARTERPIXEL ,
or 
.BR QCCVID_ME_EIGHTHPIXEL ,
indicating full-, half-, quarter-, or eighth-pixel accuracy, respectively.
See "SUBPIXEL ACCURACY" below.
.LP
.I mv_filename
gives the name of files of motion vectors.
If
.I mv_filename
is
.BR NULL ,
then
.BR QccVIDRDWTBlockDecode()
simply decodes the motion vectors to use in decoding from the bitstream
(the usual state of affairs).
On the other hand, if
.IR mv_filename
is not
.BR NULL ,
then the motion vectors stored in the bitstream are ignored and, rather,
the motion vectors are read from
.I mv_filename
instead.
.I mv_filename
should have a
.BR printf (3)-style
numerical descriptor which will then be filled in with
the current frame number before reading via
.BR QccVIDMotionVectorsReadFile (3).
.SH "ALGORITHM"
In recent years, there have been proposed
a number of video coders
that use the RDWT to circumvent
the shift variance of traditional critically sampled wavelet transforms,
a trait which has long hinder deployment of
motion estimation and compensation in the DWT domain.
The majority of prior work concerning
RDWT-based video coding originates in the
work of Park and Kim who proposed the RDWT-block
coder implemented here.
In essence, the RDWT-block coder works as follows.
An input frame is decomposed with a critically sampled
DWT via
.BR QccWAVSubbandPyramidDWT (3)
and partitioned into blocks wherein each
.IR N x N
block
.RI ( N
= 
.IR blocksize )
for 
is composed
of the coefficients from each subband that correspond spatially to
a particular
.IR N x N
block in the original image.
A full-search block-matching algorithm is then used to
compute motion vectors for each wavelet-domain block; the system uses as the
reference for this search an RDWT decomposition
of the previous
reconstructed frame,
generated by
.BR QccWAVWaveletRedundantDWT2D (3).
The motion-estimation procedure of the coder amounts
to identifying, for each block of the current frame, a particular
critically sampled
DWT in the RDWT, and a displacement
within that DWT
(see 
.BR QccWAVWaveletRedundantDWT2DSubsample (3)).
Transmission of a single motion vector
per block suffices to convey this all of this motion
information to the decoder.
.LP
After creating the motion-compensated residual in the critically
sampled DWT domain, the RDWT-block coder then performs intraframe coding
of the residual. Although it is possible to use any wavelet-domain
coder for this task, Park and Kim used the embedded SPIHT coder as the
intraframe coder. The QccPack implementation
of the RDWT-block coder does the same via a call to
.BR QccSPIHTEncode2 (3)
on the DWT-domain motion-compensated residual.
.LP
The coder developed by Park and Kim has often been called
the "low-band shift" (LBS) method due to their
proposal for implementing the RDWT via a sequence of
one-sample shifts and filter banks. However,
"low-band shift" is just one of several equivalent ways
of implementing the RDWT (the original
.I algorithme a trous
being another; see
.BR QccWAVWaveletRedundantDWT2D (3)).
Consequently, we refer to Park and Kim's method as "RDWT block"
to emphasize its use of traditional block-based motion estimation
and compensation, albeit in the RDWT domain, and to distinguish it
from other RDWT-based techniques employing significantly
different coder architectures.
.SH "SUBPIXEL ACCURACY"
As described originally by Park and Kim,
the RDWT-block algorithm uses motion estimation and compensation with
full, integer-pixel accuracy. However, due to the linearity of the RDWT,
it is possible to implement subpixel interpolation in the RDWT domain in
a manner similar to as done in the spatial domain to support traditional
subpixel accuracy. 
Specifically, one simply interpolates each subband of the RDWT to subpixel
accuracy independently.
.BR QccVIDRDWTBlockEncode()
and
.BR QccVIDRDWTBlockDecode()
both call
.BR QccVIDMotionEstimationCreateReferenceFrame (3)
for each subband of the RDWT of the reference frame to interpolate the subband
to the accuracy specified by
.IR subpixel_accuracy .
The filters
.IR filter1 ,
.IR filter2 ,
and
.IR filter3
are passed to
.BR QccVIDMotionEstimationCreateReferenceFrame (3)
to control whether filtered interpolation or bilinear interpolation
is performed at each step of the subpixel interpolation.
See
.BR QccVIDMotionEstimationCreateReferenceFrame (3)
for more detail.
.SH "SEE ALSO"
.BR rdwtblockencode (1),
.BR rdwtblockdecode (1),
.BR QccWAVWaveletRedundantDWT2D (3),
.BR QccWAVWaveletRedundantDWT2D (3),
.BR QccVIDMotionVectorsReadFile (3),
.BR QccVIDMotionVectorsWriteFile (3),
.BR QccVIDMotionEstimationCreateReferenceFrame (3),
.BR QccSPIHTEncode2 (3),
.BR QccPackVID (3),
.BR QccPackSPIHT (3),
.BR QccPackWAV (3),
.BR QccPackIMG (3),
.BR QccPack (3)

H.-W. Park and H.-S. Kim,
"Motion Estimation Using Lowband-Shift Method for
Wavelet-Based Moving-Picture Coding,"
.IR "IEEE Transactions on Image Processing" ,
vol. 9, no. 4, pp. 577-587, April 2000.

.SH AUTHOR
Written by Joe Boettcher <jbb15@msstate.edu> based on
the originally developed algorithm and code by Suxia Cui.

Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them and/or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

