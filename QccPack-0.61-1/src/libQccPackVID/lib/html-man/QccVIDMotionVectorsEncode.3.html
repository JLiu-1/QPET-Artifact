<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccVIDMotionVectorsEncode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccVIDMotionVectorsEncode, QccVIDMotionVectorsDecode - encode/decode 
motion vectors using the variable-length code specified in the H.261 standard 
 
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccVIDMotionVectorsEncode(const 
QccIMGImageComponent *</B><I>motion_vector_horizontal</I><B>, const QccIMGImageComponent 
*</B><I>motion_vector_vertical</I><B>, const QccVIDMotionVectorsTable *</B><I>mvd_table</I><B>, int 
</B><I>subpixel_accuracy</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>);</B>  <P>
<B>int QccVIDMotionVectorsDecode(QccIMGImageComponent 
*</B><I>motion_vector_horizontal</I><B>, QccIMGImageComponent *</B><I>motion_vector_vertical</I><B>, 
const QccVIDMotionVectorsTable *</B><I>table</I><B>, int </B><I>subpixel_accuracy</I><B>, QccBitBuffer 
*</B><I>input_buffer</I><B>);</B>  <P>
<B>int QccVIDMotionVectorsReadFile(QccIMGImageComponent 
*</B><I>motion_vectors_horizontal</I><B>, QccIMGImageComponent *</B><I>motion_vectors_vertical</I><B>, 
const QccString </B><I>filename</I><B>, int </B><I>frame_num</I><B>);</B>  <P>
<B>int QccVIDMotionVectorsWriteFile(const 
QccIMGImageComponent *</B><I>motion_vectors_horizontal</I><B>, const QccIMGImageComponent 
*</B><I>motion_vectors_vertical</I><B>, const QccString </B><I>filename</I><B>, int </B><I>frame_num</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
<B>QccVIDMotionVectorsEncode()</B> encodes the motion-vector field represented 
by <I>motion_vector_horizontal</I> (the horizontal vector components) and <I>motion_vector_vertical</I> 
(the vertical vector components), outputing the resulting bitstream to 
<I>output_buffer</I>. <P>
<B>QccVIDMotionVectorsDecode()</B> carries out the inverse process. 
Namely, the bitstream is read from <I>input_buffer</I> and the motion vectors 
are decoding and stored in <I>motion_vector_horizontal</I> and <I>motion_vector_vertical</I>. 
<P>
<B>QccVIDMotionVectorsEncode()</B> and <B>QccVIDMotionVectorsDecode()</B> support two 
methods of motion-vector coding: exponential-Golomb coding as in H.264, and 
Huffman coding as in H.261. See "EXPONENTIAL-GOLOMB CODING" and "HUFFMAN 
CODING" below for details on these coding procedures. If <I>mvd_table</I> is <B>NULL</B>, 
then exponential-Golomb coding is used. Otherwise, <I>mvd_table</I> is assumed 
to point to a valid <B><A HREF="QccVIDMotionVectorsTable.3.html">QccVIDMotionVectorsTable</B>(3)</A>
 created via <B><A HREF="QccVIDMotionVectorsTableCreate.3.html">QccVIDMotionVectorsTableCreate</B>(3)</A>
 
which is then used for Huffman coding. <P>
<B>QccVIDMotionVectorsReadFile()</B> and 
<B>QccVIDMotionVectorsWriteFile()</B> read and write, respectively, a motion 
vector field to/from a file. The motion vectors are stored in ASCII floating-point 
values, one vector per line. <I>filename</I> gives the filename of the file to 
read or write. <I>frame_num</I> is the frame number of the frame corresponding 
to the motion field to be read or written. <I>filename</I> should have a <B><A HREF="printf.3.html">printf</B>(3)</A>
-style 
numerical descriptor which will then be filled in with <I>frame_num</I> (e.g., 
football.%03d.pgm will become football.032.pgm if <I>frame_num</I> is 32; see <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
). 
 
<H2><A NAME="sect3" HREF="#toc3">HUFFMAN CODING </A></H2>
Essentially, the H.261 standard specifies that motion vectors 
are coded by doing a row-wise raster scan through the motion-vector field, 
starting at the upper-left and proceeding to the lower-right. To code the 
current motion vector, a difference vector is created by subtracting the 
previously encountered motion vector from the current motion vector. This 
difference vector is then coded using the variable-length Huffman coding 
table specified in Table 3/H.261 of the H.261 standard. The previous motion 
vector is considered to be the zero vector for the first vector of each 
row. Use <B><A HREF="QccVIDMotionVectorsTableCreate.3.html">QccVIDMotionVectorsTableCreate</B>(3)</A>
 to generate <I>mvd_table</I>. <P>
Note that 
the range of the motion vectors supported by the H.261 table is restricted. 
Specifically, each vector component can lie in the range -15 to +15 inclusive, 
thereby yielding difference values in the range -30 to +30. <P>
Strictly speaking, 
the H.261 standard does not support subpixel-accurate motion vectors. However, 
the H.261 motion-vector coding strategy has been extended for <B>QccVIDMotionVectorsEncode()</B> 
and <B>QccVIDMotionVectorsDecode()</B> to support the situtation when <I>subpixel_accuracy</I> 
is not full-pixel accuracy. Essentially, for subpixel accuracy, encoding 
is carried out as described above for the motion vector cast to integer-valued 
components. Then, the fractional part of each motion-vector component is 
scaled up to be an integer which is then coding using the same <I>mvd_table</I>. 
That is, if a motion vector is (<I>u</I>,<I></I> <I>v</I>), then the coding is <I>mvd_table</I>(<I>integer_u</I> 
- <I>previous_integer_u</I>), <I>mvd_table</I>(<I>integer_v</I> - <I>previous_integer_v</I>), <I>mvd_table</I>((<I>u</I> 
- <I>integer_u</I>) * S<I>),</I> and <I>mvd_table</I>((<I>v</I> - <I>integer_v</I>) * S<I>),</I> where <I>integer_u</I> and 
<I>integer_v</I> denote the integer part of <I>u</I> and <I>v</I>, respectively; <I>previous_integer_u</I> 
and <I>previous_integer_v</I> denote the integer part of the previous motion-vector 
components; <I>S</I> is a scaling constant suitably chosen so that all the fractional 
parts of the motion-vectors components are scaled to integer values (for 
example, <I>S</I> = 4 for quarter-pixel accuracy); and <I>mvd_table</I>() denotes table 
lookup into <I>mvd_table</I>.  
<H2><A NAME="sect4" HREF="#toc4">EXPONENTIAL-GOLOMB CODING </A></H2>
In H.264, motion vectors 
are coded in the raster-scan differencing procedure as described above 
for H.261, except that an exponential-Golomb code, rather than Huffman coding 
is used to code the difference values. <P>
In the implementation here, the 
difference values are created and, if <I>subpixel_accuracy</I> does not indicate 
full-pixel accuracy, the differences are scaled by an appropriate constant 
so that fractional values become integer values. <B><A HREF="QccENTExponentialGolombEncode.3.html">QccENTExponentialGolombEncode</B>(3)</A>
 
is then used to code each difference value with an exponential-Golomb code. 
The procedure is essentially the same as described in Sec. 9.1 of the H.264 
standard, except the codewords may differ slightly (although the code 
lengths are the same). <P>
Exponential-Golomb coding is advantageous for the 
coding of motion-vector differences since the range of values is not limited 
as is the case for the Huffman-based H.261 coding described above.  
<H2><A NAME="sect5" HREF="#toc5">RETURN 
VALUE </A></H2>
These routines return 0 on success, and 1 on failure.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="QccVIDMotionVectorsTable.3.html">QccVIDMotionVectorsTable</B>(3)</A>
, 
<B><A HREF="QccENTHuffmanEncode.3.html">QccENTHuffmanEncode</B>(3)</A>
, <B><A HREF="QccENTHuffmanDecode.3.html">QccENTHuffmanDecode</B>(3)</A>
, <B><A HREF="QccENTExponentialGolombEncode.3.html">QccENTExponentialGolombEncode</B>(3)</A>
, 
<B><A HREF="QccENTExponentialGolombDecode.3.html">QccENTExponentialGolombDecode</B>(3)</A>
, <B><A HREF="QccPackVID.3.html">QccPackVID</B>(3)</A>
, <B><A HREF="QccPackENT.3.html">QccPackENT</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 ITU-T, <I>Video Coding for Audiovisual Services at p x 64 kbit/s</I>, 
March 1993, ITU-T Recommendation H.261. <P>
ITU-T, <I>Advanced Video Coding for Generic 
Audiovisual Services</I>, May 2003, ITU-T Recommendation H.264. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright 
(C) 1997-2016  James E. Fowler <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">HUFFMAN CODING</A></LI>
<LI><A NAME="toc4" HREF="#sect4">EXPONENTIAL-GOLOMB CODING</A></LI>
<LI><A NAME="toc5" HREF="#sect5">RETURN VALUE</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
