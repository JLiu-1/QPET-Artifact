<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccVIDSpatialBlockDecodeHeader.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccVIDSpatialBlockEncode, QccVIDSpatialBlockDecode - encode/decode 
an image sequence using the spatial-block algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include 
"libQccPack.h"</B>  <P>
<B>int QccVIDSpatialBlockEncode(QccIMGImageSequence *</B><I>image_sequence</I><B>, 
const QccFilter *</B><I>filter1</I><B>, const QccFilter *</B><I>filter2</I><B>, const QccFilter *</B><I>filter3</I><B>, 
int </B><I>subpixel_accuracy</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>, int </B><I>blocksize</I><B>, int 
</B><I>num_levels</I><B>, int </B><I>target_bit_cnt</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, const QccString 
</B><I>mv_filename</I><B>, int </B><I>read_motion_vectors</I><B>, int </B><I>quiet</I><B>);</B>  <P>
<B>int QccVIDSpatialBlockDecodeHeader(QccBitBuffer 
*</B><I>input_buffer</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, int *</B><I>start_frame_num</I><B>, int 
*</B><I>end_frame_num</I><B>, int *</B><I>blocksize</I><B>, int *</B><I>num_levels</I><B>, int *</B><I>target_bit_cnt</I><B>);</B> 
 <P>
<B>int QccVIDSpatialBlockDecode(QccIMGImageSequence *</B><I>image_sequence</I><B>, const 
QccFilter *</B><I>filter1</I><B>, const QccFilter *</B><I>filter2</I><B>, const QccFilter *</B><I>filter3</I><B>, 
int </B><I>subpixel_accuracy</I><B>, QccBitBuffer *</B><I>input_buffer</I><B>, int </B><I>target_bit_cnt</I><B>, 
int </B><I>blocksize</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, const QccString 
</B><I>mv_filename</I><B>, int </B><I>quiet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccVIDSpatialBlockEncode()</B> 
encodes an <I>image_sequence</I> using the spatial-block video-coding algorithm. 
Essentially, the spatial-block algorithm involves traditional block-based 
motion estimation and motion compensation in the spatial-domain followed 
by a wavelet-based embedded coding of the motion-compensation resdiual; 
see "ALGORITHM" below for greater detail. <P>
<I>image_sequence</I> is the image sequence 
to be coded and should indicate a collection of grayscale images of the 
same size stored as separate, numbered files; the filename indicated by 
<I>image_sequence</I> must contain one  <B><A HREF="printf.3.html">printf</B>(3)</A>
-style numerical descriptor which 
will then be filled in the current frame number (e.g., football.%03d.pgm will 
become football.000.pgm, football.001.pgm, etc.; see <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
). Each frame 
of <I>image_sequence</I> must have a size which is an integer multiple of <I>blocksize</I> 
both horizontally and vertically. Both the <I>start_frame_num</I> and <I>end_frame_num</I> 
fields of <I>image_sequence</I> should indicate the desired starting and stopping 
frames, respectively, for the encoding; these should either be set manually 
or via a call to <B><A HREF="QccIMGImageSequenceFindFrameNums.3.html">QccIMGImageSequenceFindFrameNums</B>(3)</A>
 prior to calling 
<B>QccVIDSpatialBlockEncode()</B>. <P>
<I>filter1</I>, <I>filter2</I>, and <I>filter3</I> are interpolation 
filters for supporting the subpixel accuracy specified by <I>subpixel_accuracy</I> 
which can be one of <B>QCCVID_ME_FULLPIXEL</B>, <B>QCCVID_ME_HALFPIXEL</B>, <B>QCCVID_ME_QUARTERPIXEL</B>, 
or  <B>QCCVID_ME_EIGHTHPIXEL</B>, indicating full-, half-, quarter-, or eighth-pixel 
accuracy, respectively. <P>
<I>output_buffer</I> is the output bitstream which must 
be of <B>QCCBITBUFFER_OUTPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. 
<P>
<I>num_levels</I> gives the number of levels of dyadic wavelet decomposition 
to perform, and <I>wavelet</I> is the wavelet to use for decomposition. <P>
When encoding 
the current frame, <B>QccVIDSpatialBlockEncode()</B> will first output to <I>output_buffer</I> 
all the motion vectors for the frame, and then an embedded intraframe 
encoding of the motion-compensated residual. <I>target_bit_cnt</I> is the desired 
number of bits to output for each frame, including motion vectors and 
motion-compensated residual. After <I>target_num_bits</I> have been produced for 
the current frame, <B>QccVIDSpatialBlockEncode()</B> will call <B><A HREF="QccBitBufferFlush.3.html">QccBitBufferFlush</B>(3)</A>
 
to flush the bit-buffer contents to the output bitstream. Encoding of the 
next frame starts on the next byte boundary of the output bitstream. <P>
<I>mv_filename</I> 
gives the filename for files of motion vectors. If <I>read_motion_vectors</I> 
is <B>FALSE</B>, then the motion-vectors are written to <I>mv_filename</I> via <B><A HREF="QccVIDMotionVectorsWriteFile.3.html">QccVIDMotionVectorsWriteFile</B>(3)</A>
. 
<I>mv_filename</I> should have a <B><A HREF="printf.3.html">printf</B>(3)</A>
-style numerical descriptor which will 
then be filled in with the current frame number before writing, so that 
motion vectors are separated into multiple files, one file per frame. On 
the other hand, if <I>read_motion_vectors</I> is <B>TRUE</B>, then motion vectors are 
read from <I>mv_filename</I> via <B><A HREF="QccVIDMotionVectorsReadFile.3.html">QccVIDMotionVectorsReadFile</B>(3)</A>
, in which case 
<B>QccVIDSpatialBlockEncode()</B> performs no motion estimation itself, using 
simply the motion vectors read from the files for coding. <P>
If <I>quiet</I> = 0, 
<B>QccVIDSpatialBlockEncode()</B> will print to stdout a number of statistics 
concerning each frame as it is encoding. If <I>quiet</I> = 1, this verbose output 
is suppressed.  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<B>QccVIDSpatialBlockDecodeHeader()</B> decodes the header 
information in a bitstream produced by <B>QccVIDSpatialBlockEncode()</B>. The 
input bitstream is <I>input_buffer</I> which must be of <I>QCCBITBUFFER_INPUT</I> type 
and open via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. The header information 
is returned in <I>num_rows</I> (vertical size of image-sequence frames), <I>num_cols</I> 
(horizontal size of image-sequence frames), <I>start_frame_num</I> (number of 
the first frame of the sequence), <I>end_frame_num</I> (number of the last frame 
of the sequence), <I>num_levels</I> (number of wavelet-transform levels), and 
<I>target_bit_cnt</I> (number of bits encoded for each frame). <P>
<B>QccVIDSpatialBlockDecode()</B> 
decodes the bitstream <I>input_buffer</I>, reconstructing each image of the output 
image sequence and writing it to a separate, numbered grayscale-image file. 
The filename denoted by <I>image_sequence</I> must contain one <B><A HREF="printf.3.html">printf</B>(3)</A>
-style 
numerical descriptor which is filled in with the number of the current 
frame being decoded. The bitstream must already have had its header read 
by a prior call to <B>QccVIDSpatialBlockDecodeHeader()</B> (i.e., you call <B>QccVIDSpatialBlockDecodeHeader()</B> 
first and then <B>QccVIDSpatialBlockDecode()</B>). If <I>quiet</I> = 0, then <B>QccVIDSpatialBlockDecode()</B> 
prints a brief message to stdout after decoding each frame; if <I>quiet</I> = 
1, then this message is suppressed. <P>
<I>filter1</I>, <I>filter2</I>, and <I>filter3</I> are interpolation 
filters for supporting the subpixel accuracy specified by <I>subpixel_accuracy</I> 
which can be one of <B>QCCVID_ME_FULLPIXEL</B>, <B>QCCVID_ME_HALFPIXEL</B>, <B>QCCVID_ME_QUARTERPIXEL</B>, 
or  <B>QCCVID_ME_EIGHTHPIXEL</B>, indicating full-, half-, quarter-, or eighth-pixel 
accuracy, respectively. <P>
<I>mv_filename</I> gives the name of files of motion vectors. 
If <I>mv_filename</I> is <B>NULL</B>, then <B>QccVIDSpatialBlockDecode()</B> simply decodes 
the motion vectors to use in decoding from the bitstream (the usual state 
of affairs). On the other hand, if <I>mv_filename</I> is not <B>NULL</B>, then the motion 
vectors stored in the bitstream are ignored and, rather, the motion vectors 
are read from <I>mv_filename</I> instead. <I>mv_filename</I> should have a <B><A HREF="printf.3.html">printf</B>(3)</A>
-style 
numerical descriptor which will then be filled in with the current frame 
number before reading via <B><A HREF="QccVIDMotionVectorsReadFile.3.html">QccVIDMotionVectorsReadFile</B>(3)</A>
.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
The 
spatial-block video-coding algorithm here is a generic implementation of 
the simple process of spatial-domain motion estimation and motion compensation 
followed by an embedded wavelet-based coding of the residual frames. Motion 
estimation is carried out via a call to <B><A HREF="QccVIDMotionEstimationFullSearch.3.html">QccVIDMotionEstimationFullSearch</B>(3)</A>
, 
while motion compensation uses the reference frame created by a call to 
<B><A HREF="QccVIDMotionEstimationCreateReferenceFrame.3.html">QccVIDMotionEstimationCreateReferenceFrame</B>(3)</A>
, with subpixel accuracy 
supported as described for this latter routine. Finally, the motion-compensation 
residual is coded via a call to <B><A HREF="QccSPIHTEncode.3.html">QccSPIHTEncode</B>(3)</A>
 using the specified 
<I>wavelet</I> and <I>num_levels</I>.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="spatialblockencode.1.html">spatialblockencode</B>(1)</A>
, <B><A HREF="spatialblockdecode.1.html">spatialblockdecode</B>(1)</A>
, 
<B><A HREF="QccVIDMotionVectorsReadFile.3.html">QccVIDMotionVectorsReadFile</B>(3)</A>
, <B><A HREF="QccVIDMotionVectorsWriteFile.3.html">QccVIDMotionVectorsWriteFile</B>(3)</A>
, <B><A HREF="QccVIDMotionEstimationFullSearch.3.html">QccVIDMotionEstimationFullSearch</B>(3)</A>
, 
<B><A HREF="QccVIDMotionEstimationCreateReferenceFrame.3.html">QccVIDMotionEstimationCreateReferenceFrame</B>(3)</A>
, <B><A HREF="QccSPIHTEncode.3.html">QccSPIHTEncode</B>(3)</A>
, <B><A HREF="QccPackVID.3.html">QccPackVID</B>(3)</A>
, 
<B><A HREF="QccPackSPIHT.3.html">QccPackSPIHT</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 S. Cui, Y. Wang, 
and J. E. Fowler, "Motion Compensation Via Redundant-Wavelet Multihypothesis," 
<I>IEEE Transactions on Image Processing</I>, submitted March 2004. Revised February 
2005. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
