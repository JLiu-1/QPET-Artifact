.TH QCCIMGIMAGECOMPONENTMEAN 3 "QCCPACK" ""
.SH NAME
QccIMGImageComponentMean,
QccIMGImageComponentShapeAdaptiveMean,
QccIMGImageComponentVariance,
QccIMGImageComponentShapeAdaptiveVariance,
QccIMGImageComponentSubtractMean,
QccIMGImageComponentAddMean
\- 
mean and variance operations on image components
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "double QccIMGImageComponentMean(const QccIMGImageComponent *" image_component );
.br
.BI "double QccIMGImageComponentShapeAdaptiveMean(const QccIMGImageComponent *" image_component ", const QccIMGImageComponent *" alpha_mask );
.br
.sp
.BI "double QccIMGImageComponentVariance(const QccIMGImageComponent *" image_component );
.br
.BI "double QccIMGImageComponentShapeAdaptiveVariance(const QccIMGImageComponent *" image_component ", const QccIMGImageComponent *alpha_mask );
.br
.sp
.BI "int QccIMGImageComponentSubtractMean(QccIMGImageComponent *" image_component ", double *" mean ", const QccSQScalarQuantizer *" quantizer );
.br
.BI "int QccIMGImageComponentAddMean(QccIMGImageComponent *" image_component ", double " mean );
.SH DESCRIPTION
.BR QccIMGImageComponentMean()
returns the mean of the
.IR image
array of
.IR image_component .
.LP
.BR QccIMGImageComponentShapeAdaptiveMean()
performs a mean calculation similar to that of
.BR QccIMGImageComponentMean() ,
except that
.IR alpha_mask
is assumed to denote regions that are "transparent" in
.I image_component
and thus contain no valid pixel data.
That is,
.BR QccIMGImageComponentShapeAdaptiveMean()
skips over pixels in the mean calculation for which
.BR QccAlphaTransparent (3)
returns non-zero when applied to
.IR alpha_mask
at the current pixel location.
.LP
.BR QccIMGImageComponentVariance()
returns the variance of the
.IR image
array of
.IR image_component .
.LP
.BR QccIMGImageComponentShapeAdaptiveVariance()
performs a variance calculation similar to that of
.BR QccIMGImageComponentVariance() ,
except that
.IR alpha_mask
is assumed to denote regions that are "transparent" in
.I image_component
and thus contain no valid pixel data.
.LP
.BR QccIMGImageComponentSubtractMean()
first calculates the mean of
.IR image_component .
If
.IR quantizer
is not
.BR NULL ,
.BR QccSQScalarQuantization (3)
and
.BR QccSQInverseScalarQuantization (3)
are called in succession to calculate a quantized reconstruction
of the mean value, which is then subtracted from each pixel value of
.IR image_component .
On the other hand, if
.IR quantizer
is
.BR NULL ,
then the calculated mean is subtracted directly from each pixel value of
.IR image_component .
If
.IR mean
is not
.BR NULL,
the value subtracted from
.IR image_component ,
quantized or not,
is returned in the location pointed to by
.IR mean .
.LP
.BR QccIMGImageComponentAddMean()
restores the
.I mean
that was removed by
.BR QccIMGImageComponentSubtractMean() .
That is,
.IR mean
is added to each pixel in
.IR image_component .
.SH "RETURN VALUES"
.BR QccIMGImageComponentSubtractMean()
and
.BR QccIMGImageComponentAddMean()
return 0 on success and 1 on error;
the other routines return the mean or variance value they calculate.
.SH "SEE ALSO"
.BR QccAlphaTransparent (3),
.BR QccIMGImageComponent (3),
.BR QccPackIMG (3),
.BR QccPack (3)

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



