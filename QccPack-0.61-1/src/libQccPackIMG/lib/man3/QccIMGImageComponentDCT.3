.TH QCCIMGIMAGECOMPONENTDCT 3 "QCCPACK" ""
.SH NAME
QccIMGImageComponentDCT,
QccIMGImageComponentInverseDCT,
QccIMGImageDCT,
QccIMGImageInverseDCT
\- 
block-based DCT and inverse DCT of images and image components
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccIMGImageComponentDCT(const QccIMGImageComponent *" input_component ", QccIMGImageComponent *" output_component ", int " block_num_rows ", int " block_num_cols );
.br
.BI "int QccIMGImageComponentInverseDCT(const QccIMGImageComponent *" input_component ", QccIMGImageComponent *" output_component ", int " block_num_rows ", int " block_num_cols );
.br
.sp
.BI "int QccIMGImageDCT(const QccIMGImage *" input_image ", QccIMGImage *" output_image ", int " block_num_rows ", int " block_num_cols );
.br
.BI "int QccIMGImageInverseDCT(const QccIMGImage *" input_image ", QccIMGImage *" output_image ", int " block_num_rows ", int " block_num_cols );
.SH DESCRIPTION
.BR QccIMGImageComponentDCT()
calculates the two-dimension discrete cosine transform (2D DCT) of blocks from
.IR input_component ,
returning the resulting transformed blocks in
.IR output_component .
That is,
.BR QccIMGImageComponentDCT()
first partitions
.IR input_component
into distinct, non-overlapping blocks of size
.IR block_num_rows
rows by
.IR block_num_cols
columns, and then calls
.BR QccMatrixDCT (3)
to perform the 2D DCT on each block.
The transformed blocks are then placed into
.IR output_component ,
which must be allocated to the same size as
.IR input_component
prior to calling
.BR QccIMGImageComponentDCT() .
The size of both
.IR input_component
and
.IR output_component
must be evenly divisible by the block size; i.e.,
.IR input_component->num_rows
must be an integer multiple of
.IR block_num_rows
while
.IR input_component->num_cols
must be an integer multiple of
.IR block_num_cols .
.BR QccIMGImageComponentExtractBlock (3)
is used to partition
.IR input_component
into blocks, while
.BR QccIMGImageComponentInsertBlock (3)
is used to insert the transform blocks into
.IR output_component .
.LP
.BR QccIMGImageComponentInverseDCT()
calculates the two-dimensional inverse DCT of blocks from
.IR input_component ,
returning the transformed blocks in
.IR output_component .
Again,
.IR output_component
must be allocated to the same size as
.IR input_component
prior to calling
.BR QccIMGImageComponentInverseDCT() ,
and the size of both
.IR input_component
and
.IR output_component
must be evenly divisible by the block size
(which must be the same block size as used initially by
.BR QccIMGImageComponentDCT()
for sane results).
.BR QccIMGImageComponentInverseDCT()
calls
.BR QccMatrixInverseDCT (3)
to perform the inverse DCT for each block.
.LP
.BR QccIMGImageDCT()
and
.BR QccIMGImageInverseDCT()
perform the forward and inverse DCT, respectively, on
.IR image
by calling
.BR QccIMGImageComponentDCT()
and
.BR QccIMGImageComponentInverseDCT() ,
respectively, on each of the
.IR Y ,
.IR U ,
and
.IR V
components of the image.
.SH "RETURN VALUE"
These routines return 0 on success, 1 on failure.
.SH "SEE ALSO"
.BR QccMatrixDCT (3),
.BR QccMatrixInverseDCT (3),
.BR QccIMGImageComponentExtractBlock (3),
.BR QccIMGImageComponentInsertBlock (3),
.BR QccIMGImageComponent (3),
.BR QccIMGImage (3),
.BR QccPackIMG (3),
.BR QccPack (3)

A. K. Jain,
.IR "Fundamentals of Digital Image Processing" .
Englewood Cliffs, NJ: Prentice Hall, 1989.

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
