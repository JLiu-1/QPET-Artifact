.TH QCCIMGIMAGECUBEMSE 3 "QCCPACK" ""
.SH NAME
QccIMGImageCubeMSE,
QccIMGImageCubeShapeAdaptiveMSE,
QccIMGImageCubeMAE,
QccIMGImageCubeShapeAdaptiveMAE
\- 
mean squared error and maximum absolute error between image cubes
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "double QccIMGImageCubeMSE(const QccIMGImageCube *" image_cube1 ", const QccIMGImageCube *" image_cube2 );
.br
.BI "double QccIMGImageCubeShapeAdaptiveMSE(const QccIMGImageCube *" image_cube1 ", const QccIMGImageCube *" image_cube2 ", const QccIMGImageCube *" alpha_mask );
.br
.sp
.BI "double QccIMGImageCubeMAE(const QccIMGImageCube *" image_cube1 ", const QccIMGImageCube *" image_cube2 );
.br
.BI "double QccIMGImageCubeShapeAdaptiveMAE(const QccIMGImageCube *" image_cube1 ", const QccIMGImageCube *" image_cube2 ", const QccIMGImageCube *" alpha_mask );
.SH DESCRIPTION
.BR QccIMGImageCubeMSE()
returns the mean squared error (MSE) between
.IR image_cube1
and
.IR image_cube2 .
The MSE is calculated by taking the difference between a voxel in
.IR image_cube1
and its corresponding voxel in
.IR image_cube2 ,
squaring this difference, and finally averaging all the squared differences
over the entire image cube.
.IR image_cube1
and
.IR image_cube2
must have the same size.
.LP
.BR QccIMGImageCubeShapeAdaptiveMSE()
performs an MSE calculation similar to that of
.BR QccIMGImageCubeMSE() ,
except that
.IR alpha_mask
is assumed to denote regions that are "transparent" in
both
.IR image_cube1
and
.IR image_cube2
and thus contain no valid voxel data.
That is,
.BR QccIMGImageCubeShapeAdaptiveMSE()
skips over voxels in the MSE calculation for which
.BR QccAlphaTransparent (3)
returns non-zero when applied to
.IR alpha_mask
at the current voxel location.
If
.IR alpha_mask
is
.BR NULL ,
the usual, full-cube MSE is calculated via
.BR QccIMGImageCubeMSE() .
.IR image_cube1 ,
.IR image_cube2 ,
and
.IR alpha_mask
(if it is
.RB non- NULL )
must all have the same size.
.LP
.BR QccIMGImageCubeMAE()
returns the maximum absolute error (MAE) between
.IR image_cube1
and
.IR image_cube2 .
The MAE is calculated by taking the difference between a voxel in
.IR image_cube1
and its corresponding voxel in
.IR image_cube2 ,
and then calculating the absolute value of this difference using
.BR fabs (3).
The largest absolute value encountered in this fashion
over the entire image cube is returned by
.BR QccIMGImageCubeMAE() .
.IR image_cube1
and
.IR image_cube2
must have the same size.
.LP
.BR QccIMGImageCubeShapeAdaptiveMAE()
performs an MAE calculation similar to that of
.BR QccIMGImageCubeMAE() ,
except that
.IR alpha_mask
is assumed to denote regions that are "transparent" in
both
.IR image_cube1
and
.IR image_cube2
and thus contain no valid voxel data.
.IR alpha_mask
is
.BR NULL ,
the usual, full-cube MAE is calculated via
.BR QccIMGImageCubeMAE() .
.IR image_cube1 ,
.IR image_cube2 ,
and
.IR alpha_mask
(if it is
.RB non- NULL )
must all have the same size.
.SH "RETURN VALUES"
These routines return the value of the MSE or MAE quantity they calculate;
in the case of an error, these routines return 0.0.
.SH "SEE ALSO"
.BR fabs (3),
.BR QccAlphaTransparent (3),
.BR QccIMGImageCube (3),
.BR QccPackIMG (3),
.BR QccPack (3)

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



