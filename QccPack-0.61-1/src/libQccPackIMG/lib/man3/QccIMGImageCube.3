.TH QCCIMGIMAGECUBE 3 "QCCPACK" ""
.SH NAME
QccIMGImageCube \- 
data structure 
.B QccIMGImageCube
and corresponding
.B ICB
file format for a 3D image cube
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccIMGImageCubeInitialize(QccIMGImageCube *" image_cube );
.br
.BI "int QccIMGImageCubeAlloc(QccIMGImageCube *" image_cube );
.br
.BI "void QccIMGImageCubeFree(QccIMGImageCube *" image_cube );
.br
.BI "int QccIMGImageCubePrint(const QccIMGImageCube *" image_cube );
.br
.sp
.BI "int QccIMGImageCubeSetMin(QccIMGImageCube *" image_cube );
.br
.BI "int QccIMGImageCubeSetMax(QccIMGImageCube *" image_cube );
.br
.BI "int QccIMGImageCubeSetMaxMin(QccIMGImageCube *" image_cube );
.br
.sp
.BI "int QccIMGImageCubeResize(QccIMGImageCube *" image_cube ", int " num_frames ", int " num_rows ", int " num_cols );
.SH DESCRIPTION
QccPack provides data structure
.B QccIMGImageCube
for representing a three-dimensional image cube, which can
be used for various applications involving volumetric imagery,
such as multispectral and hyperspectral data.
This image-cube structure can be read from and written to 
.BR ICB -format
files, or a
.B QccIMGImageCube
structure can be used without file input or output.
.LP
The main component of a
.B QccIMGImageCube
structure is a three-dimensional array of floating-point values
representing the cube's voxels.
The image cube is represented as a collection of two-dimensional
"frames," where each frame has the same number of rows and columns.
For multispectral and hyperspectral imagery, these 2D
frames would usually be spectral bands.
.SH "DATA STRUCTURE"
The
.B QccIMGImageCube
data structure is defined as:
.RS
.nf

typedef QccVolume QccIMGImageVolume;
typedef struct
{
  QccString filename;
  QccString magic_num;
  int major_version;
  int minor_version;
  int num_frames;
  int num_rows;
  int num_cols;
  double min_val;
  double max_val;
  QccIMGImageVolume volume;
} QccIMGImageCube;
.fi
.RE
.LP
The fields of
.B QccIMGImageCube
are as follows:
.TP
.I filename
The name of the file.
.TP
.IR magic_num ", " major_version ", " minor_version
The magic number and version of the file.
.TP
.IR num_frames ", " num_rows ", " num_cols
The number of frames, rows, and columns of the image cube.
.TP
.IR min_val ", " max_val
The minimum and maximum voxel values in the image cube.
.TP
.IR volume
The array of voxels.
.SH "FILE FORMAT"
For reading and writing structures
of type
.BR QccIMGImageCube ,
QccPack provides the
.B ICB
file format.
This file format starts with an ASCII header followed by
binary data.
The ASCII header starts with a magic number, and can be
followed with any amount of white space (blanks, `\\t' (tab),
`\\n' (newline), `\\r' (carriage return)) and/or
comments lines (lines starting with "#").  Following this white space,
additional ASCII
header information is given, separated by blanks and newlines.
Binary data follows this ASCII header information.
Note:  one (and only one) newline 
.B must
immediately follow the last component of ASCII header information before the
start of the binary data.
.LP
The
.B ICB
file format consists of the following information:
.RS
.sp
.BI ICB X.X
.br
.I "<white space>"
.br
.I "C R F"
.br
.IR "min max"
.br
.IR "i111 i112" \|.\|.\|.
.br
.IR "i121 i122" \|.\|.\|.
.br
\|.
.br
\|.
.br
\|.
.br
.IR "i211 i212" \|.\|.\|.
.br
.IR "i221 i222" \|.\|.\|.
.br
\|.
.br
\|.
.br
\|.
.br
.sp
.RE
where
.B ICB
is the magic number,
.I X.X
is the version number,
.I "<white space>"
is white space and/or 
comment lines, 
.I C
is the number of columns of the image cube,
.I R
is the number of rows, 
.I F
is the number of frames, 
and
.I min
and
.I max
give the range of the values of the image cube.
.I ifrc
is the voxel for the
.IR f th
frame, the
.IR r th
row,
and the
.IR c th
column of the image cube.
.IR C ", " R ", " F ", " min ", and "
.I max
are stored in ASCII.  The image cube itself,
.IR ifrc ,
is stored as binary floating-point numbers (4 bytes each, MSB first,
see
.BR QccFileWriteDouble (3)).
In the nomenclature common to multispectral and hyperspectral
applications, the image cube data is stored in
band-sequential (BSQ) format.
.SH "ROUTINES"
.B QccIMGImageCubeInitialize()
should be called before any use of a
.B QccIMGImageCube
structure.
.B QccIMGImageCubeInitialize()
initializes the fields of
.I image_cube
to the following values:
.RS

.IR filename :
.B NULL
string
.br
.IR magic_num :
.B QCCIMGIMAGECUBE_MAGICNUM
.br
.IR major_version ", " minor_version :
initialized to output of 
.BR QccGetQccPackVersion (3)
.br
.IR num_frames :
0
.br
.IR num_rows :
0
.br
.IR num_cols :
0
.br
.IR min_val :
0
.br
.IR max_val :
0
.br
.IR volume :
.B NULL
.RE
.LP
.B QccIMGImageCubeAlloc()
allocates storage space for 
.IR image_cube->volume .
If 
.I image_cube->volume
is not
.BR NULL ,
.B QccIMGImageCubeAlloc()
returns immediately without changing the state of any memory allocation.
Otherwise,
the 
.I image_cube->volume
array is allocated.
The fields
.IR image_cube->num_frames ,
.IR image_cube->num_rows ,
and
.IR image_cube->num_cols 
must be set prior to calling
.BR QccIMGImageCubeAlloc() .
.LP
.B QccIMGImageCubeFree()
frees the
.I image_cube->volume
array previously allocated by
.BR QccIMGImageCubeAlloc() .
.LP
.B QccIMGImageCubePrint()
prints the contents of
.I image_cube
to stdout.
.LP
.BR QccIMGImageCubeSetMin()
determines the smallest voxel value in
.IR image_cube->volume
and sets
.IR image_cube->min_val
to that minimum value.
.LP
.BR QccIMGImageCubeSetMax()
determines the largest voxel value in
.IR image_cube->volume
and sets
.IR image_cube->max_val
to that maximum value.
.LP
.BR QccIMGImageCubeSetMaxMin()
sets both
.IR image_cube->max_val
and
.IR image_cube->min_val
by calling
.BR QccIMGImageCubeSetMax()
and
.BR QccIMGImageCubeSetMin()
in succession.
.LP
.BR QccIMGImageCubeResize()
calls
.BR QccVolumeResize (3)
to change the size of
.IR image_cube
to
.IR num_frames " x " num_rows " x " num_cols .
.SH "RETURN VALUE"
These routines return 0 on success, and 1 on failure.
.SH "SEE ALSO"
.BR QccFileWriteDouble (3),
.BR QccPackIMG (3),
.BR QccPack (3)

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

