<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccSPECK3DEncode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccSPECK3DEncode, QccSPECK3DDecode - encode/decode an image cube 
using the 3D-SPECK algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccSPECK3DEncode(const 
QccIMGImageCube *</B><I>image_cube</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
QccBitBuffer *</B><I>output_buffer</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  <P>
<B>int QccSPECK3DDecodeHeader(QccBitBuffer 
*</B><I>input_buffer</I><B>, int *</B><I>transform_type</I><B>, int *</B><I>temporal_num_levels</I><B>, int *</B><I>spatial_num_levels</I><B>, 
int *</B><I>num_frames</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int 
*</B><I>max_coefficient_bits</I><B>);</B>  <P>
<B>int QccSPECK3DDecode(QccBitBuffer *</B><I>input_buffer</I><B>, 
QccIMGImageCube *</B><I>image_cube</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
double </B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_bit</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccSPECK3DEncode()</B> encodes an image cube, <I>image_cube</I>, using 
a 3D generalization of the SPECK algorithm. The original SPECK algorithm 
was developed for 2D images by Pearlman <I>et al</I>.; it was latter extended 
to 3D by Tang <I>et al</I>. In essence, the 3D-SPECK algorithm involves a 3D DWT 
followed by  a progressive "bitplane" coding of the wavelet coefficients 
using a cube-splitting quantization structure based on octtrees. See "ALGORITHM" 
below for more detail. <P>
<I>image_cube</I> is the image cube to be coded and <I>output_buffer</I> 
is the output bitstream. <I>output_buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> type 
and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccSPECK3DEncode</B>() 
supports the use of both wavelet-packet and dyadic wavelet-transform decompositions. 
If <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B>, a dyadic DWT is used; 
if <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B>, a wavelet-packet DWT 
is used. <I>temporal_num_levels</I> and <I>spatial_num_levels</I> give the number of 
levels of wavelet decomposition to perform for both transform types; for 
a dyadic transform, <I>temporal_num_levels</I> should equal <I>spatial_num_levels</I>. 
<I>wavelet</I> is the wavelet to use for decomposition. <P>
The bitstream output from 
the 3D-SPECK encoder is embedded, meaning that any prefix of the bitstream 
can be decoded to give a valid  representation of the image.  The 3D-SPECK 
encoder essentially produces output bits until the number of bits output 
reaches <I>target_bit_cnt</I>, the desired (target) total length of the output 
bitstream in bits, and then it stops. Note that this is the bitstream length 
in bits, not the rate of the bitstream (which would be expressed in bits 
per voxel). <P>
<B>QccSPECK3DEncode()</B> optionally supports the use of a shape-adaptive 
DWT (SA-DWT) rather than the usual DWT. That is,  <B>QccSPECK3DEncode()</B> can 
call <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 as the wavelet transform 
rather than the usual <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
. The use of a SA-DWT 
is indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then the usual DWT is 
used. In the case of a SA-DWT, <I>mask</I>  gives the transparency mask which indicates 
which voxels of the image are non-transparent and thus have data that is 
to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
for more details on the calculation of this SA-DWT. See "ALGORITHM" below 
for details on how the 3D-SPECK algorithm handles shape-adaptive coding. 
 
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccSPECK3DDecodeHeader()</B> decodes the header information  in 
a bitstream previously produced by <B>QccSPECK3DEncode()</B>. The input bitstream 
is <I>input_buffer</I> which must be of <B>QCCBITBUFFER_INPUT</B> type and opened via 
a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
The header information is returned 
in <I>transform_type</I> (either <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B> or <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B> 
to indicate a dyadic or wavelet-packet transform decomposition, respectively), 
<I>temporal_num_levels</I> (number of levels of wavelet decomposition in the 
temporal direction), <I>spatial_num_levels</I> (number of levels of wavelet decomposition 
in the spatial directions), <I>num_frames</I> (size of the image cube in the 
temporal direction), <I>num_rows</I> (vertical size of image cube), <I>num_cols</I> 
(horizontal size of image cube), <I>image_mean</I> (the mean value of the original 
image cube), and <I>max_coefficient_bits</I> (indicates the precision, in number 
of bits, of the wavelet coefficient with the largest magnitude). <P>
<B>QccSPECK3DDecode()</B> 
decodes the bitstream <I>input_buffer</I>, producing the reconstructed image 
cube, <I>image_cube</I>. The bitstream must already have had its header read by 
a prior call to <B>QccSPECK3DDecodeHeader()</B> (i.e., you call <B>QccSPECK3DDecodeHeader() 
</B> first and then <B>QccSPECK3DDecode()</B>). If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, 
then decoding stops when the end of the input bitstream is reached; otherwise, 
decoding stops when <I>target_num_bits</I> from the input bitstream have been 
decoded. <P>
If a SA-DWT was used in 3D-SPECK encoding, then the original transparency 
mask should be passed to  <B>QccSPECK3DDecode()</B> as <I>mask</I>. That is, <I>mask</I> should 
be the same transparency mask (untransformed)  that was passed to <B>QccSPECK3DEncode()</B>. 
Note that <B>QccSPECK3DDecode()</B> will transform this <I>mask</I> via a Lazy wavelet 
transform, and then pass the transformed mask to  <B><A HREF="QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT</B>(3)</A>
. 
If the usual, full-volume DWT was used in encoding, then <I>mask</I> should be 
a NULL pointer.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
The 3D-SPECK algorithm involves a 3D DWT followed 
by a progressive encoding of the bitplanes of wavelet coefficients. As 
is common with bitplane-based embedded coders, the encoder of the 3D-SPECK 
algorithm codes significance information in a significance pass followed 
by refinement-bit information in a refinement pass. The significance pass 
determines the significance of a wavelet coefficient against a given threshold, 
while the refinement pass codes the bits of those coefficients previously 
determined to be significant. The 3D-SPECK algoorithm uses octtree partitioning 
in which the significance state of an entire cube of coefficients is tested 
and coded, the cube is subdivided into eight subcubes of approximately 
equal size, and the significance-coding process is repeated recursively 
on each of the subcubes. Unlike the original 2D SPECK algorithm, the 3D-SPECK 
algorithm uses only one type of set, rather than having S and I sets as 
in 2D SPECK. Consequently, each subband in the DWT decomposition is added 
to an LIS at the start of the 3D-SPECK algorithm, whereas the 2D algorithm 
initializes with only the baseband subband in an LIS. <P>
The QccPack implementation 
of 3D-SPECK supports shape-adaptive coding by generalizing the 2D OB-SPECK 
approach described by Lu and Pearlman to 3D (see <B><A HREF="QccSPECKEncode.3.html">QccSPECKEncode</B>(3)</A>
).  
<H2><A NAME="sect6" HREF="#toc6">SEE 
ALSO </A></H2>
<B><A HREF="speckencode3d.1.html">speckencode3d</B>(1)</A>
, <B><A HREF="speckdecode3d.1.html">speckdecode3d</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3D.3.html">QccWAVSubbandPyramid3D</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
, 
<B><A HREF="QccSPECKEncode.3.html">QccSPECKEncode</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 X. Tang, W. 
A. Pearlman, and J. W. Modestino, "Hyperspectral Image Compression Using 
Three-Dimensional Wavelet Coding," in <I>Image and Video Communications and 
Processing</I>, Santa Clara, CA, January 2003, Proc. SPIE 5022, pp. 1037-1047. 
<P>
 W. A. Pearlman, A. Islam, N. Nagaraj, and A. Said, "Efficient, Low-Complexity 
Image Coding with a Set-Partitioning Embedded Block Coder," <I>IEEE Transactions 
on Circuits and Systems for Video Technology</I>, to appear, 2003. <P>
 A. Islam 
and W. A. Pearlman, "An Embedded and Efficient Low-Complexity Hierarchical 
Image Coder," in <I>Visual Communications and Image Processing</I>, K. Aizawa, 
R. L. Stevenson, and Y.-Q. Zhang, Eds., San Jose, CA, January 1999, Proc. SPIE 
3653, pp. 294-305. <P>
 Z. Lu and W. A. Pearlman, "Wavelet Video Coding of Video 
Object by Object-Based SPECK Algorithm," in <I>Proceedings of the Picture 
Coding Symposium</I>, Seoul, Korea, April 2001, pp. 413-416. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright 
(C) 1997-2016  James E. Fowler <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
