<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccSPECKEncode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccSPECKEncode, QccSPECKDecode - encode/decode an image using the 
SPECK algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccSPECKEncode(const 
QccIMGImageComponent *</B><I>image</I><B>, const QccIMGImageComponent *</B><I>mask</I><B>, int </B><I>num_levels</I><B>, 
int </B><I>target_bit_cnt</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>);</B> 
 <P>
<B>int QccSPECKDecodeHeader(QccBitBuffer *</B><I>input_buffer</I><B>, int *</B><I>num_levels</I><B>, 
int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int *</B><I>max_coefficient_bits</I><B>);</B> 
 <P>
<B>int QccSPECKDecode(QccBitBuffer *</B><I>input_buffer</I><B>, QccIMGImageComponent *</B><I>image</I><B>, 
const QccIMGImageComponent *</B><I>mask</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>, double </B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B> 
 
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccSPECKEncode()</B> encodes an image component, <I>image</I>, 
using the Set-Partitioning Embedded Block (SPECK) algorithm by Pearlman 
<I>et al.</I> The SPECK algorithm involves a 2D DWT followed by  a progressive 
"bitplane" coding of the wavelet coefficients using a block-splitting quantization 
structure based on quadtrees. <P>
<I>image</I> is the image component to be coded 
and <I>output_buffer</I> is the output bitstream. <I>output_buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> 
type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<I>num_levels</I> gives 
the number of levels of dyadic wavelet decomposition to perform, and <I>wavelet</I> 
is the wavelet to use for decomposition. <P>
The bitstream output from the 
SPECK encoder is embedded, meaning that any prefix of the bitstream can 
be decoded to give a valid  representation of the image.  The SPECK encoder 
essentially produces output bits until the number of bits output reaches 
<I>target_bit_cnt</I>, the desired (target) total length of the output bitstream 
in bits, and then it stops. Note that this is the bitstream length in bits, 
not the rate of the bitstream (which would be expressed in bits per pixel). 
<P>
<B>QccSPECKEncode()</B> optionally supports the use of a shape-adaptive DWT (SA-DWT) 
rather than the usual DWT. That is,  <B>QccSPECKEncode()</B> can call <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 
as the wavelet transform rather than the usual <B><A HREF="QccWAVSubbandPyramidDWT.3.html">QccWAVSubbandPyramidDWT</B>(3)</A>
. 
The use of a SA-DWT is indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then 
the usual DWT is used. In the case of a SA-DWT, <I>mask</I>  gives the transparency 
mask which indicates which pixels of the image are non-transparent and 
thus have data that is to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 
for more details on the calculation of this SA-DWT. See "Shape-Adaptive Coding" 
below for details on how the SPECK algorithm handles shape-adaptive coding. 
 
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccSPECKDecodeHeader()</B> decodes the header information  in a 
bitstream previously produced by <B>QccSPECKEncode()</B>. The input bitstream 
is <I>input_buffer</I> which must be of <B>QCCBITBUFFER_INPUT</B> type and opened via 
a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
The header information is returned 
in <I>num_levels</I> (number of levels of wavelet decomposition), <I>num_rows</I> (vertical 
size of image), <I>num_cols</I> (horizontal size of image), <I>image_mean</I> (the mean 
value of the original image), and <I>max_coefficient_bits</I> (indicates the 
precision, in number of bits, of the wavelet coefficient with the largest 
magnitude). <P>
<B>QccSPECKDecode()</B> decodes the bitstream <I>input_buffer</I>, producing 
the reconstructed image component, <I>image</I>. The bitstream must already have 
had its header read by a prior call to <B>QccSPECKDecodeHeader()</B> (i.e., you 
call <B>QccSPECKDecodeHeader() </B> first and then <B>QccSPECKDecode()</B>). If <I>target_bit_cnt</I> 
is <B>QCCENT_ANYNUMBITS</B>, then decoding stops when the end of the input bitstream 
is reached; otherwise, decoding stops when <I>target_num_bits</I> from the input 
bitstream have been decoded. <P>
If a SA-DWT was used in SPECK encoding, then 
the original transparency mask should be passed to  <B>QccSPECKDecode()</B> as 
<I>mask</I>. That is, <I>mask</I> should be the same transparency mask (in the spatial 
domain) that was passed to <B>QccSPECKEncode()</B>. Note that <B>QccSPECKDecode()</B> 
will transform this <I>mask</I> via a Lazy wavelet transform, and then pass the 
transformed mask to  <B><A HREF="QccWAVSubbandPyramidInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidInverseShapeAdaptiveDWT</B>(3)</A>
. If 
the usual DWT was used in encoding, then <I>mask</I> should be a NULL pointer. 
 
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM DETAILS </A></H2>
The SPECK algorithm follows the popular bitplane-coding 
approach to successive approximation of wavelet coefficients. As such, 
the SPECK coder performs two passes through the set of wavelet coefficients: 
the significance pass and the refinement pass. The significance pass describes 
the significance state for each coefficient---whether or not the coefficient 
magnitude is greater than or less than the current significance threshold. 
Thus, for a given threshold, the significance pass amounts to the coding 
of a binary-valued significance map. On the other hand, the refinement pass 
produces a successive approximation to those coefficients that are already 
known to be significant by coding the current coefficient-magnitude bitplane 
for those significant coefficients. After each iteration of the significance 
and refinement passes, the  significance threshold is divided in half, 
and the process is repeated for the next bitplane. <P>
For coding the binary 
significance map, the SPECK algorithm parititions sets of coefficients 
into smaller and smaller sets. Unlike zerotree set-partitioning algorithms 
such as SPIHT, SPECK eliminates the cross-scale aggregation of coefficients 
and  focuses the set-partitioning process instead on sets of contiguous 
coefficients from within a single subband. Specifically, SPECK codes the 
significance map with quadtrees, a well known method of spatial partitioning. 
In quadtree partitioning, the significance state of an entire block of 
coefficients is tested and coded, the block is subdivided into four subblocks 
of approximately equal size, and the significance-coding process is repeated 
recursively on each of the subblocks. <P>
As with SPIHT, the SPECK algorithm 
stores sets in implicitly sorted lists. Insignificant sets are placed in 
a list of insigificant sets (LIS). During the sorting pass, each insignificant 
set in an LIS is tested for significance against the current threshold. 
If the set becomes significant, it is split into four subsets according 
to the quadtree decomposition structure described above. The four new sets 
are placed into an LIS, recursively tested for significance, and split 
again if needed. SPECK maintains multiple LIS lists in order to implicitly 
process sets according to their size. During the sorting pass, each time 
a set is split, the resulting subsets move to the next LIS. When a set 
is reduced in size to a single coefficient, and that coefficient becomes 
significant, then the singleton set is moved from its LIS to a list of 
significant pixels (LSP) for later processing in the refinement pass. <P>
The 
SPECK implementation in QccPackSPECK follows the algorithm described in 
the paper by Pearlman, Islam, Nagaraj, and Said, except that, as described 
by Pearlman <I>et al.</I>, the CodeS() procedure partitions a set into four subsets 
and then, for each subset, encodes the significance state of the subset 
and recursively calls CodeS() on the subset. On the other hand, in the 
QccPack implementation, once CodeS() partitions a set into  subsets, ProcessS() 
is called on each subset. ProcessS() then in turn codes the significance 
state of the subset as well as calls CodeS() for the subset. That is to 
say, as originally described by Pearlman()  <I>et al.</I>, recursion in SPECK 
is limited to within CodeS(), whereas, in the  QccPack implementation 
of SPECK, ProcessS() and CodeS() recursively call one another. This latter 
recursion strategy is a bit simpler to code, while performance to the 
original algorithm is identical.  
<H2><A NAME="sect6" HREF="#toc6">PERFORMANCE </A></H2>
The QccPack implementation 
of the SPECK algorithm was coded "from scratch," with no consultation 
of the original SPECK source code produced at RPI by Pearlman <I>et al.</I> The 
QccPack implementation follows the description of the SPECK algorithm 
given by Pearlman <I>et al.</I> in their ITCSVT paper as closely as can be extrapolated 
from that description, except as noted above. However,  since no algorithm 
of complexity can ever be described <I>completely</I> in a journal article, it 
is inevitable that certain subtle details were implemented in the QccPack 
SPECK coder  differently from in the coder used by Pearlman <I>et al.</I> for 
their results. As a consequence, the performance of the QccPack implementation 
differs slightly from that reported by Pearlman <I>et al.</I> in their ITCSVT 
paper. However, the difference has been observed to be rather small, with 
the QccPack implementation achieving PSNR typically 0.05 dB  below that 
reported by Pearlman <I>et al.</I> <P>
A quantitative comparison follows using the 
three "standard" images (Lenna, Barbara, and Goldhill) provided with QccPack. 
 In all of the results, the wavelet transform employed is a 5-level dyadic 
decomposition using the 9/7 Cohen-Daubechies-Feauveau biorthogonal wavelet 
with symmetric extension at the image boundaries (this is the same transform 
used in the paper by Pearlman  <I>et al.</I>). The RPI results refer to the results 
reported in the ITCSVT paper by Pearlman <I>et al.</I> <P>
  <blockquote>                Lenna 
<BR>
  ------------------------------------- <BR>
  | Rate   |          PSNR (db)       | <BR>
  | (bpp)  |     RPI         QccPack 
 | <BR>
  ------------------------------------ <BR>
  |  0.25  |    34.03    |    33.99   | <BR>
  |  0.5   |    37.10    |    37.10   
| <BR>
  |  1.0   |    40.25    |    40.25   | <BR>
  ------------------------------------- <BR>
 <P>
 <P>
                Barbara <BR>
  ------------------------------------- <BR>
  | Rate 
  |          PSNR (db)       | <BR>
  | (bpp)  |     RPI         QccPack  | <BR>
  ------------------------------------ <BR>
 
 |  0.25  |    27.76    |    27.69   | <BR>
  |  0.5   |    31.54    |    31.48   | <BR>
  |  1.0 
  |    36.49    |    36.44   | <BR>
  ------------------------------------- <BR>
 <P>
 <P>
                Goldhill <BR>
  ------------------------------------- <BR>
  | Rate   | 
         PSNR (db)       | <BR>
  | (bpp)  |     RPI         QccPack  | <BR>
  ------------------------------------ <BR>
  |  
0.25  |    30.50    |    30.43   | <BR>
  |  0.5   |    33.03    |    32.95   | <BR>
  |  1.0  
 |    36.36    |    36.32   | <BR>
  ------------------------------------- <BR>
  </blockquote>
<P>
  
<H2><A NAME="sect7" HREF="#toc7">SHAPE-ADAPTIVE CODING </A></H2>
Lu and Pearlman developed 
a variant of the SPECK algorithm for coding arbitrarily shaped image objects. 
This object-based SPECK (OB-SPECK) algorithm follows the common methodology 
for shape-adaptive embedded coders, namely, transparent regions are considered 
to be permanently insignificant. During set partitioning in OB-SPECK, when 
a set contains no opaque coefficients, it is pruned from the quadtree 
decomposition. The QccPack implementation of SPECK handles shape-adaptive 
coding identically to OB-SPECK.  
<H2><A NAME="sect8" HREF="#toc8">SEE ALSO </A></H2>
<B><A HREF="speckencode.1.html">speckencode</B>(1)</A>
, <B><A HREF="speckdecode.1.html">speckdecode</B>(1)</A>
, 
<B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid.3.html">QccWAVSubbandPyramid</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramidDWT.3.html">QccWAVSubbandPyramidDWT</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 W. A. Pearlman, A. Islam, N. Nagaraj, and A. Said, "Efficient, 
Low-Complexity Image Coding with a Set-Partitioning Embedded Block Coder," 
<I>IEEE Transactions on Circuits and Systems for Video Technology</I>, to appear, 
2003. <P>
 A. Islam and W. A. Pearlman, "An Embedded and Efficient Low-Complexity 
Hierarchical Image Coder," in <I>Visual Communications and Image Processing</I>, 
K. Aizawa, R. L. Stevenson, and Y.-Q. Zhang, Eds., San Jose, CA, January 1999, 
Proc. SPIE 3653, pp. 294-305. <P>
 Z. Lu and W. A. Pearlman, "Wavelet Video Coding 
of Video Object by Object-Based SPECK Algorithm," in <I>Proceedings of the 
Picture Coding Symposium</I>, Seoul, Korea, April 2001, pp. 413-416. <P>
  
<H2><A NAME="sect9" HREF="#toc9">AUTHOR 
</A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
  
<H2><A NAME="sect10" HREF="#toc10">LICENSE </A></H2>
The Set-Partitioning Embedded 
Block (SPECK) algorithm is protected by US Patent #6,671,413 (issued December 
30, 2003) and by patents pending. An implementation of the SPECK algorithm 
is included herein (utility programs speckencode and speckdecode, and 
speck.c in the QccPack library) with the permission of Dr. William A. Pearlman, 
exclusive holder of patent rights. Dr. Pearlman has graciously granted a 
license with certain restrictions governing the terms and conditions for 
use, copying, distribution, and modification of the SPECK algorithm implementation 
contained herein. Specifically, only use in academic and non-commercial 
research is permitted, while all commercial use is prohibited. Refer to 
the file LICENSE-SPECK for more details. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM DETAILS</A></LI>
<LI><A NAME="toc6" HREF="#sect6">PERFORMANCE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">SHAPE-ADAPTIVE CODING</A></LI>
<LI><A NAME="toc8" HREF="#sect8">SEE ALSO</A></LI>
<LI><A NAME="toc9" HREF="#sect9">AUTHOR</A></LI>
<LI><A NAME="toc10" HREF="#sect10">LICENSE</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
