.TH QCCWAVWAVELETANALYSIS3DINT 3 "QCCPACK" ""
.SH NAME
QccWAVWaveletAnalysis3DInt, QccWAVWaveletSynthesis3DInt \- 
integer-valued separable wavelet analysis/synthesis of a 3DInt signal
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccWAVWaveletAnalysis3DInt(QccVolumeInt " volume ", int " num_frames ", int " num_rows ", int " num_cols ", int " phase_frame ", int " phase_row ", int " phase_col ", const QccWAVWavelet *" wavelet );
.sp
.BI "int QccWAVWaveletSynthesis3DInt(QccVolumeInt " volume ", int " num_frames ", int " num_rows ", int " num_cols ", int " phase_frame ", int " phase_row ", int " phase_col ", const QccWAVWavelet *" wavelet );
.SH DESCRIPTION
.B QccWAVWaveletAnalysis3DInt()
performs one level of an integer-valued separable 3D wavelet decomposition for
a three-dimensional signal,
.IR volume ,
which is represented as a volume of
.IR num_frames
frames,
.I num_rows
rows, and
.I num_cols
columns.
Essentially,
.BR QccWAVWaveletAnalysis3DInt()
calls
.BR QccWAVWaveletAnalysis2DInt (3)
once for each frame of the volume, and then
.BR QccWAVWaveletAnalysis1DInt (3)
for each vector in the temporal direction.
.IR phase_frame ,
.IR phase_row ,
and
.I phase_col
indicate whether the frames, rows, and columns, respectively, of the image
start with even- or odd-indexed samples.
Usually, one assumes that the upper corner of the image cube is
indexed as (0, 0, 0) - in this case, 
.IR phase_frame ,
.IR phase_row ,
and
.I phase_col
would all be
.BR QCCWAVWAVELET_PHASE_EVEN .
In any event,
.IR phase_frame ,
.IR phase_row ,
and
.IR phase_col
are passed 
with each call to 
.BR QccWAVWaveletAnalysis2DInt (3)
and
.BR QccWAVWaveletAnalysis1DInt (3)
as appropriate.
The result of the separable decomposition is returned in
.IR volume .
.I wavelet
must indicate an integer-valued lifting scheme (see
.BR QccWAVLiftingSchemeInteger (3)).
.LP
.B QccWAVWaveletSynthesis3DInt()
performs one level of separable wavelet synthesis
for a 3DInt signal.
Subbands in 
.I volume
are assumed to be organized as described above for the output of
.BR QccWAVWaveletAnalysis3DInt() .
.B QccWAVWaveletSynthesis3DInt()
calls
.BR QccWAVWaveletSynthesis1DInt (3)
once for each vector in the temporal direction, then
.BR QccWAVWaveletSynthesis2DInt (3)
for each frame.
The result of the separable wavelet synthesis is returned in
.IR volume .
.LP
Note:
In general, you will probably want to use
.BR QccWAVWaveletDyadicDWT3DInt (3)
and
.BR QccWAVWaveletInverseDyadicDWT3DInt (3),
or
.BR QccWAVWaveletPacketDWT3DInt (3)
and
.BR QccWAVWaveletInversePacketDWT3DInt (3),
for implementing a discrete wavelet transform and its inverse since
these routines
allow any number of scales, or levels, of decomposition to be
performed.
.SH "INTEGER-TO-INTEGER WAVELET TRANSFORMS"
Transforms generally provide perfect reconstruction in that the
inverse transform will perfectly invert transform coefficients
into an exact representation of the original signal.
However, when implemented in floating-point arithmetic, the potential
for loss arises due to the limits of finite precision in both the
forward and inverse transforms.
On the other hand,
transforms that map integer-valued signals into integer-valued
transforms coefficients can guarantee perfect reconstruction, provided
an inverse transform can be found.
For this reason, lifting schemes, in which inverse transforms are
trivial, are favored for the
implementation of integer-valued wavelet transforms. Typically,
the general approach proposed by Calderbank
.IR "et al" .
is followed wherein rounding of floating-point values to integers is performed
at each prediction and update step in a lifting scheme.
Integer versions of several popular biorthogonal wavelets were
created in this manner by Calderbank
.IR "et al" .,
as well as by Xiong
.IR "et al" .
.LP
In traditional floating-point lifting, the prediction and update steps
are generally followed by a single application of scaling by a constant
in order to produce the usual unitary normalization.
This scaling step is somewhat problematic for integer-valued lifting
since the scaling constant is usually not an integer.
In applications wherein unitary scaling is not required
(e.g., in some applications that process each subband completely
independently), the scaling step is simply dropped in order
to implement an integer-valued version of the transform.
Alternatively, one can append three additional lifting steps to 
implement the scaling; these additional lifting steps can then be rendered
integer-valued via appropriate rounding (e.g., Xiong
.IR "et al" .)
making the transforms approximately normalized.
This latter approach of scaling via additional lifting steps
is employed in the integer-valued
lifting schemes implemented in QccPack.
.SH "RETURN VALUES"
These routines
return 0 on success and 1 on error.
.SH "SEE ALSO"
.BR QccWAVWaveletAnalysis1DInt (3),
.BR QccWAVWaveletSynthesis1DInt (3),
.BR QccWAVWaveletAnalysis2DInt (3),
.BR QccWAVWaveletSynthesis2DInt (3),
.BR QccWAVWaveletDyadicDWT3DInt (3),
.BR QccWAVWaveletInverseDyadicDWT3DInt (3),
.BR QccWAVWaveletPacketDWT3DInt (3),
.BR QccWAVWaveletInversePacketDWT3DInt (3),
.BR QccWAVWavelet (3),
.BR QccPackWAV (3),
.BR QccPack (3)
.LP
.LP
A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless
Image Compression Using Integer to Integer Wavelet Transforms", in
.IR "Proceedings of the International Conference on Image Processing" ,
Lausanne, Switzerland, pp. 596-599, September 1997.

Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless Compression of
Medical Volumetric Data Using Three-Dimensional Integer Wavelet Transforms,"
.IR "IEEE Transactions on Medical Imaging" ,
vol. 22, pp. 459-470, March 2003.

I. Daubechies and W. Sweldens,
"Factoring Wavelet Transforms Into Lifting Steps,"
.IR "J. Fourier Anal. Appl." ,
vol. 4, no. 3, pp. 245-267, 1998.

B.-J. Kim, Z. Xiong, and W. A. Pearlman,
"Low Bit-Rate Scalable Video Coding with 3-D Set Partitioning
in Hierarchical Trees (3-D SPIHT),"
.IR "IEEE Transactions on Circuits and Systems for Video Technology" ,
vol. 10, no. 8, pp. 1374-1387, December 2000.
.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



