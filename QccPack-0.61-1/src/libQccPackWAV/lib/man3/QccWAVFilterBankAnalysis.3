.TH QCCWAVFILTERBANKANALYSIS 3 "QCCPACK" ""
.SH NAME
QccWAVFilterBankAnalysis, QccWAVFilterBankSynthesis \- 
perform analysis/synthesis of a signal using a filter bank
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccWAVFilterBankAnalysis(QccVector " signal ", int " signal_length ", int " phase ", const QccWAVFilterBank *" filter_bank ", int " boundary_extension );
.br
.BI "int QccWAVFilterBankSynthesis(QccVector " signal ", int " signal_length ", int " phase ", const QccWAVFilterBank *" filter_bank ", int " boundary_extension );
.SH DESCRIPTION
.B QccWAVFilterBankAnalysis()
essentially performs one level of a wavelet decomposition.
Specifically,
.BR QccFilterMultiRateFilterVector (3)
is called twice, once to produce a lowpass subband of
.IR signal ,
and once to produce a highpass subband.
That is,
.I signal
is filtered using the lowpass analysis filter of
.IR filter_bank .
The filter output is subsampled by a factor of two, and stored as the
first half of
.IR signal .
Then, the process is repeated using the highpass analysis filter of
.I filter_bank
with the output stored as the last half of
.IR signal .
.LP
.IR signal_length ,
the length of
.IR signal ,
may be even or odd.
.IR phase
is either
.BR QCCWAVFILTERBANK_PHASE_EVEN
or
.BR QCCWAVFILTERBANK_PHASE_ODD
and
indicates whether the first sample of
.IR signal
has an even or odd index, respectively. Usually one assumes that
.I signal
starts with index 0, which is even, so
.I phase
should be specified to be
.BR QCCWAVFILTERBANK_PHASE_EVEN
in this typical case.
If
.IR signal_length
is odd, then one of the two subbands is one sample longer than the other.
Specifically, if
.IR signal_length
is odd, and
.IR phase
is 
.BR QCCWAVFILTERBANK_PHASE_EVEN ,
then the lowpass subband is one sample longer than the highpass
subband. If
.IR phase
is
.BR QCCWAVFILTERBANK_PHASE_ODD ,
the the highpass subband is one sample longer than the lowpass
subband. In the case that
.IR signal_length
is even, then both subbands have the same length regardless of the value of
.IR phase .
.LP
.B QccWAVFilterBankSynthesis()
performs one level of wavelet synthesis.  The first half of
.I signal
is assumed to contain the lowpass subband while the second half contains
the highpass subband.  These are upsampled by a factor of two and then
filtered with the lowpass and highpass synthesis filters, respectively,
of
.IR filter_bank .
The resulting signals of these two filtering operations are added to together
to produce the output signal which is returned in
.IR signal .
As with
.BR QccWAVFilterBankAnalysis() ,
.I signal_length
must be even.
.BR QccWAVFilterBankSynthesis() .
The upsampling and filter operations are performed via calls to
.BR QccFilterMultiRateFilterVector (3).
.LP
.IR boundary_extension 
can be one of the following:
.B QCCWAVWAVELET_BOUNDARY_SYMMETRIC_EXTENSION
(symmetric extension, valid only for biorthogonal filter banks), or
.B QCCWAVWAVELET_BOUNDARY_PERIODIC_EXTENSION
(periodic extension, valid for orthogonal and biorthogonal filter banks).
Check the comments at the start of each
.B FBK
file for permitted values for
.I boundary_extension
for particular filter banks.
Note that, if periodic extension is used,
.IR signal_length
must be even (this is due to mathematical constraints).
.LP
The case in which
.IR signal_length
is equal to 1 is degenerate. A wavelet transform is technically not well
defined for this situation because it is not clear how to subsample
the signal. However, in practice, this degenerate case can be handled in
several ways with no problems. In QccPack, the length-one signal is
merely multiplied by sqrt(2) and placed in the lowpass subband (in which
case the highpass subband has zero length) for 
.IR phase
equal to
.BR QCCWAVFILTERBANK_PHASE_EVEN ,
or divided by sqrt(2) and placed in the highpass subband
(in which case the lowpass subband has zero length) for
.IR phase
equal to
.BR QCCWAVFILTERBANK_PHASE_ODD .
.LP
Note:
In general, you will probably want to use
.BR QccWAVWaveletDWT1D (3)
and
.BR QccWAVWaveletInverseDWT1D (3)
instead of these routines
for implementing a discrete wavelet transform and its inverse since
.BR QccWAVWaveletDWT1D (3)
and
.BR QccWAVWaveletInverseDWT1D (3)
allow any number of scales, or levels, of decomposition to be
performed, and can be used with either filter-bank or lifting implementations
of wavelets.
.SH "RETURN VALUES"
These routines
return 0 on success and 1 on error.
.SH "SEE ALSO"
.BR QccFilterMultiRateFilterVector (3),
.BR QccWAVFilterBank (3),
.BR QccWAVWavelet (3),
.BR QccWAVWaveletDWT1D (3),
.BR QccWAVWaveletInverseDWT1D (3),
.BR QccPackWAV (3),
.BR QccFilterRead (3),
.BR QccFilterWrite (3),
.BR QccFilter (3),
.BR QccPack (3)
.LP
M. Antonini, M. Barlaud, P. Mathieu, and I. Daubechies,
"Image Coding Using Wavelet Transform,"
.IR "IEEE Transactions on Image Processing" ,
vol. 1, pp. 205-220, April 1992.
.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



