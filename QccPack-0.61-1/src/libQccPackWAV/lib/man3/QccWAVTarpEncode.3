.TH QCCTARPENCODE 3 "QCCPACK" ""
.SH NAME
QccWAVTarpEncode, QccWAVTarpDecode \-
encode/decode an image using the tarp algorithm
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccWAVTarpEncode(const QccIMGImageComponent *" image ", const QccIMGImageComponent *" mask ", double " alpha ", int " num_levels ", int " target_bit_cnt ", const QccWAVWavelet *" wavelet ", QccBitBuffer *" output_buffer );
.br
.BI "int QccWAVTarpDecodeHeader(QccBitBuffer *" input_buffer ", double *" alpha ", int *" num_levels ", int *" num_rows ", int *" num_cols ", double *" image_mean ", int *" max_coefficient_bits );
.br
.BI "int QccWAVTarpDecode(QccBitBuffer *" input_buffer ", QccIMGImageComponent *" image ", const QccIMGImageComponent *" mask ", double " alpha ", int " num_levels ", const QccWAVWavelet *" wavelet ", double " image_mean ", int " max_coefficient_bits ", int " target_bit_cnt );
.SH DESCRIPTION
.SS Encoding
.LP
.B QccWAVTarpEncode()
encodes an image component,
.IR image ,
using the tarp algorithm by Simard
.IR "et al" .
The tarp algorithm involves a 2D DWT followed by 
a progressive "bitplane" coding of the wavelet coefficients using a
Parzen-window technique to estimate probability of significance and
nonadaptive arithmetic coding to code significance-map and
refinement information. See "ALGORITHM" below for more detail.
.LP
.I image
is the image component to be coded and
.I buffer
is the output bitstream.
.I buffer
must be of
.B QCCBITBUFFER_OUTPUT
type and opened via a prior call to
.BR QccBitBufferStart (3).
.LP
.I num_levels
gives the number of levels of dyadic wavelet decomposition to perform,
and
.I wavelet
is the wavelet to use for decomposition.
.LP
The tarp algorithm performance is determined primarily through
the parameter
.IR alpha ,
a value that gives the learning rate of the density-estimation
process implemented by the tarp filter.
Simard
.IR "et al" .
originally used a value of
.I alpha
= 0.6.
.LP
The bitstream output from the tarp encoder is embedded, meaning that
any prefix of the bitstream can be decoded to give a valid 
representation of the image.  The tarp encoder essentially produces
output bits until the number of bits output reaches
.IR target_bit_cnt ,
the desired (target) total length of the output bitstream in bits,
and then it stops.
Note that this is the bitstream length in bits, not the rate of the bitstream
(which would be expressed in bits per pixel).
.LP
.BR QccTarpEncode()
optionally supports the use of a shape-adaptive DWT (SA-DWT) rather than
the usual DWT. That is, 
.BR QccTarpEncode()
can call
.BR QccWAVSubbandPyramidShapeAdaptiveDWT (3)
as the wavelet transform rather than the usual
.BR QccWAVSubbandPyramidDWT (3).
The use of a SA-DWT is indicated by a
.RB non- NULL
.IR mask ;
if 
.I mask
is
.BR NULL ,
then the usual DWT is used.
In the case of a SA-DWT,
.I mask 
gives the transparency mask which indicates which pixels of the image
are non-transparent and thus have data that is to be transformed.
Refer to 
.BR QccWAVSubbandPyramidShapeAdaptiveDWT (3)
for more details on the calculation of this SA-DWT, and
see "ALGORITHM" below for how the shape-adaptive mask
is employed in the tarp algorithm.
.SS Decoding
.LP
.B QccWAVTarpDecodeHeader()
decodes the header information in the bitstream in the input
.I buffer
(which must be of
.B QCCBITBUFFER_INPUT
type and opened via a prior call to
.BR QccBitBufferStart (3)).
The header information is returned in
.I alpha
(the learning-rate parameter of the density-estimation process),
.I num_levels
(number of levels of wavelet decomposition),
.I num_rows
(vertical size of image),
.I num_cols
(horizontal size of image),
.I image_mean
(the mean value of the original image), and
.I max_coefficient_bits
(the number of bits used to represent the magnitude of the coefficient with largest absolute value).
.LP
.B QccWAVTarpDecode()
decodes the bitstream
.IR buffer ,
producing the reconstructed image component,
.IR image .
The bitstream must already have had its header read by a prior call
to
.B QccWAVTarpDecodeHeader()
(i.e., you call
.B QccWAVTarpDecodeHeader() 
first and then
.BR QccWAVTarpDecode() ).
If
.I target_bit_cnt
is
.BR QCCENT_ANYNUMBITS ,
then decoding stops when the end of the input bitstream is reached;
otherwise, decoding stops when
.I target_num_bits
from the input bitstream have been decoded.
.LP
If a SA-DWT was used in tarp encoding, then the original transparency
mask should be passed to 
.BR QccWAVTarpDecode()
as
.IR mask .
That is,
.I mask
should be the same transparency mask (in the spatial domain)
that was passed to
.BR QccWAVTarpEncode() .
Note that
.BR QccWAVTarpDecode()
will transform this
.I mask
via a Lazy wavelet transform, and then pass the transformed mask
to 
.BR QccWAVSubbandPyramidInverseShapeAdaptiveDWT (3).
If the usual DWT was used in encoding, then
.I mask
should be a
.B NULL
pointer.
.SH "ALGORITHM"
There are several variants of the tarp algorithm for image coding.
The coder originally described by Simard
.IR "et al" .
applied a scalar quantizer to the coefficients of a 2D DWT and
then used the tarp-filter procedure described below to
independently
code each of the bitplanes of the coefficients. The quantizer stepsize
was adjusted to optimze performance for a specified target rate.
Although this approach results in a progressive coding of the image,
strictly speaking, the bitstream is not embedded.
On the other hand,
the QccPack implementation of tarp coding is an embedded
coder based on the significance-refinement approach
to bitplane coding common to wavelet-based embedded coders.
We note that this embedded approach was suggested as an
alternative implementation by Simard
.IR "et al" .
in their original paper, but results given there focused on the 
quantizer-based non-embedded approach just described.
.LP
The embedded tarp coder as
implemented in QccPack
involves a 2D DWT followed by a progressive encoding
of the bitplanes of wavelet coefficients.
As is common with bitplane-based embedded coders,
the encoder of the tarp algorithm
codes significance information in a significance pass
followed by refinement-bit information in a refinement pass.
The significance pass determines the significance of a wavelet coefficient
against a given threshold, while the refinement pass codes the bits of
those coefficients previously determined to be significant.
.LP
The unique aspect of the tarp algorithm is in the significance
pass. The tarp algorithm employs a density-estimation process
based upon Parzen windows to determine the probability that each
currently insignificant coefficient becomes significant in the current
significance pass. This probability is passed to a two-symbol,
nonadaptive arithmetic
coder to code the actual significance value of the current coefficient.
The
.I alpha
parameter to the algorithm determines the shape of the Parzen windows
employed, effectively determining the learning rate of the
density-estimation process. The actual density estimation is
implemented as an efficient set of filtering operations that create
a causal 2D filter that looks like a canvas propped up by a pole
at the current coefficient, hence the name "tarp" filter.
That's it - no runlength coding, no zerotrees - just a simple
density estimation.
.LP
The refinement pass codes refinement bits using the same
nonadaptive arithmetic coder used in the significance pass except that
the refinement bits are assumed equally likely, and thus a uniform
density is used by the nonadaptive arithmetic coder.
.LP
There are several ways to handle the overlapping of the 2D causal tarp filter 
beyond the image boundaries.
Simard
.IR "et al" .
proposed boundary initial conditions that attempt to spread prior
knowledge accumulated during the filtering along the boundary.
In contrast, the implementation here takes the simpler route of
merely assuming all values beyond the image boundaries are insignificant.
It is unlikely that either approach differs much from the other
in terms of rate-distortion performance.
.LP
As proposed by Fowler,
to handle shape-adaptive coding (not originally considered by Simard
.IR "et al" .),
the implementation here merely skips over 
the transparent regions, maintaining the current
probability estimate unchanged.
.LP
Finally, we note that Tian and Hemami proposed a variant of tarp
coding somewhat similar to what is implemented here in that
they use the tarp filter to code significance information.
However, their approach is somewhat more sophisticated in that
fraction bitplanes are used in the significance pass to
achieve a higher degree of embeddedness.
.SH "PERFORMANCE"
The tarp algorithm offers rate-distortion performance
amazing close to the SPIHT algorithm (see
.BR QccSPIHTEncode (3)
in the optional QccPackSPIHT module).
The following table compares the tarp coder (alpha = 0.6) with the
SPIHT coder (arithmetic-coding version).
.RS
.nf
               Lenna
 ------------------------------------
 | Rate  |          PSNR (db)       |
 | (bpp) |    Tarp          SPIHT   |
 ------------------------------------
 |  0.2  |    32.83    |    32.94   |
 |  0.5  |    36.74    |    37.11   |
 |  1.0  |    39.85    |    40.28   |
 ------------------------------------
    Average difference = 0.22 dB


              Barbara
 ------------------------------------
 | Rate  |          PSNR (db)       |
 | (bpp) |     Tarp         SPIHT   |
 ------------------------------------
 |  0.2  |    26.48    |    26.48   |
 |  0.5  |    31.07    |    31.33   |
 |  1.0  |    35.90    |    36.43   |
 ------------------------------------
    Average difference = 0.11 dB


              Goldhill
 ------------------------------------
 | Rate  |          PSNR (db)       |
 | (bpp) |    Tarp          SPIHT   |
 ------------------------------------
 |  0.2  |    29.62    |    29.68   |
 |  0.5  |    32.97    |    32.96   |
 |  1.0  |    36.16    |    36.37   |
 ------------------------------------
    Average difference = 0.12 dB

.fi
.RE

.SH "NOTES"
The tarp-filer algorithm as described originally by Simard
.I "et al" .
does not employ shape-adaptive coding.
.SH "SEE ALSO"
.BR tarpencode (1),
.BR tarpdecode (1),
.BR imgdwt (1),
.BR imgdist (1),
.BR QccBitBuffer (3),
.BR QccENTArithmeticEncode (3),
.BR QccENTArithmeticDecode (3),
.BR QccWAVSubbandPyramid (3),
.BR QccPackWAV (3),
.BR QccPackIMG (3),
.BR QccPack (3)

P. Simard, D. Steinkraus, and H. Malvar, "On-Line Adaptation in Image Coding
with a 2-D Tarp Filter", in
.IR "Proceedings of the IEEE Data Compression Conference" ,
J. A. Storer and M. Cohn, Eds.,  
Snowbird, UT, April 2002, pp. 422-431.
.LP
J. E. Fowler, "Shape-Adaptive Tarp Coding," in
.IR "Proceedings of the International Conference on Image Processing" ,
Barcelona, Spain, September 2003, vol. 1, pp. 621-624.
.LP
C. Tian and S. S. Hemami, "An Embedded Image Coding System
Based on Tarp Filter with Classification," in
.IR "Proceedings of the International Conference on Acoustics, Speech, and Signal Processing" ,
Montreal, Canada, May 2004, to appear.

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them and/or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
