.TH QCCWAVTARP3DENCODE 1 "QCCPACK" ""
.SH NAME
QccWAVTarp3DEncode, QccWAVTarp3DDecode \-
encode/decode an image cube using the 3D tarp algorithm
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccWAVTarp3DEncode(const QccIMGImageCube *" image ", const QccIMGImageCube *" mask ", QccBitBuffer *" buffer ", int " transform_type ", int " temporal_num_levels ", int " spatial_num_levels ", double " alpha ", const QccWAVWavelet *" wavelet ", int " target_bit_cnt );
.sp
.BI "int QccWAVTarp3DDecodeHeader(QccBitBuffer *" buffer ", int *" transform_type ", int *" temporal_num_levels ", int *" spatial_num_levels ", int *" num_frames ", int *" num_rows ", int *" num_cols ", double *" image_mean ", int *" max_coefficient_bits ", double *" alpha );
.sp
.BI "int QccWAVTarp3DDecode(QccBitBuffer *" buffer ", QccIMGImageCube *" image ", const QccIMGImageCube *" mask ", int " transform_type ", int " temporal_num_levels ", int " spatial_num_levels ", double " alpha ", const QccWAVWavelet *" wavelet ", double " image_mean ", int " max_coefficient_bits ", int " target_bit_bit );
.SH DESCRIPTION
.SS Encoding
.LP
.B QccWAVTarp3DEncode()
encodes an image cube,
.IR image ,
using a 3D generalization of the tarp algorithm.
The original tarp algorithm was developed for 2D images by
Simard
.IR "et al" .;
it was latter extended to 3D by Wang
.IR "et al" .
In essence, the 3D tarp algorithm involves a 3D DWT followed by 
a progressive "bitplane" coding of the wavelet coefficients using a
Parzen-window technique to estimate probability of significance and
nonadaptive arithmetic coding to code significance-map and
refinement information. See "ALGORITHM" below for more detail.
.LP
.I image
is the image cube to be coded and
.I buffer
is the output bitstream.
.I buffer
must be of
.B QCCBITBUFFER_OUTPUT
type and opened via a prior call to
.BR QccBitBufferStart (3).
.LP
.BR QccWAVTarp3DEncode ()
supports the use of both wavelet-packet and dyadic wavelet-transform
decompositions.
If
.IR transform_type
is
.BR QCCWAVSUBBANDPYRAMID3D_DYADIC ,
a dyadic DWT is used; if
.IR transform_type
is
.BR QCCWAVSUBBANDPYRAMID3D_PACKET ,
a wavelet-packet DWT is used.
.IR temporal_num_levels 
and
.IR spatial_num_levels
give the number of levels of wavelet decomposition to perform
for both transform types; for a dyadic transform,
.IR temporal_num_levels 
should equal
.IR spatial_num_levels .
.I wavelet
is the wavelet to use for decomposition.
.LP
The 3D tarp algorithm performance is determined primarily through
the parameter
.IR alpha ,
a value that gives the learning rate of the density-estimation
process implemented by the tarp filter.
Wang
.IR "et al" .
used a value of
.I alpha
= 0.3.
.LP
The bitstream output from the 3D tarp encoder is embedded, meaning that
any prefix of the bitstream can be decoded to give a valid 
representation of the image.  The 3D tarp encoder essentially produces
output bits until the number of bits output reaches
.IR target_bit_cnt ,
the desired (target) total length of the output bitstream in bits,
and then it stops.
Note that this is the bitstream length in bits, not the rate of the bitstream
(which would be expressed in bits per voxel).
.LP
.BR QccWAVTarp3DEncode()
optionally supports the use of a shape-adaptive DWT (SA-DWT) rather than
the usual DWT. That is, 
.BR QccWAVTarp3DEncode()
can call
.BR QccWAVSubbandPyramid3DShapeAdaptiveDWT (3)
as the wavelet transform rather than the usual
.BR QccWAVSubbandPyramid3DDWT (3).
The use of a SA-DWT is indicated by a non-NULL
.IR mask ;
if 
.I mask
is NULL, then the usual DWT is used.
In the case of a SA-DWT,
.I mask 
gives the transparency mask which indicates which voxels of the image
are non-transparent and thus have data that is to be transformed.
Refer to 
.BR QccWAVSubbandPyramid3DShapeAdaptiveDWT (3)
for more details on the calculation of this SA-DWT.
See "ALGORITHM" below for details on how the 3D tarp
algorithm handles shape-adaptive coding.
.SS Decoding
.LP
.B QccWAVTarp3DDecodeHeader()
decodes the header information 
in a bitstream previously produced by
.BR QccWAVTarp3DEncode() .
The input bitstream is
.I buffer
which must be of
.B QCCBITBUFFER_INPUT
type and opened via a prior call to
.BR QccBitBufferStart (3).
.LP
The header information is returned in
.I transform_type
(either
.BR QCCWAVSUBBANDPYRAMID3D_DYADIC 
or
.BR QCCWAVSUBBANDPYRAMID3D_PACKET 
to indicate a dyadic or wavelet-packet transform decomposition, respectively),
.I temporal_num_levels
(number of levels of wavelet decomposition in the temporal direction),
.I spatial_num_levels
(number of levels of wavelet decomposition in the spatial directions),
.I num_frames
(size of the image cube in the temporal direction),
.I num_rows
(vertical size of image cube),
.I num_cols
(horizontal size of image cube),
.I image_mean
(the mean value of the original image cube),
.I max_coefficient_bits
(indicates the precision, in number of bits, of the wavelet coefficient
with the largest magnitude),
and
.I alpha
(the value of the learning rate).
.LP
.B QccWAVTarp3DDecode()
decodes the bitstream
.IR buffer ,
producing the reconstructed image cube,
.IR image .
The bitstream must already have had its header read by a prior call
to
.B QccWAVTarp3DDecodeHeader()
(i.e., you call
.B QccWAVTarp3DDecodeHeader() 
first and then
.BR QccWAVTarp3DDecode() ).
If
.I target_bit_cnt
is
.BR QCCENT_ANYNUMBITS ,
then decoding stops when the end of the input bitstream is reached;
otherwise, decoding stops when
.I target_num_bits
from the input bitstream have been decoded.
.LP
If a SA-DWT was used in 3D tarp encoding, then the original transparency
mask should be passed to 
.BR QccWAVTarp3DDecode()
as
.IR mask .
That is,
.I mask
should be the same transparency mask (untransformed) 
that was passed to
.BR QccWAVTarp3DEncode() .
Note that
.BR QccWAVTarp3DDecode()
will transform this
.I mask
via a Lazy wavelet transform, and then pass the transformed mask
to 
.BR QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT (3).
If the usual, full-volume DWT was used in encoding, then
.I mask
should be a NULL pointer.
.SH "ALGORITHM"
There are several variants of the tarp algorithm.
The progressive (but not embedded) coder originally described by Simard
.IR "et al" .
for 2D images
applied a scalar quantizer to the coefficients of a 2D DWT and
then used the tarp-filter procedure described below to
independently
code each of the bitplanes of the coefficients.
On the other hand,
the QccPack implementation of 2D tarp coding is an embedded
coder based on the significance-refinement approach
to bitplane coding common to wavelet-based embedded coders.
(see
.BR QccWAVTarpEncode (3)).
.LP
The 3D tarp algorithm implemented here is
that described by Wang
.IR "et al" .
This 3D tarp coder
follows the same significance-refinement approach to embedded coding as
employed in the 2D QccPack tarp coder
.BR QccWAVTarpEncode (3)
and
involves a 3D DWT followed by a progressive encoding
of the bitplanes of wavelet coefficients.
As is common with bitplane-based embedded coders,
the encoder of the tarp algorithm
codes significance information in a significance pass
followed by refinement-bit information in a refinement pass.
The significance pass determines the significance of a wavelet coefficient
against a given threshold, while the refinement pass codes the bits of
those coefficients previously determined to be significant.
.LP
The unique aspect of the 3D tarp algorithm is in the significance
pass. The 3D tarp algorithm employs a density-estimation process
based upon Parzen windows to determine the probability that each
currently insignificant coefficient becomes significant in the current
significance pass. This probability is passed to a two-symbol,
nonadaptive arithmetic
coder to code the actual significance value of the current coefficient.
The
.I alpha
parameter to the algorithm determines the shape of the Parzen windows
employed, effectively determining the learning rate of the
density-estimation process.
The actual density estimation is
implemented as an efficient set of filtering operations that create
a causal 3D filter.
.LP
The refinement pass codes refinement bits using the same
nonadaptive arithmetic coder used in the significance pass except that
the refinement bits are assumed equally likely, and thus a uniform
density is used by the nonadaptive arithmetic coder.
.LP
As proposed by Fowler,
to handle shape-adaptive coding (not originally considered by Simard
.IR "et al" .
for the initial 2D algorithm, or by Wang
.IR "et al" .
for the subsequent 3D algorithm),
the implementation here merely skips over 
the transparent regions, maintaining the current
probability estimate unchanged.
.SH "SEE ALSO"
.BR tarpencode3d (1),
.BR tarpdecode3d (1),
.BR QccBitBuffer (3),
.BR QccWAVSubbandPyramid3D (3),
.BR QccWAVSubbandPyramid3DDWT (3),
.BR QccWAVSubbandPyramid3DShapeAdaptiveDWT (3),
.BR QccWAVTarpEncode (3),
.BR QccPackWAV (3),
.BR QccPackIMG (3),
.BR QccPack (3)

Y. Wang, J. T. Rucker, and J. E. Fowler, "Embedded Wavelet-Based Compression
of Hyperspectral Imagery Using Tarp Coding," in
.IR "Proceedings of the International Geoscience and Remote Sensing Symposium" ,
Toulouse, France, July 2003, vol. 3, pp. 2027-2029.
.LP
P. Simard, D. Steinkraus, and H. Malvar, "On-Line Adaptation in Image Coding
with a 2-D Tarp Filter", in
.IR "Proceedings of the IEEE Data Compression Conference" ,
J. A. Storer and M. Cohn, Eds.,  
Snowbird, UT, April 2002, pp. 422-431.
.LP
J. E. Fowler, "Shape-Adaptive Tarp Coding," in
.IR "Proceedings of the International Conference on Image Processing" ,
Barcelona, Spain, September 2003, vol. 1, pp. 621-624.

.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them and/or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
