.TH QCCWAVWAVELETDWT2DINT 3 "QCCPACK" ""
.SH NAME
QccWAVWaveletDWT2DInt, QccWAVWaveletInverseDWT2DInt \- 
integer-valued separable 2D discrete wavelet transform and inverse transform for a 2D signal
.SH SYNOPSIS
.B #include "libQccPack.h"
.sp
.BI "int QccWAVWaveletDWT2DInt(QccMatrixInt " matrix ", int " num_rows ", int " num_cols ", int " origin_row ", int " origin_col ", int " subsample_pattern_row ", int " subsample_pattern_col ", int " num_scales ", const QccWAVWavelet *" wavelet );
.br
.BI "int QccWAVWaveletInverseDWT2DInt(QccMatrixInt " matrix ", int " num_rows ", int " num_cols ", int " origin_row ", int " origin_col ", int " subsample_pattern_row ", int " subsample_pattern_col ", int " num_scales ", const QccWAVWavelet *" wavelet );
.SH DESCRIPTION
.B QccWAVWaveletDWT2DInt()
performs an integer-valued separable 2D
discrete wavelet transform (DWT) of a two-dimensional signal,
.IR matrix ,
which is represented as a matrix of
.I num_rows
rows and
.I num_cols
columns.
.I origin_row
and
.I origin_col
indicates the row and column indices, respectively, of the upper-left
corner of the image.
Usually, one assumes that the upper-left corner of the image is
indexed as (0, 0) - in this case, both
.I origin_row
and
.I origin_col
would be zero.
.I num_scales
gives the number of scales, or levels, of the decomposition.
.BR QccWAVWaveletDWT2DInt()
implements a dyadic, or octave, decomposition of
.IR matrix ;
that is, the low-low subband (baseband)
is recursively decomposed into a lowpass and
three highpass bands for each level of decomposition, each of which being
one quarter the size of the baseband that was decomposed.
The output of the DWT is returned in
.IR matrix ,
overwriting the original input matrix.
The output subbands reside in 
.I matrix
with the baseband in the upper-left corner, with highpass subbands
successively "nested" from the upper-left corner to lower-right corner.
.BR QccWAVWaveletDWT2DInt()
calls
.BR QccWAVWaveletAnalysis2DInt (3)
for each level of decomposition, using the baseband
subband for the current level of decomposition as input.
As a result, the transform recursively decomposes the upper-left corner of
the input matrix.
.I wavelet
must indicate an integer-valued lifting scheme (see
.BR QccWAVLiftingSchemeInteger (3)).
.LP
.B QccWAVWaveletInverseDWT2DInt()
performs the corresponding separable 2DInt inverse DWT of
.IR matrix
which is assumed to have been produced
by
.BR QccWAVWaveletDWT2DInt() .
.I num_scales
gives the number of levels of decomposition that exist in
.IR matrix .
.B QccWAVWaveletInverseDWT2DInt()
calls
.BR QccWAVWaveletSynthesis2DInt (3)
for each level of synthesis.
.LP
.I subsample_pattern_row
and
.I subsample_pattern_col
indicate the even- or odd-phase subsampling to be used at each level
of row and column decomposition.
In most applications, even subsampling at all
levels is desired, in which case both 
.I subsample_pattern_row
and
.I subsample_pattern_col
should be set to zero.
In more general settings, when some mixture of even- and odd-phase subsampling
is desired, 
.I subsample_pattern_row
and
.I subsample_pattern_col
can be integers between 0 and
.IR "(2 ^ num_levels) - 1" .
In these integers, the 
.IR j th
bit (where
.I j
= 1 is the least-significant bit) indicates whether the
.IR j th
level of decomposition employs
even or odd subsampling (0 = even, 1 = odd).
For example, if
.I subsample_pattern_row
is 5, then the first and third row decompositions use odd-phase
subsampling, while all others use even subsampling.
.LP
Use
.BR QccWAVSubbandPyramidIntDWT (3)
and
.BR QccWAVSubbandPyramidIntInverseDWT (3)
to perform a 2D separable DWT or inverse DWT on a
.B QccWAVSubbandPyramidInt
data structure (which is the recommended way to do it, since the
.B QccWAVSubbandPyramidInt
structure stores the number of levels of decomposition along with
the transform coefficients).
.SH "INTEGER-TO-INTEGER WAVELET TRANSFORMS"
Transforms generally provide perfect reconstruction in that the
inverse transform will perfectly invert transform coefficients
into an exact representation of the original signal.
However, when implemented in floating-point arithmetic, the potential
for loss arises due to the limits of finite precision in both the
forward and inverse transforms.
On the other hand,
transforms that map integer-valued signals into integer-valued
transforms coefficients can guarantee perfect reconstruction, provided
an inverse transform can be found.
For this reason, lifting schemes, in which inverse transforms are
trivial, are favored for the
implementation of integer-valued wavelet transforms. Typically,
the general approach proposed by Calderbank
.IR "et al" .
is followed wherein rounding of floating-point values to integers is performed
at each prediction and update step in a lifting scheme.
Integer versions of several popular biorthogonal wavelets were
created in this manner by Calderbank
.IR "et al" .,
as well as by Xiong
.IR "et al" .
.LP
In traditional floating-point lifting, the prediction and update steps
are generally followed by a single application of scaling by a constant
in order to produce the usual unitary normalization.
This scaling step is somewhat problematic for integer-valued lifting
since the scaling constant is usually not an integer.
In applications wherein unitary scaling is not required
(e.g., in some applications that process each subband completely
independently), the scaling step is simply dropped in order
to implement an integer-valued version of the transform.
Alternatively, one can append three additional lifting steps to 
implement the scaling; these additional lifting steps can then be rendered
integer-valued via appropriate rounding (e.g., Xiong
.IR "et al" .)
making the transforms approximately normalized.
This latter approach of scaling via additional lifting steps
is employed in the integer-valued
lifting schemes implemented in QccPack.
.SH "RETURN VALUES"
These routines
return 0 on success and 1 on error.
.SH "SEE ALSO"
.BR QccWAVWaveletAnalysis2DInt (3),
.BR QccWAVWaveletSynthesis2DInt (3),
.BR QccWAVSubbandPyramidIntDWT (3),
.BR QccWAVSubbandPyramidIntInverseDWT (3),
.BR QccWAVWavelet (3),
.BR QccPackWAV (3),
.BR QccPack (3)
.LP
A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless
Image Compression Using Integer to Integer Wavelet Transforms", in
.IR "Proceedings of the International Conference on Image Processing" ,
Lausanne, Switzerland, pp. 596-599, September 1997.

Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless Compression of
Medical Volumetric Data Using Three-Dimensional Integer Wavelet Transforms,"
.IR "IEEE Transactions on Medical Imaging" ,
vol. 22, pp. 459-470, March 2003.

I. Daubechies and W. Sweldens,
"Factoring Wavelet Transforms Into Lifting Steps,"
.IR "J. Fourier Anal. Appl." ,
vol. 4, no. 3, pp. 245-267, 1998.
.SH AUTHOR
Copyright (C) 1997-2016  James E. Fowler
.\"  The programs herein are free software; you can redistribute them an.or
.\"  modify them under the terms of the GNU General Public License
.\"  as published by the Free Software Foundation; either version 2
.\"  of the License, or (at your option) any later version.
.\"  
.\"  These programs are distributed in the hope that they will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"  
.\"  You should have received a copy of the GNU General Public License
.\"  along with these programs; if not, write to the Free Software
.\"  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



