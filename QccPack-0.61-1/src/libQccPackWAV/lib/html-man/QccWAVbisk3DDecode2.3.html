<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVbisk3DDecode2.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVbisk3DEncode, QccWAVbisk3DDecode - encode/decode an image cube 
using the 3D-BISK algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVbisk3DEncode(const 
QccIMGImageCube *</B><I>image_cube</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
QccBitBuffer *</B><I>output_buffer</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  <P>
<B>int QccWAVbisk3DEncode2(QccWAVSubbandPyramid3D 
*</B><I>image_subband_pyramid</I><B>, QccWAVSubbandPyramid3D *</B><I>mask_subband_pyramid</I><B>, 
double </B><I>image_mean</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  
<P>
<B>int QccWAVbisk3DDecodeHeader(QccBitBuffer *</B><I>input_buffer</I><B>, int *</B><I>transform_type</I><B>, 
int *</B><I>temporal_num_levels</I><B>, int *</B><I>spatial_num_levels</I><B>, int *</B><I>num_frames</I><B>, int 
*</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int *</B><I>max_coefficient_bits</I><B>);</B> 
 <P>
<B>int QccWAVbisk3DDecode(QccBitBuffer *</B><I>input_buffer</I><B>, QccIMGImageCube *</B><I>image_cube</I><B>, 
const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, int </B><I>temporal_num_levels</I><B>, 
int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, double </B><I>image_mean</I><B>, 
int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_bit</I><B>);</B>  <P>
<B>int QccWAVbisk3DDecode2(QccBitBuffer 
*</B><I>input_buffer</I><B>, QccWAVSubbandPyramid3D *</B><I>image_subband_pyramid</I><B>, QccWAVSubbandPyramid3D 
*</B><I>mask_subband_pyramid</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B> 
 
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVbisk3DEncode()</B> encodes an image cube, <I>image_cube</I>, 
using a 3D generalization of the BISK algorithm. The original BISK algorithm 
was developed for 2D images by Fowler; it was latter extended to 3D by 
Rucker and Fowler. In essence, the 3D-BISK algorithm involves a 3D DWT followed 
by  a progressive "bitplane" coding of the wavelet coefficients using 
a cube-splitting quantization structure based on <I>k</I>-d trees. See "ALGORITHM" 
below for more detail. <P>
<I>image_cube</I> is the image cube to be coded and <I>output_buffer</I> 
is the output bitstream. <I>output_buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> type 
and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccWAVbisk3DEncode</B>() 
supports the use of both wavelet-packet and dyadic wavelet-transform decompositions. 
If <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B>, a dyadic DWT is used; 
if <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B>, a wavelet-packet DWT 
is used. <I>temporal_num_levels</I> and <I>spatial_num_levels</I> give the number of 
levels of wavelet decomposition to perform for both transform types; for 
a dyadic transform, <I>temporal_num_levels</I> should equal <I>spatial_num_levels</I>. 
<I>wavelet</I> is the wavelet to use for decomposition. <P>
The bitstream output from 
the 3D-BISK encoder is embedded, meaning that any prefix of the bitstream 
can be decoded to give a valid  representation of the image.  The 3D-BISK 
encoder essentially produces output bits until the number of bits output 
reaches <I>target_bit_cnt</I>, the desired (target) total length of the output 
bitstream in bits, and then it stops. Note that this is the bitstream length 
in bits, not the rate of the bitstream (which would be expressed in bits 
per voxel). <P>
<B>QccWAVbisk3DEncode()</B> optionally supports the use of a shape-adaptive 
DWT (SA-DWT) rather than the usual DWT. That is,  <B>QccWAVbisk3DEncode()</B> can 
call <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 as the wavelet transform 
rather than the usual <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
. The use of a SA-DWT 
is indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then the usual DWT is 
used. In the case of a SA-DWT, <I>mask</I>  gives the transparency mask which indicates 
which voxels of the image are non-transparent and thus have data that is 
to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
for more details on the calculation of this SA-DWT. See "ALGORITHM" below 
for details on how the 3D-BISK algorithm handles shape-adaptive coding. <P>
The 
routine <B>QccWAVbisk3DEncode2()</B> provides an alternative interface to 3D-BISK 
encoding. Specifically, <B>QccWAVbisk3DEncode2()</B> functions indentically to 
<B>QccWAVbisk3DEncode()</B> described above, except that both the image cube 
and optional mask are assumed to have had a 3D DWT applied to them prior 
to calling <B>QccWAVbisk3DEncode2()</B>. As a consequence, the image cube and 
mask are passed to <B>QccWAVbisk3DEncode2()</B> in the wavelet domain as <I>image_subband_pyramid</I> 
and <I>mask_subband_pyramid</I>. We note that most applications should opt for 
<B>QccWAVbisk3DEncode()</B> rather than <B>QccWAVbisk3DEncode2()</B>; however, <B>QccWAVbisk3DEncode()</B> 
is implemented essentially as a call to an appropriate 3D DWT followed 
by a call to <B>QccWAVbisk3DEncode2()</B>. If  <B>QccWAVbisk3DEncode2()</B> is used, 
it is the responsibility of the calling routine to perform the appropriate 
3D DWT prior to calling <B>QccWAVbisk3DEncode2()</B>.  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVbisk3DDecodeHeader()</B> 
decodes the header information  in a bitstream previously produced by 
<B>QccWAVbisk3DEncode()</B>. The input bitstream is <I>input_buffer</I> which must be 
of <B>QCCBITBUFFER_INPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. 
<P>
The header information is returned in <I>transform_type</I> (either <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B> 
or <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B> to indicate a dyadic or wavelet-packet 
transform decomposition, respectively), <I>temporal_num_levels</I> (number of 
levels of wavelet decomposition in the temporal direction), <I>spatial_num_levels</I> 
(number of levels of wavelet decomposition in the spatial directions), 
<I>num_frames</I> (size of the image cube in the temporal direction), <I>num_rows</I> 
(vertical size of image cube), <I>num_cols</I> (horizontal size of image cube), 
<I>image_mean</I> (the mean value of the original image cube), and <I>max_coefficient_bits</I> 
(indicates the precision, in number of bits, of the wavelet coefficient 
with the largest magnitude). <P>
<B>QccWAVbisk3DDecode()</B> decodes the bitstream 
<I>input_buffer</I>, producing the reconstructed image cube, <I>image_cube</I>. The bitstream 
must already have had its header read by a prior call to <B>QccWAVbisk3DDecodeHeader()</B> 
(i.e., you call <B>QccWAVbisk3DDecodeHeader() </B> first and then <B>QccWAVbisk3DDecode()</B>). 
If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, then decoding stops when the end 
of the input bitstream is reached; otherwise, decoding stops when <I>target_num_bits</I> 
from the input bitstream have been decoded. <P>
If a SA-DWT was used in 3D-BISK 
encoding, then the original transparency mask should be passed to  <B>QccWAVbisk3DDecode()</B> 
as <I>mask</I>. That is, <I>mask</I> should be the same transparency mask (untransformed) 
 that was passed to <B>QccWAVbisk3DEncode()</B>. Note that <B>QccWAVbisk3DDecode()</B> 
will transform this <I>mask</I> via a Lazy wavelet transform, and then pass the 
transformed mask to  <B><A HREF="QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT</B>(3)</A>
. 
If the usual, full-volume DWT was used in encoding, then <I>mask</I> should be 
a NULL pointer. <P>
<B>QccWAVbisk3DDecode2()</B> provides the appropriate alternative 
interface to 3D-BISK decoding required if encoding was done via <B>QccWAVbisk3DEncode2()</B>. 
Essentially,  <B>QccWAVbisk3DDecode()</B> is implemented by a call to <B>QccWAVbisk3DDecode2()</B> 
followed by an appropriate inverse 3D DWT. If <B>QccWAVbisk3DDecode2()</B> is 
used, it is the responsibility of the calling to routine to perform the 
appropriate inverse 3D DWT subsequent to the call to <B>QccWAVbisk3DDecode2()</B>. 
As noted above, most applications should use <B>QccWAVbisk3DDecode()</B> rather 
than <B>QccWAVbisk3DDecode2()</B>.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
The 3D-BISK algorithm involves a 
3D DWT followed by a progressive encoding of the bitplanes of wavelet 
coefficients. As is common with bitplane-based embedded coders, the encoder 
of the 3D-BISK algorithm codes significance information in a significance 
pass followed by refinement-bit information in a refinement pass. The significance 
pass determines the significance of a wavelet coefficient against a given 
threshold, while the refinement pass codes the bits of those coefficients 
previously determined to be significant. <P>
The unique aspect of the 3D-BISK 
algorithm is in the significance pass. In many ways, the 3D-BISK algorithm 
can be considered to be a variant of 3D-SPECK (Tang <I>et al</I>. 2003) designed 
specifically for improved shape-adaptive coding, and it is a generalization 
to 3D of the original 2D BISK algorithm developed by Fowler. The 3D-BISK 
coder employs two tactics to improve shape-adaptive coding---aggressive discarding 
of transparent regions from sets after partitioning, and a spatial-partitioning 
structure more flexible than the octtrees used by 3D-SPECK. In octtree partitioning, 
the significance state of an entire cube of coefficients is tested and 
coded, the cube is subdivided into eight subcubes of approximately equal 
size, and the significance-coding process is repeated recursively on each 
of the subcubes. On the other hand, when processing a given set, the 3D-BISK 
coder employs a different partitioning scheme, <I>k</I>-d trees (Bentley 1975) 
rather than octtrees, to recursively code the significance map. Like octtrees, 
<I>k</I>-d trees are a recursive spatial partitioning data structure. Unlike octtrees, 
which subdivide a cube into eight equally sized subcubes, <I>k</I>-d trees effectuate 
a binary partitioning; that is, cubes are divided in two. Although there 
are several approaches for selecting the location and orientation of the 
split, the 3D-BISK algorithm uses a simple approach in which cubes are 
divided into approximately equally sized halves, and we alternate between 
splitting horizontally, vertically, and temporally. <P>
Additionally, to improve 
shape-adaptive coding, the 3D-BISK coder "shrinks" each set to the bounding 
box surrounding the opaque coefficients before subdividing the set into 
smaller blocks.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="biskencode3d.1.html">biskencode3d</B>(1)</A>
, <B><A HREF="biskdecode3d.1.html">biskdecode3d</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3D.3.html">QccWAVSubbandPyramid3D</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
, 
<B><A HREF="QccWAVbiskEncode.3.html">QccWAVbiskEncode</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 J. T. Rucker 
and J. E. Fowler, "Coding of Ocean-Temperature Volumes Using Binary Set Splitting 
with <I>k</I>-d Trees," in <I>Proceedings of the International Geoscience and Remote 
Sensing Symposium</I>, Anchorage, AK, September 2004, to appear. <P>
 J. E. Fowler, 
"Shape-Adaptive Coding Using Binary Set Splitting with <I>k</I>-d Trees," in <I>Proceedings 
of the International Conference on Image Processing</I>, Singapore, October 
2004, to appear. <P>
 X. Tang, W. A. Pearlman, and J. W. Modestino, "Hyperspectral 
Image Compression Using Three-Dimensional Wavelet Coding," in <I>Image and 
Video Communications and Processing</I>, Santa Clara, CA, January 2003, Proc. 
SPIE 5022, pp. 1037-1047. <P>
 J. L. Bentley, "Multidimensional Binary Search Trees 
Used for Associative Searching," <I>Communications of the ACM</I>, vol. 18, no. 
9, pp. 509-517, September 1975. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. 
Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
