<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletDWT2DInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletDWT2DInt, QccWAVWaveletInverseDWT2DInt -  integer-valued 
separable 2D discrete wavelet transform and inverse transform for a 2D 
signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVWaveletDWT2DInt(QccMatrixInt 
</B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>origin_row</I><B>, int </B><I>origin_col</I><B>, int 
</B><I>subsample_pattern_row</I><B>, int </B><I>subsample_pattern_col</I><B>, int </B><I>num_scales</I><B>, const 
QccWAVWavelet *</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletInverseDWT2DInt(QccMatrixInt 
</B><I>matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>origin_row</I><B>, int </B><I>origin_col</I><B>, int 
</B><I>subsample_pattern_row</I><B>, int </B><I>subsample_pattern_col</I><B>, int </B><I>num_scales</I><B>, const 
QccWAVWavelet *</B><I>wavelet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletDWT2DInt()</B> performs 
an integer-valued separable 2D discrete wavelet transform (DWT) of a two-dimensional 
signal, <I>matrix</I>, which is represented as a matrix of <I>num_rows</I> rows and 
<I>num_cols</I> columns. <I>origin_row</I> and <I>origin_col</I> indicates the row and column 
indices, respectively, of the upper-left corner of the image. Usually, one 
assumes that the upper-left corner of the image is indexed as (0, 0) - in 
this case, both <I>origin_row</I> and <I>origin_col</I> would be zero. <I>num_scales</I> gives 
the number of scales, or levels, of the decomposition. <B>QccWAVWaveletDWT2DInt()</B> 
implements a dyadic, or octave, decomposition of <I>matrix</I>; that is, the 
low-low subband (baseband) is recursively decomposed into a lowpass and 
three highpass bands for each level of decomposition, each of which being 
one quarter the size of the baseband that was decomposed. The output of 
the DWT is returned in <I>matrix</I>, overwriting the original input matrix. The 
output subbands reside in  <I>matrix</I> with the baseband in the upper-left corner, 
with highpass subbands successively "nested" from the upper-left corner 
to lower-right corner. <B>QccWAVWaveletDWT2DInt()</B> calls <B><A HREF="QccWAVWaveletAnalysis2DInt.3.html">QccWAVWaveletAnalysis2DInt</B>(3)</A>
 
for each level of decomposition, using the baseband subband for the current 
level of decomposition as input. As a result, the transform recursively 
decomposes the upper-left corner of the input matrix. <I>wavelet</I> must indicate 
an integer-valued lifting scheme (see <B><A HREF="QccWAVLiftingSchemeInteger.3.html">QccWAVLiftingSchemeInteger</B>(3)</A>
). <P>
<B>QccWAVWaveletInverseDWT2DInt()</B> 
performs the corresponding separable 2DInt inverse DWT of <I>matrix</I> which 
is assumed to have been produced by <B>QccWAVWaveletDWT2DInt()</B>. <I>num_scales</I> 
gives the number of levels of decomposition that exist in <I>matrix</I>. <B>QccWAVWaveletInverseDWT2DInt()</B> 
calls <B><A HREF="QccWAVWaveletSynthesis2DInt.3.html">QccWAVWaveletSynthesis2DInt</B>(3)</A>
 for each level of synthesis. <P>
<I>subsample_pattern_row</I> 
and <I>subsample_pattern_col</I> indicate the even- or odd-phase subsampling to 
be used at each level of row and column decomposition. In most applications, 
even subsampling at all levels is desired, in which case both  <I>subsample_pattern_row</I> 
and <I>subsample_pattern_col</I> should be set to zero. In more general settings, 
when some mixture of even- and odd-phase subsampling is desired,  <I>subsample_pattern_row</I> 
and <I>subsample_pattern_col</I> can be integers between 0 and <I>(2 ^ num_levels) 
- 1</I>. In these integers, the  <I>j</I>th bit (where <I>j</I> = 1 is the least-significant 
bit) indicates whether the <I>j</I>th level of decomposition employs even or 
odd subsampling (0 = even, 1 = odd). For example, if <I>subsample_pattern_row</I> 
is 5, then the first and third row decompositions use odd-phase subsampling, 
while all others use even subsampling. <P>
Use <B><A HREF="QccWAVSubbandPyramidIntDWT.3.html">QccWAVSubbandPyramidIntDWT</B>(3)</A>
 
and <B><A HREF="QccWAVSubbandPyramidIntInverseDWT.3.html">QccWAVSubbandPyramidIntInverseDWT</B>(3)</A>
 to perform a 2D separable DWT 
or inverse DWT on a <B>QccWAVSubbandPyramidInt</B> data structure (which is the 
recommended way to do it, since the <B>QccWAVSubbandPyramidInt</B> structure 
stores the number of levels of decomposition along with the transform 
coefficients).  
<H2><A NAME="sect3" HREF="#toc3">INTEGER-TO-INTEGER WAVELET TRANSFORMS </A></H2>
Transforms generally 
provide perfect reconstruction in that the inverse transform will perfectly 
invert transform coefficients into an exact representation of the original 
signal. However, when implemented in floating-point arithmetic, the potential 
for loss arises due to the limits of finite precision in both the forward 
and inverse transforms. On the other hand, transforms that map integer-valued 
signals into integer-valued transforms coefficients can guarantee perfect 
reconstruction, provided an inverse transform can be found. For this reason, 
lifting schemes, in which inverse transforms are trivial, are favored 
for the implementation of integer-valued wavelet transforms. Typically, 
the general approach proposed by Calderbank <I>et al</I>. is followed wherein 
rounding of floating-point values to integers is performed at each prediction 
and update step in a lifting scheme. Integer versions of several popular 
biorthogonal wavelets were created in this manner by Calderbank <I>et al</I>., 
as well as by Xiong <I>et al</I>. <P>
In traditional floating-point lifting, the prediction 
and update steps are generally followed by a single application of scaling 
by a constant in order to produce the usual unitary normalization. This 
scaling step is somewhat problematic for integer-valued lifting since the 
scaling constant is usually not an integer. In applications wherein unitary 
scaling is not required (e.g., in some applications that process each subband 
completely independently), the scaling step is simply dropped in order 
to implement an integer-valued version of the transform. Alternatively, 
one can append three additional lifting steps to  implement the scaling; 
these additional lifting steps can then be rendered integer-valued via 
appropriate rounding (e.g., Xiong <I>et al</I>.) making the transforms approximately 
normalized. This latter approach of scaling via additional lifting steps 
is employed in the integer-valued lifting schemes implemented in QccPack. 
 
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE 
ALSO </A></H2>
<B><A HREF="QccWAVWaveletAnalysis2DInt.3.html">QccWAVWaveletAnalysis2DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletSynthesis2DInt.3.html">QccWAVWaveletSynthesis2DInt</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramidIntDWT.3.html">QccWAVSubbandPyramidIntDWT</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramidIntInverseDWT.3.html">QccWAVSubbandPyramidIntInverseDWT</B>(3)</A>
, <B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless 
Image Compression Using Integer to Integer Wavelet Transforms", in <I>Proceedings 
of the International Conference on Image Processing</I>, Lausanne, Switzerland, 
pp. 596-599, September 1997. <P>
 Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless 
Compression of Medical Volumetric Data Using Three-Dimensional Integer 
Wavelet Transforms," <I>IEEE Transactions on Medical Imaging</I>, vol. 22, pp. 
459-470, March 2003. <P>
 I. Daubechies and W. Sweldens, "Factoring Wavelet Transforms 
Into Lifting Steps," <I>J. Fourier Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 1998. 
 
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
