<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletAnalysis1DInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletAnalysis1DInt, QccWAVWaveletSynthesis1DInt -  integer-valued 
wavelet analysis/synthesis of a 1D signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccWAVWaveletAnalysis1DInt(QccVectorInt </B><I>signal</I><B>, int </B><I>signal_length</I><B>, 
int </B><I>phase</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletSynthesis1DInt(QccVectorInt 
</B><I>signal</I><B>, int </B><I>signal_length</I><B>, int </B><I>phase</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  

<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletAnalysis1DInt()</B> performs one level of an integer-valued 
wavelet decomposition for a one-dimensional signal. Essentially, <B>QccWAVWaveletAnalysis1DInt()</B> 
calls <B><A HREF="QccWAVLiftingAnalysisInt.3.html">QccWAVLiftingAnalysisInt</B>(3)<B></A>
.</B> <I>phase</I> indicates whether  <I>signal</I> is to 
start with an odd- or even-indexed sample; that is, whether odd- or even-phase 
subsampling is employed after filtering. <I>phase</I> can be either <B>QCCWAVWAVELET_PHASE_EVEN</B> 
or <B>QCCWAVWAVELET_PHASE_ODD</B>. Additionally, <I>signal_length</I> can be even or 
odd. <I>wavelet</I> must indicate an integer-valued lifting scheme (see <B><A HREF="QccWAVLiftingSchemeInteger.3.html">QccWAVLiftingSchemeInteger</B>(3)</A>
). 
<P>
<B>QccWAVWaveletSynthesis1DInt()</B> performs one level of wavelet synthesis. 
 The first half of <I>signal</I> is assumed to contain the lowpass subband while 
the second half contains the highpass subband. <B>QccWAVWaveletSynthesis1DInt()</B> 
calls <B><A HREF="QccWAVLiftingSynthesisInt.3.html">QccWAVLiftingSynthesisInt</B>(3)</A>
. <I>phase</I> indicates whether  <I>signal</I> is 
to start with an odd- or even-indexed sample. <I>signal_length</I> can be even or 
odd. <P>
Note: In general, you will probably want to use <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
 
and <B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
 instead of these routines for implementing 
a discrete wavelet transform and its inverse since <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
 
and <B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
 allow any number of scales, or levels, 
of decomposition to be performed.  
<H2><A NAME="sect3" HREF="#toc3">INTEGER-TO-INTEGER WAVELET TRANSFORMS 
</A></H2>
Transforms generally provide perfect reconstruction in that the inverse 
transform will perfectly invert transform coefficients into an exact representation 
of the original signal. However, when implemented in floating-point arithmetic, 
the potential for loss arises due to the limits of finite precision in 
both the forward and inverse transforms. On the other hand, transforms 
that map integer-valued signals into integer-valued transforms coefficients 
can guarantee perfect reconstruction, provided an inverse transform can 
be found. For this reason, lifting schemes, in which inverse transforms 
are trivial, are favored for the implementation of integer-valued wavelet 
transforms. Typically, the general approach proposed by Calderbank <I>et al</I>. 
is followed wherein rounding of floating-point values to integers is performed 
at each prediction and update step in a lifting scheme. Integer versions 
of several popular biorthogonal wavelets were created in this manner by 
Calderbank <I>et al</I>., as well as by Xiong <I>et al</I>. <P>
In traditional floating-point 
lifting, the prediction and update steps are generally followed by a single 
application of scaling by a constant in order to produce the usual unitary 
normalization. This scaling step is somewhat problematic for integer-valued 
lifting since the scaling constant is usually not an integer. In applications 
wherein unitary scaling is not required (e.g., in some applications that 
process each subband completely independently), the scaling step is simply 
dropped in order to implement an integer-valued version of the transform. 
Alternatively, one can append three additional lifting steps to  implement 
the scaling; these additional lifting steps can then be rendered integer-valued 
via appropriate rounding (e.g., Xiong <I>et al</I>.) making the transforms approximately 
normalized. This latter approach of scaling via additional lifting steps 
is employed in the integer-valued lifting schemes implemented in QccPack. 
 
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE 
ALSO </A></H2>
<B><A HREF="QccWAVLiftingScheme.3.html">QccWAVLiftingScheme</B>(3)</A>
, <B><A HREF="QccWAVLiftingAnalysisInt.3.html">QccWAVLiftingAnalysisInt</B>(3)</A>
, <B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless 
Image Compression Using Integer to Integer Wavelet Transforms", in <I>Proceedings 
of the International Conference on Image Processing</I>, Lausanne, Switzerland, 
pp. 596-599, September 1997. <P>
 Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless 
Compression of Medical Volumetric Data Using Three-Dimensional Integer 
Wavelet Transforms," <I>IEEE Transactions on Medical Imaging</I>, vol. 22, pp. 
459-470, March 2003. <P>
 I. Daubechies and W. Sweldens, "Factoring Wavelet Transforms 
Into Lifting Steps," <I>J. Fourier Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 1998. 
 
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
