<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVTarp3DEncode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVTarp3DEncode, QccWAVTarp3DDecode - encode/decode an image cube 
using the 3D tarp algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVTarp3DEncode(const 
QccIMGImageCube *</B><I>image</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, QccBitBuffer *</B><I>buffer</I><B>, 
int </B><I>transform_type</I><B>, int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, double 
</B><I>alpha</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  <P>
<B>int QccWAVTarp3DDecodeHeader(QccBitBuffer 
*</B><I>buffer</I><B>, int *</B><I>transform_type</I><B>, int *</B><I>temporal_num_levels</I><B>, int *</B><I>spatial_num_levels</I><B>, 
int *</B><I>num_frames</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int 
*</B><I>max_coefficient_bits</I><B>, double *</B><I>alpha</I><B>);</B>  <P>
<B>int QccWAVTarp3DDecode(QccBitBuffer 
*</B><I>buffer</I><B>, QccIMGImageCube *</B><I>image</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, double </B><I>alpha</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>, double </B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_bit</I><B>);</B> 
 
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVTarp3DEncode()</B> encodes an image cube, <I>image</I>, 
using a 3D generalization of the tarp algorithm. The original tarp algorithm 
was developed for 2D images by Simard <I>et al</I>.; it was latter extended to 
3D by Wang <I>et al</I>. In essence, the 3D tarp algorithm involves a 3D DWT followed 
by  a progressive "bitplane" coding of the wavelet coefficients using 
a Parzen-window technique to estimate probability of significance and nonadaptive 
arithmetic coding to code significance-map and refinement information. See 
"ALGORITHM" below for more detail. <P>
<I>image</I> is the image cube to be coded 
and <I>buffer</I> is the output bitstream. <I>buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> 
type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccWAVTarp3DEncode</B>() 
supports the use of both wavelet-packet and dyadic wavelet-transform decompositions. 
If <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B>, a dyadic DWT is used; 
if <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B>, a wavelet-packet DWT 
is used. <I>temporal_num_levels</I> and <I>spatial_num_levels</I> give the number of 
levels of wavelet decomposition to perform for both transform types; for 
a dyadic transform, <I>temporal_num_levels</I> should equal <I>spatial_num_levels</I>. 
<I>wavelet</I> is the wavelet to use for decomposition. <P>
The 3D tarp algorithm 
performance is determined primarily through the parameter <I>alpha</I>, a value 
that gives the learning rate of the density-estimation process implemented 
by the tarp filter. Wang <I>et al</I>. used a value of <I>alpha</I> = 0.3. <P>
The bitstream 
output from the 3D tarp encoder is embedded, meaning that any prefix of 
the bitstream can be decoded to give a valid  representation of the image. 
 The 3D tarp encoder essentially produces output bits until the number 
of bits output reaches <I>target_bit_cnt</I>, the desired (target) total length 
of the output bitstream in bits, and then it stops. Note that this is the 
bitstream length in bits, not the rate of the bitstream (which would be 
expressed in bits per voxel). <P>
<B>QccWAVTarp3DEncode()</B> optionally supports 
the use of a shape-adaptive DWT (SA-DWT) rather than the usual DWT. That 
is,  <B>QccWAVTarp3DEncode()</B> can call <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
as the wavelet transform rather than the usual <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
. 
The use of a SA-DWT is indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then 
the usual DWT is used. In the case of a SA-DWT, <I>mask</I>  gives the transparency 
mask which indicates which voxels of the image are non-transparent and 
thus have data that is to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
for more details on the calculation of this SA-DWT. See "ALGORITHM" below 
for details on how the 3D tarp algorithm handles shape-adaptive coding. 
 
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVTarp3DDecodeHeader()</B> decodes the header information  in 
a bitstream previously produced by <B>QccWAVTarp3DEncode()</B>. The input bitstream 
is <I>buffer</I> which must be of <B>QCCBITBUFFER_INPUT</B> type and opened via a prior 
call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
The header information is returned in <I>transform_type</I> 
(either <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B> or <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B> 
to indicate a dyadic or wavelet-packet transform decomposition, respectively), 
<I>temporal_num_levels</I> (number of levels of wavelet decomposition in the 
temporal direction), <I>spatial_num_levels</I> (number of levels of wavelet decomposition 
in the spatial directions), <I>num_frames</I> (size of the image cube in the 
temporal direction), <I>num_rows</I> (vertical size of image cube), <I>num_cols</I> 
(horizontal size of image cube), <I>image_mean</I> (the mean value of the original 
image cube), <I>max_coefficient_bits</I> (indicates the precision, in number 
of bits, of the wavelet coefficient with the largest magnitude), and <I>alpha</I> 
(the value of the learning rate). <P>
<B>QccWAVTarp3DDecode()</B> decodes the bitstream 
<I>buffer</I>, producing the reconstructed image cube, <I>image</I>. The bitstream must 
already have had its header read by a prior call to <B>QccWAVTarp3DDecodeHeader()</B> 
(i.e., you call <B>QccWAVTarp3DDecodeHeader() </B> first and then <B>QccWAVTarp3DDecode()</B>). 
If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, then decoding stops when the end 
of the input bitstream is reached; otherwise, decoding stops when <I>target_num_bits</I> 
from the input bitstream have been decoded. <P>
If a SA-DWT was used in 3D tarp 
encoding, then the original transparency mask should be passed to  <B>QccWAVTarp3DDecode()</B> 
as <I>mask</I>. That is, <I>mask</I> should be the same transparency mask (untransformed) 
 that was passed to <B>QccWAVTarp3DEncode()</B>. Note that <B>QccWAVTarp3DDecode()</B> 
will transform this <I>mask</I> via a Lazy wavelet transform, and then pass the 
transformed mask to  <B><A HREF="QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT</B>(3)</A>
. 
If the usual, full-volume DWT was used in encoding, then <I>mask</I> should be 
a NULL pointer.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
There are several variants of the tarp algorithm. 
The progressive (but not embedded) coder originally described by Simard 
<I>et al</I>. for 2D images applied a scalar quantizer to the coefficients of 
a 2D DWT and then used the tarp-filter procedure described below to independently 
code each of the bitplanes of the coefficients. On the other hand, the 
QccPack implementation of 2D tarp coding is an embedded coder based on 
the significance-refinement approach to bitplane coding common to wavelet-based 
embedded coders. (see <B><A HREF="QccWAVTarpEncode.3.html">QccWAVTarpEncode</B>(3)</A>
). <P>
The 3D tarp algorithm implemented 
here is that described by Wang <I>et al</I>. This 3D tarp coder follows the same 
significance-refinement approach to embedded coding as employed in the 
2D QccPack tarp coder <B><A HREF="QccWAVTarpEncode.3.html">QccWAVTarpEncode</B>(3)</A>
 and involves a 3D DWT followed 
by a progressive encoding of the bitplanes of wavelet coefficients. As 
is common with bitplane-based embedded coders, the encoder of the tarp 
algorithm codes significance information in a significance pass followed 
by refinement-bit information in a refinement pass. The significance pass 
determines the significance of a wavelet coefficient against a given threshold, 
while the refinement pass codes the bits of those coefficients previously 
determined to be significant. <P>
The unique aspect of the 3D tarp algorithm 
is in the significance pass. The 3D tarp algorithm employs a density-estimation 
process based upon Parzen windows to determine the probability that each 
currently insignificant coefficient becomes significant in the current 
significance pass. This probability is passed to a two-symbol, nonadaptive 
arithmetic coder to code the actual significance value of the current 
coefficient. The <I>alpha</I> parameter to the algorithm determines the shape 
of the Parzen windows employed, effectively determining the learning rate 
of the density-estimation process. The actual density estimation is implemented 
as an efficient set of filtering operations that create a causal 3D filter. 
<P>
The refinement pass codes refinement bits using the same nonadaptive arithmetic 
coder used in the significance pass except that the refinement bits are 
assumed equally likely, and thus a uniform density is used by the nonadaptive 
arithmetic coder. <P>
As proposed by Fowler, to handle shape-adaptive coding 
(not originally considered by Simard <I>et al</I>. for the initial 2D algorithm, 
or by Wang <I>et al</I>. for the subsequent 3D algorithm), the implementation 
here merely skips over  the transparent regions, maintaining the current 
probability estimate unchanged.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="tarpencode3d.1.html">tarpencode3d</B>(1)</A>
, <B><A HREF="tarpdecode3d.1.html">tarpdecode3d</B>(1)</A>
, 
<B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3D.3.html">QccWAVSubbandPyramid3D</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
, <B><A HREF="QccWAVTarpEncode.3.html">QccWAVTarpEncode</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, 
<B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 Y. Wang, J. T. Rucker, and J. E. Fowler, "Embedded 
Wavelet-Based Compression of Hyperspectral Imagery Using Tarp Coding," 
in <I>Proceedings of the International Geoscience and Remote Sensing Symposium</I>, 
Toulouse, France, July 2003, vol. 3, pp. 2027-2029. <P>
P. Simard, D. Steinkraus, 
and H. Malvar, "On-Line Adaptation in Image Coding with a 2-D Tarp Filter", 
in <I>Proceedings of the IEEE Data Compression Conference</I>, J. A. Storer and 
M. Cohn, Eds.,   Snowbird, UT, April 2002, pp. 422-431. <P>
J. E. Fowler, "Shape-Adaptive 
Tarp Coding," in <I>Proceedings of the International Conference on Image 
Processing</I>, Barcelona, Spain, September 2003, vol. 1, pp. 621-624. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR 
</A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
