<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVTarpDecode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVTarpEncode, QccWAVTarpDecode - encode/decode an image using 
the tarp algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVTarpEncode(const 
QccIMGImageComponent *</B><I>image</I><B>, const QccIMGImageComponent *</B><I>mask</I><B>, double 
</B><I>alpha</I><B>, int </B><I>num_levels</I><B>, int </B><I>target_bit_cnt</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
QccBitBuffer *</B><I>output_buffer</I><B>);</B>  <BR>
<B>int QccWAVTarpDecodeHeader(QccBitBuffer 
*</B><I>input_buffer</I><B>, double *</B><I>alpha</I><B>, int *</B><I>num_levels</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, 
double *</B><I>image_mean</I><B>, int *</B><I>max_coefficient_bits</I><B>);</B>  <BR>
<B>int QccWAVTarpDecode(QccBitBuffer 
*</B><I>input_buffer</I><B>, QccIMGImageComponent *</B><I>image</I><B>, const QccIMGImageComponent 
*</B><I>mask</I><B>, double </B><I>alpha</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, double 
</B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVTarpEncode()</B> encodes an image component, <I>image</I>, using 
the tarp algorithm by Simard <I>et al</I>. The tarp algorithm involves a 2D DWT 
followed by  a progressive "bitplane" coding of the wavelet coefficients 
using a Parzen-window technique to estimate probability of significance 
and nonadaptive arithmetic coding to code significance-map and refinement 
information. See "ALGORITHM" below for more detail. <P>
<I>image</I> is the image component 
to be coded and <I>buffer</I> is the output bitstream. <I>buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> 
type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<I>num_levels</I> gives 
the number of levels of dyadic wavelet decomposition to perform, and <I>wavelet</I> 
is the wavelet to use for decomposition. <P>
The tarp algorithm performance 
is determined primarily through the parameter <I>alpha</I>, a value that gives 
the learning rate of the density-estimation process implemented by the 
tarp filter. Simard <I>et al</I>. originally used a value of <I>alpha</I> = 0.6. <P>
The bitstream 
output from the tarp encoder is embedded, meaning that any prefix of the 
bitstream can be decoded to give a valid  representation of the image. 
 The tarp encoder essentially produces output bits until the number of 
bits output reaches <I>target_bit_cnt</I>, the desired (target) total length 
of the output bitstream in bits, and then it stops. Note that this is the 
bitstream length in bits, not the rate of the bitstream (which would be 
expressed in bits per pixel). <P>
<B>QccTarpEncode()</B> optionally supports the use 
of a shape-adaptive DWT (SA-DWT) rather than the usual DWT. That is,  <B>QccTarpEncode()</B> 
can call <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 as the wavelet transform 
rather than the usual <B><A HREF="QccWAVSubbandPyramidDWT.3.html">QccWAVSubbandPyramidDWT</B>(3)</A>
. The use of a SA-DWT is 
indicated by a non-<B>NULL</B> <I>mask</I>; if  <I>mask</I> is <B>NULL</B>, then the usual DWT is used. 
In the case of a SA-DWT, <I>mask</I>  gives the transparency mask which indicates 
which pixels of the image are non-transparent and thus have data that is 
to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 for 
more details on the calculation of this SA-DWT, and see "ALGORITHM" below 
for how the shape-adaptive mask is employed in the tarp algorithm.  
<H3><A NAME="sect4" HREF="#toc4">Decoding 
</A></H3>
<P>
<B>QccWAVTarpDecodeHeader()</B> decodes the header information in the bitstream 
in the input <I>buffer</I> (which must be of <B>QCCBITBUFFER_INPUT</B> type and opened 
via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
). The header information is returned 
in <I>alpha</I> (the learning-rate parameter of the density-estimation process), 
<I>num_levels</I> (number of levels of wavelet decomposition), <I>num_rows</I> (vertical 
size of image), <I>num_cols</I> (horizontal size of image), <I>image_mean</I> (the mean 
value of the original image), and <I>max_coefficient_bits</I> (the number of 
bits used to represent the magnitude of the coefficient with largest absolute 
value). <P>
<B>QccWAVTarpDecode()</B> decodes the bitstream <I>buffer</I>, producing the 
reconstructed image component, <I>image</I>. The bitstream must already have had 
its header read by a prior call to <B>QccWAVTarpDecodeHeader()</B> (i.e., you call 
<B>QccWAVTarpDecodeHeader() </B> first and then <B>QccWAVTarpDecode()</B>). If <I>target_bit_cnt</I> 
is <B>QCCENT_ANYNUMBITS</B>, then decoding stops when the end of the input bitstream 
is reached; otherwise, decoding stops when <I>target_num_bits</I> from the input 
bitstream have been decoded. <P>
If a SA-DWT was used in tarp encoding, then 
the original transparency mask should be passed to  <B>QccWAVTarpDecode()</B> 
as <I>mask</I>. That is, <I>mask</I> should be the same transparency mask (in the spatial 
domain) that was passed to <B>QccWAVTarpEncode()</B>. Note that <B>QccWAVTarpDecode()</B> 
will transform this <I>mask</I> via a Lazy wavelet transform, and then pass the 
transformed mask to  <B><A HREF="QccWAVSubbandPyramidInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidInverseShapeAdaptiveDWT</B>(3)</A>
. If 
the usual DWT was used in encoding, then <I>mask</I> should be a <B>NULL</B> pointer. 
 
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
There are several variants of the tarp algorithm for image 
coding. The coder originally described by Simard <I>et al</I>. applied a scalar 
quantizer to the coefficients of a 2D DWT and then used the tarp-filter 
procedure described below to independently code each of the bitplanes 
of the coefficients. The quantizer stepsize was adjusted to optimze performance 
for a specified target rate. Although this approach results in a progressive 
coding of the image, strictly speaking, the bitstream is not embedded. 
On the other hand, the QccPack implementation of tarp coding is an embedded 
coder based on the significance-refinement approach to bitplane coding 
common to wavelet-based embedded coders. We note that this embedded approach 
was suggested as an alternative implementation by Simard <I>et al</I>. in their 
original paper, but results given there focused on the  quantizer-based 
non-embedded approach just described. <P>
The embedded tarp coder as implemented 
in QccPack involves a 2D DWT followed by a progressive encoding of the 
bitplanes of wavelet coefficients. As is common with bitplane-based embedded 
coders, the encoder of the tarp algorithm codes significance information 
in a significance pass followed by refinement-bit information in a refinement 
pass. The significance pass determines the significance of a wavelet coefficient 
against a given threshold, while the refinement pass codes the bits of 
those coefficients previously determined to be significant. <P>
The unique 
aspect of the tarp algorithm is in the significance pass. The tarp algorithm 
employs a density-estimation process based upon Parzen windows to determine 
the probability that each currently insignificant coefficient becomes 
significant in the current significance pass. This probability is passed 
to a two-symbol, nonadaptive arithmetic coder to code the actual significance 
value of the current coefficient. The <I>alpha</I> parameter to the algorithm 
determines the shape of the Parzen windows employed, effectively determining 
the learning rate of the density-estimation process. The actual density 
estimation is implemented as an efficient set of filtering operations 
that create a causal 2D filter that looks like a canvas propped up by 
a pole at the current coefficient, hence the name "tarp" filter. That's 
it - no runlength coding, no zerotrees - just a simple density estimation. 
<P>
The refinement pass codes refinement bits using the same nonadaptive arithmetic 
coder used in the significance pass except that the refinement bits are 
assumed equally likely, and thus a uniform density is used by the nonadaptive 
arithmetic coder. <P>
There are several ways to handle the overlapping of the 
2D causal tarp filter  beyond the image boundaries. Simard <I>et al</I>. proposed 
boundary initial conditions that attempt to spread prior knowledge accumulated 
during the filtering along the boundary. In contrast, the implementation 
here takes the simpler route of merely assuming all values beyond the 
image boundaries are insignificant. It is unlikely that either approach 
differs much from the other in terms of rate-distortion performance. <P>
As 
proposed by Fowler, to handle shape-adaptive coding (not originally considered 
by Simard <I>et al</I>.), the implementation here merely skips over  the transparent 
regions, maintaining the current probability estimate unchanged. <P>
Finally, 
we note that Tian and Hemami proposed a variant of tarp coding somewhat 
similar to what is implemented here in that they use the tarp filter to 
code significance information. However, their approach is somewhat more 
sophisticated in that fraction bitplanes are used in the significance 
pass to achieve a higher degree of embeddedness.  
<H2><A NAME="sect6" HREF="#toc6">PERFORMANCE </A></H2>
The tarp 
algorithm offers rate-distortion performance amazing close to the SPIHT 
algorithm (see <B><A HREF="QccSPIHTEncode.3.html">QccSPIHTEncode</B>(3)</A>
 in the optional QccPackSPIHT module). 
The following table compares the tarp coder (alpha = 0.6) with the SPIHT 
coder (arithmetic-coding version).  <blockquote>               Lenna <BR>
  ------------------------------------ <BR>
  | Rate  |   
       PSNR (db)       | <BR>
  | (bpp) |    Tarp          SPIHT   | <BR>
  ------------------------------------ <BR>
  |  0.2 
 |    32.83    |    32.94   | <BR>
  |  0.5  |    36.74    |    37.11   | <BR>
  |  1.0  |    39.85 
   |    40.28   | <BR>
  ------------------------------------ <BR>
     Average difference = 0.22 dB <BR>
 <P>
 <P>
               Barbara 
<BR>
  ------------------------------------ <BR>
  | Rate  |          PSNR (db)       | <BR>
  | (bpp) |     Tarp         SPIHT 
  | <BR>
  ------------------------------------ <BR>
  |  0.2  |    26.48    |    26.48   | <BR>
  |  0.5  |    31.07    |    31.33   | 
<BR>
  |  1.0  |    35.90    |    36.43   | <BR>
  ------------------------------------ <BR>
     Average difference = 0.11 dB <BR>
 <P>
 
<P>
               Goldhill <BR>
  ------------------------------------ <BR>
  | Rate  |          PSNR (db)       | <BR>
  | (bpp) 
|    Tarp          SPIHT   | <BR>
  ------------------------------------ <BR>
  |  0.2  |    29.62    |    29.68   | <BR>
  |  0.5  
|    32.97    |    32.96   | <BR>
  |  1.0  |    36.16    |    36.37   | <BR>
  ------------------------------------ <BR>
     Average 
difference = 0.12 dB <BR>
 <P>
  </blockquote>
<P>
  
<H2><A NAME="sect7" HREF="#toc7">NOTES </A></H2>
The tarp-filer algorithm as described originally 
by Simard <I>et al</I> . does not employ shape-adaptive coding.  
<H2><A NAME="sect8" HREF="#toc8">SEE ALSO </A></H2>
<B><A HREF="tarpencode.1.html">tarpencode</B>(1)</A>
, 
<B><A HREF="tarpdecode.1.html">tarpdecode</B>(1)</A>
, <B><A HREF="imgdwt.1.html">imgdwt</B>(1)</A>
, <B><A HREF="imgdist.1.html">imgdist</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccENTArithmeticEncode.3.html">QccENTArithmeticEncode</B>(3)</A>
, 
<B><A HREF="QccENTArithmeticDecode.3.html">QccENTArithmeticDecode</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid.3.html">QccWAVSubbandPyramid</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 P. Simard, D. Steinkraus, and H. Malvar, "On-Line Adaptation in 
Image Coding with a 2-D Tarp Filter", in <I>Proceedings of the IEEE Data Compression 
Conference</I>, J. A. Storer and M. Cohn, Eds.,   Snowbird, UT, April 2002, pp. 
422-431. <P>
J. E. Fowler, "Shape-Adaptive Tarp Coding," in <I>Proceedings of the 
International Conference on Image Processing</I>, Barcelona, Spain, September 
2003, vol. 1, pp. 621-624. <P>
C. Tian and S. S. Hemami, "An Embedded Image Coding 
System Based on Tarp Filter with Classification," in <I>Proceedings of the 
International Conference on Acoustics, Speech, and Signal Processing</I>, 
Montreal, Canada, May 2004, to appear. <P>
  
<H2><A NAME="sect9" HREF="#toc9">AUTHOR </A></H2>
Copyright (C) 1997-2016 
 James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">PERFORMANCE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">NOTES</A></LI>
<LI><A NAME="toc8" HREF="#sect8">SEE ALSO</A></LI>
<LI><A NAME="toc9" HREF="#sect9">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
