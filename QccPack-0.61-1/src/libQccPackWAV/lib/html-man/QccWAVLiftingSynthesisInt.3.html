<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVLiftingSynthesisInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVLiftingAnalysisInt, QccWAVLiftingSynthesisInt -  perform integer-valued 
lifting analysis/synthesis of a signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSISINT </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccWAVLiftingAnalysisInt(QccVectorInt </B><I>signal</I><B>, int </B><I>signal_length</I><B>, 
int </B><I>phase</I><B>, const QccWAVLiftingScheme *</B><I>lifting_scheme</I><B>, int </B><I>boundary</I><B>);</B>  
<BR>
<B>int QccWAVLiftingSynthesisInt(QccVectorInt </B><I>signal</I><B>, int </B><I>signal_length</I><B>, 
int </B><I>phase</I><B>, const QccWAVLiftingScheme *</B><I>lifting_scheme</I><B>, int </B><I>boundary</I><B>);</B>  

<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVLiftingAnalysisInt()</B> performs one level of an integer-valued 
wavelet decomposition, which maps integer signal values into integer-valued 
wavelet coefficients (see "INTEGER-TO-INTEGER WAVELET TRANSFORMS" below). 
Specifically, lifting analysis is employed to produce a lowpass subband 
and a highpass subband of <I>signal</I>. The lowpass subband is returned as the 
first half of <I>signal</I>; the highpass subband is returned as the last half 
of <I>signal</I>. <I>signal_length</I> gives the length of <I>signal</I> and may be even or 
odd. <P>
If <I>phase</I> is <B>QCCWAVWAVELET_PHASE_EVEN</B>, then <I>signal</I> is assumed to start 
with a even-indexed sample. Otherwise, if <I>phase</I> is <B>QCCWAVWAVELET_PHASE_ODD</B>, 
it indicates that <I>signal</I> starts with an odd-indexed sample. <I>phase</I> is passed 
to <B><A HREF="QccWAVWaveletLWTInt.3.html">QccWAVWaveletLWTInt</B>(3)</A>
, the lazy wavelet transform, the first step 
of lifting analysis, to indicate the signal origin. <P>
In the case that <I>signal_length</I> 
is even, both the odd and even subbands of produced by lifting analysis 
are the same length.  On the other hand, if <I>signal_length</I> is odd, one of 
the two subbands will be one sample longer than the other. Which subband 
will be longer will depend on the value of <I>phase</I>. Specifically, if <I>phase</I> 
is <B>QCCWAVWAVELET_PHASE_EVEN</B>, then the lowpass subband is one sample longer 
than the highpass subband. If <I>phase</I> is <B>QCCWAVWAVELET_PHASE_ODD</B>, the the 
highpass subband is one sample longer than the lowpass subband. <P>
<I>lifting_scheme</I> 
gives the particular lifting scheme to employ, which must be an integer-valued 
lifting scheme. Lifting implementations of wavelet analysis and synthesis 
are "hard-coded" into the QccPack library for purposes of execution speed 
and ease of implementation. As a consequence, only a limited number of 
wavelets are current supported, and this list cannot be extended by the 
user (without modifying the QccPack source code, or course). The currently 
supported integer-valued lifting schemes and their corresponding <B>LFT</B> files 
(see <B><A HREF="QccWAVLiftingScheme.3.html">QccWAVLiftingScheme</B>(3)</A>
) are  <blockquote><P>
 LWT.int.lft - integer-valued Lazy Wavelet 
transform  <BR>
CohenDaubechiesFeauveau.9-7.int.lft - integer-valued 9/7 biorthogonal 
wavelet  <BR>
CohenDaubechiesFeauveau.5-3.int.lft - integer-valued 5/3 biorthogonal 
wavelet  </blockquote>
<P>
<B>QccWAVLiftingSynthesisInt()</B> performs one level of wavelet synthesis. 
 The first half of <I>signal</I> is assumed to contain the lowpass subband while 
the second half contains the highpass subband. Lifting synthesis is performed 
to produce the output signal which is returned in <I>signal</I>, including a 
call to <B><A HREF="QccWAVWaveletInverseLWTInt.3.html">QccWAVWaveletInverseLWTInt</B>(3)</A>
 to perform an inverse lazy wavelet 
transform. As with <B>QccWAVLiftingAnalysisInt()</B>, <I>signal_length</I> may be even 
or odd. <I>phase</I> indicates whether the output <I>signal</I> is to start with an even- 
or odd-indexed sample. <P>
<I>boundary</I> indicates how lifting should be handled 
at the ends of the signal and can be one of the following: <B>QCCWAVWAVELET_BOUNDARY_SYMMETRIC_EXTENSION</B> 
(symmetric extension, valid only for biorthogonal wavelets), or <B>QCCWAVWAVELET_BOUNDARY_PERIODIC_EXTENSION</B> 
(periodic extension, valid for orthogonal and biorthogonal wavelets). Check 
the comments at the start of each <B>LFT</B> file for permitted values for <I>boundary</I> 
for particular lifting schemes. Note that, if periodic extension is used, 
<I>signal_length</I> must be even (this is due to mathematical constraints). <P>
The 
case in which <I>signal_length</I> is equal to 1 is degenerate. A wavelet transform 
is technically not well defined for this situation because it is not clear 
how to subsample the signal. For integer-valued lifting in QccPack, the 
length-one signal is merely placed in the lowpass subband unchanged (in 
which case the highpass subband has zero length) for  <I>phase</I> equal to <B>QCCWAVWAVELET_PHASE_EVEN</B>, 
or placed in the highpass subband unchanged (in which case the lowpass 
subband has zero length) for <I>phase</I> equal to <B>QCCWAVWAVELET_PHASE_ODD</B>. <P>
Note: 
In general, you will probably want to use <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
 and 
<B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
 instead of these routines for implementing 
a discrete wavelet transform and its inverse since <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
 
and <B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
 allow any number of scales, or levels, 
of decomposition to be performed.  
<H2><A NAME="sect3" HREF="#toc3">INTEGER-TO-INTEGER WAVELET TRANSFORMS 
</A></H2>
Transforms generally provide perfect reconstruction in that the inverse 
transform will perfectly invert transform coefficients into an exact representation 
of the original signal. However, when implemented in floating-point arithmetic, 
the potential for loss arises due to the limits of finite precision in 
both the forward and inverse transforms. On the other hand, transforms 
that map integer-valued signals into integer-valued transforms coefficients 
can guarantee perfect reconstruction, provided an inverse transform can 
be found. For this reason, lifting schemes, in which inverse transforms 
are trivial, are favored for the implementation of integer-valued wavelet 
transforms. Typically, the general approach proposed by Calderbank <I>et al</I>. 
is followed wherein rounding of floating-point values to integers is performed 
at each prediction and update step in a lifting scheme. Integer versions 
of several popular biorthogonal wavelets were created in this manner by 
Calderbank <I>et al</I>., as well as by Xiong <I>et al</I>. <P>
In traditional floating-point 
lifting, the prediction and update steps are generally followed by a single 
application of scaling by a constant in order to produce the usual unitary 
normalization. This scaling step is somewhat problematic for integer-valued 
lifting since the scaling constant is usually not an integer. In applications 
wherein unitary scaling is not required (e.g., in some applications that 
process each subband completely independently), the scaling step is simply 
dropped in order to implement an integer-valued version of the transform. 
Alternatively, one can append three additional lifting steps to  implement 
the scaling; these additional lifting steps can then be rendered integer-valued 
via appropriate rounding (e.g., Xiong <I>et al</I>.) making the transforms approximately 
normalized. This latter approach of scaling via additional lifting steps 
is employed in the integer-valued lifting schemes implemented in QccPack. 
 
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE 
ALSO </A></H2>
<B><A HREF="QccWAVLiftingScheme.3.html">QccWAVLiftingScheme</B>(3)</A>
, <B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
A. R. Calderbank, 
I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless Image Compression Using Integer 
to Integer Wavelet Transforms", in <I>Proceedings of the International Conference 
on Image Processing</I>, Lausanne, Switzerland, pp. 596-599, September 1997. 
<P>
 Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless Compression of Medical 
Volumetric Data Using Three-Dimensional Integer Wavelet Transforms," <I>IEEE 
Transactions on Medical Imaging</I>, vol. 22, pp. 459-470, March 2003. <P>
 I. Daubechies 
and W. Sweldens, "Factoring Wavelet Transforms Into Lifting Steps," <I>J. Fourier 
Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 1998.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 1997-2016 
 James E. Fowler <P>
 <P>
 <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSISINT</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
