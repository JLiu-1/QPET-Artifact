<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletAnalysis3DInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletAnalysis3DInt, QccWAVWaveletSynthesis3DInt -  integer-valued 
separable wavelet analysis/synthesis of a 3DInt signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include 
"libQccPack.h"</B>  <P>
<B>int QccWAVWaveletAnalysis3DInt(QccVolumeInt </B><I>volume</I><B>, int 
</B><I>num_frames</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>phase_frame</I><B>, int </B><I>phase_row</I><B>, 
int </B><I>phase_col</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  <P>
<B>int QccWAVWaveletSynthesis3DInt(QccVolumeInt 
</B><I>volume</I><B>, int </B><I>num_frames</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>phase_frame</I><B>, int 
</B><I>phase_row</I><B>, int </B><I>phase_col</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
<B>QccWAVWaveletAnalysis3DInt()</B> performs one level of an integer-valued separable 
3D wavelet decomposition for a three-dimensional signal, <I>volume</I>, which 
is represented as a volume of <I>num_frames</I> frames, <I>num_rows</I> rows, and <I>num_cols</I> 
columns. Essentially, <B>QccWAVWaveletAnalysis3DInt()</B> calls <B><A HREF="QccWAVWaveletAnalysis2DInt.3.html">QccWAVWaveletAnalysis2DInt</B>(3)</A>
 
once for each frame of the volume, and then <B><A HREF="QccWAVWaveletAnalysis1DInt.3.html">QccWAVWaveletAnalysis1DInt</B>(3)</A>
 
for each vector in the temporal direction. <I>phase_frame</I>, <I>phase_row</I>, and 
<I>phase_col</I> indicate whether the frames, rows, and columns, respectively, 
of the image start with even- or odd-indexed samples. Usually, one assumes 
that the upper corner of the image cube is indexed as (0, 0, 0) - in this 
case,  <I>phase_frame</I>, <I>phase_row</I>, and <I>phase_col</I> would all be <B>QCCWAVWAVELET_PHASE_EVEN</B>. 
In any event, <I>phase_frame</I>, <I>phase_row</I>, and <I>phase_col</I> are passed  with each 
call to  <B><A HREF="QccWAVWaveletAnalysis2DInt.3.html">QccWAVWaveletAnalysis2DInt</B>(3)</A>
 and <B><A HREF="QccWAVWaveletAnalysis1DInt.3.html">QccWAVWaveletAnalysis1DInt</B>(3)</A>
 
as appropriate. The result of the separable decomposition is returned in 
<I>volume</I>. <I>wavelet</I> must indicate an integer-valued lifting scheme (see <B><A HREF="QccWAVLiftingSchemeInteger.3.html">QccWAVLiftingSchemeInteger</B>(3)</A>
). 
<P>
<B>QccWAVWaveletSynthesis3DInt()</B> performs one level of separable wavelet 
synthesis for a 3DInt signal. Subbands in  <I>volume</I> are assumed to be organized 
as described above for the output of <B>QccWAVWaveletAnalysis3DInt()</B>. <B>QccWAVWaveletSynthesis3DInt()</B> 
calls <B><A HREF="QccWAVWaveletSynthesis1DInt.3.html">QccWAVWaveletSynthesis1DInt</B>(3)</A>
 once for each vector in the temporal 
direction, then <B><A HREF="QccWAVWaveletSynthesis2DInt.3.html">QccWAVWaveletSynthesis2DInt</B>(3)</A>
 for each frame. The result 
of the separable wavelet synthesis is returned in <I>volume</I>. <P>
Note: In general, 
you will probably want to use <B><A HREF="QccWAVWaveletDyadicDWT3DInt.3.html">QccWAVWaveletDyadicDWT3DInt</B>(3)</A>
 and <B><A HREF="QccWAVWaveletInverseDyadicDWT3DInt.3.html">QccWAVWaveletInverseDyadicDWT3DInt</B>(3)</A>
, 
or <B><A HREF="QccWAVWaveletPacketDWT3DInt.3.html">QccWAVWaveletPacketDWT3DInt</B>(3)</A>
 and <B><A HREF="QccWAVWaveletInversePacketDWT3DInt.3.html">QccWAVWaveletInversePacketDWT3DInt</B>(3)</A>
, 
for implementing a discrete wavelet transform and its inverse since these 
routines allow any number of scales, or levels, of decomposition to be 
performed.  
<H2><A NAME="sect3" HREF="#toc3">INTEGER-TO-INTEGER WAVELET TRANSFORMS </A></H2>
Transforms generally provide 
perfect reconstruction in that the inverse transform will perfectly invert 
transform coefficients into an exact representation of the original signal. 
However, when implemented in floating-point arithmetic, the potential for 
loss arises due to the limits of finite precision in both the forward 
and inverse transforms. On the other hand, transforms that map integer-valued 
signals into integer-valued transforms coefficients can guarantee perfect 
reconstruction, provided an inverse transform can be found. For this reason, 
lifting schemes, in which inverse transforms are trivial, are favored 
for the implementation of integer-valued wavelet transforms. Typically, 
the general approach proposed by Calderbank <I>et al</I>. is followed wherein 
rounding of floating-point values to integers is performed at each prediction 
and update step in a lifting scheme. Integer versions of several popular 
biorthogonal wavelets were created in this manner by Calderbank <I>et al</I>., 
as well as by Xiong <I>et al</I>. <P>
In traditional floating-point lifting, the prediction 
and update steps are generally followed by a single application of scaling 
by a constant in order to produce the usual unitary normalization. This 
scaling step is somewhat problematic for integer-valued lifting since the 
scaling constant is usually not an integer. In applications wherein unitary 
scaling is not required (e.g., in some applications that process each subband 
completely independently), the scaling step is simply dropped in order 
to implement an integer-valued version of the transform. Alternatively, 
one can append three additional lifting steps to  implement the scaling; 
these additional lifting steps can then be rendered integer-valued via 
appropriate rounding (e.g., Xiong <I>et al</I>.) making the transforms approximately 
normalized. This latter approach of scaling via additional lifting steps 
is employed in the integer-valued lifting schemes implemented in QccPack. 
 
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE 
ALSO </A></H2>
<B><A HREF="QccWAVWaveletAnalysis1DInt.3.html">QccWAVWaveletAnalysis1DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletSynthesis1DInt.3.html">QccWAVWaveletSynthesis1DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletAnalysis2DInt.3.html">QccWAVWaveletAnalysis2DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletSynthesis2DInt.3.html">QccWAVWaveletSynthesis2DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletDyadicDWT3DInt.3.html">QccWAVWaveletDyadicDWT3DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletInverseDyadicDWT3DInt.3.html">QccWAVWaveletInverseDyadicDWT3DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletPacketDWT3DInt.3.html">QccWAVWaveletPacketDWT3DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletInversePacketDWT3DInt.3.html">QccWAVWaveletInversePacketDWT3DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
<P>
A. R. Calderbank, I. Daubechies, 
W. Sweldens, B.-L. Yeo, "Lossless Image Compression Using Integer to Integer 
Wavelet Transforms", in <I>Proceedings of the International Conference on 
Image Processing</I>, Lausanne, Switzerland, pp. 596-599, September 1997. <P>
 Z. 
Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless Compression of Medical Volumetric 
Data Using Three-Dimensional Integer Wavelet Transforms," <I>IEEE Transactions 
on Medical Imaging</I>, vol. 22, pp. 459-470, March 2003. <P>
 I. Daubechies and W. 
Sweldens, "Factoring Wavelet Transforms Into Lifting Steps," <I>J. Fourier 
Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 1998. <P>
 B.-J. Kim, Z. Xiong, and W. A. Pearlman, 
"Low Bit-Rate Scalable Video Coding with 3-D Set Partitioning in Hierarchical 
Trees (3-D SPIHT)," <I>IEEE Transactions on Circuits and Systems for Video 
Technology</I>, vol. 10, no. 8, pp. 1374-1387, December 2000.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright 
(C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
