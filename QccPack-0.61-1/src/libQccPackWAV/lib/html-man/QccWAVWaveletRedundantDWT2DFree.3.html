<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletRedundantDWT2DFree.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletRedundantDWT2D, QccWAVWaveletInverseRedundantDWT2D, 
QccWAVWaveletRedundantDWT2DSubsample -  redundant discrete wavelet transform 
and inverse transform for a 2D signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccWAVWaveletRedundantDWT2D(const QccMatrix </B><I>input_matrix</I><B>, QccMatrix 
*</B><I>output_matrices</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletInverseRedundantDWT2D(const QccMatrix *</B><I>input_matrices</I><B>, 
QccMatrix </B><I>output_matrix</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>num_scales</I><B>, const 
QccWAVWavelet *</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletRedundantDWT2DSubsample(const 
QccMatrix *</B><I>input_matrices</I><B>, QccMatrix </B><I>output_matrix</I><B>, int </B><I>num_rows</I><B>, int 
</B><I>num_cols</I><B>, int </B><I>num_scales</I><B>, int </B><I>subsample_pattern_row</I><B>, int </B><I>subsample_pattern_col</I><B>, 
const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  <BR>
<B>QccMatrix *QccWAVWaveletRedundantDWT2DAlloc(int 
</B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>num_scales</I><B>);</B>  <BR>
<B>void QccWAVWaveletRedundantDWT2DFree(QccMatrix 
*</B><I>rdwt</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_scales</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletRedundantDWT2D()</B> 
performs a redundant discrete wavelet transform (RDWT) of a two-dimensional 
matrix. <I>num_scales</I> gives the number of scales, or levels, of the decomposition. 
<B>QccWAVWaveletRedundantDWT2D()</B> implements a dyadic decomposition of <I>input_matrix</I> 
with oversampling; that is, the lowpass subband is recursively decomposed 
into lowpass and highpass bands for each level of decomposition. Unlike 
the usual critically sampled DWT (as implemented by <B><A HREF="QccWAVWaveletDWT2D.3.html">QccWAVWaveletDWT2D</B>(3)</A>
), 
each subband has the same size as the original <I>input_matrix</I>; i.e.,  <I>num_rows</I> 
rows and <I>num_cols</I> columns. <P>
During each level or scale of decomposition, 
a baseband, a horizontal, a vertical, and a diagonal subband are produced. 
The baseband subband is then recursively decomposed. Consequently, the 
2D RDWT produces <I>num_scales * 3</I> highpass subbands and one final baseband 
subband, for a total of <I>num_scales * 3 + 1</I> subbands. These subbands are 
returned in <I>output_matrices</I> which is an array of  <I>num_scales * 3 + 1</I> matrices 
each of which having size <I>num_rows</I> rows and  <I>num_cols</I> columns. The first 
entry in the <I>output_matrices</I> array  is the baseband matrix; subsequent 
entries contain highpass bands of decreasing scale (increasing spatial 
resolution) in the order horizontal, vertical, and diagonal. Sufficient 
storage space for <I>output_matrices</I> must be allocated prior to calling <B>QccWAVWaveletRedundantDWT2D()</B>. 
<P>
<I>wavelet</I> can be either a filter-bank or lifting-scheme implementation. In 
either case, the 2D RDWT is implemented as a separable transform in that 
each row is decomposed in a fashion similar to the 1D RDWT implemented 
by <B><A HREF="QccWAVWaveletRedundantDWT1D.3.html">QccWAVWaveletRedundantDWT1D</B>(3)</A>
 followed by a similar 1D decomposition 
along each column. <P>
<B>QccWAVWaveletInverseRedundantDWT2D()</B> performs the inverse 
RDWT of <I>input_matrices</I>. Sufficient space for <I>output_matrix</I> must be allocated 
prior to calling <B>QccWAVWaveletInverseRedundantDWT2D()</B>. <P>
<B>QccWAVWaveletRedundantDWT2DAlloc()</B> 
allocates  <I>num_scales * 3 + 1</I> subband matrices, each of size <I>num_rows</I> 
by <I>num_cols</I>, returning the allocated subbands. <B>QccWAVWaveletRedundantDWT2DFree()</B> 
frees the matrices allocated via <B>QccWAVWaveletRedundantDWT2DAlloc()</B>. <P>
The 
RDWT produces an oversampled wavelet transform; that is, an overcomplete 
expansion of the original signal. However, the coefficients of the usual 
critically sampled DWT are amongst the RDWT coefficients. More accurately, 
there exist <I>4</I> ^ num_scales sets of RDWT coefficients that are identical 
to a critically sampled, dyadic DWT. Each one of these <I>4</I> ^ num_scales DWTs 
differs from the others in the subsampling phase choice (one can choose 
even or odd for both rows and columns) at each level of the transform. 
<B>QccWAVWaveletRedundantDWT2DSubsample()</B> subsamples the coefficients output 
from <B>QccWAVWaveletRedundantDWT2D()</B> to obtain the coefficients for a critically 
sampled DWT. Together, <I>subsample_pattern_row</I> and <I>subsample_pattern_col</I> 
indicate which of the  <I>4</I> ^ num_scales DWT-coefficient sets to choose; the 
resulting critically sampled DWT then consists of the same coefficients 
that would have been produced by a call to <B><A HREF="QccWAVWaveletDWT2D.3.html">QccWAVWaveletDWT2D</B>(3)</A>
 with 
these particular <I>subsample_pattern_row</I> and <I>subsample_pattern_col</I> values. 
<I>subsample_pattern_row</I> and <I>subsample_pattern_col</I> both can take on values 
0 to <I>(2 ^ num_levels) - 1</I> (see <B><A HREF="QccWAVWaveletDWT2D.3.html">QccWAVWaveletDWT2D</B>(3)</A>
). <I>num_scales</I> gives the 
number of levels of decomposition that exist in <I>input_matrices</I>, which 
is assumed to be an array of <I>num_scales * 3 + 1</I> matrices as produced by 
<B>QccWAVWaveletRedundantDWT2D()</B>. The output of  <B>QccWAVWaveletRedundantDWT2DSubsample()</B> 
is a matrix of nested subbands as is present in the <B><A HREF="QccWAVSubbandPyramid.3.html">QccWAVSubbandPyramid</B>(3)</A>
 
structure. Sufficient space for <I>output_matrix</I> must be allocated prior to 
calling <B>QccWAVWaveletInverseRedundantDWT2DSubsample()</B>. <P>
<B>QccWAVWaveletInverseRedundantDWT2D()</B> 
is the "proper" procedure for inverting the RDWT. That is, <B>QccWAVWaveletInverseRedundantDWT2D()</B> 
performs inverse filtering as well as weighted "averaging" of the transform 
redundancies  to properly reconstruct the original signal from the RDWT 
coefficients. A "quick and dirty" reconstruction is possible, however, 
by subsampling and then inverting using the critically sampled inverse 
DWT, i.e., by calling <B>QccWAVWaveletRedundantDWT2DSubsample()</B> and then <B>QccWAVWaveletInverseDWT2D()</B>. 
Both these approaches to inverting the RDWT will produce the same results 
on unaltered RDWT coefficients; however, should the RDWT coefficients 
be processed in some fashion, say, through quantization, then <B>QccWAVWaveletInverseRedundantDWT2D()</B> 
should be used to invert the transform. Additionally, this subsampling 
approach to inverting the RDWT works only for <I>subsample_pattern</I> = 0, which 
is the only subsampling pattern whose phase choices match those assumed 
by <B>QccWAVWaveletInverseDWT2D()</B>.  
<H2><A NAME="sect3" HREF="#toc3">NOTES </A></H2>
The notion of an RDWT apparently 
dates back to the work of  Holschneider <I>et al</I>. and Dutilleux who devised 
a redundant transform implemented via the so-called <I>algorithme a trous</I>. 
This filter-bank algorithm is similar to the usual Mallat algorithm for 
the critically sampled DWT in that it implements the wavelet transform 
with filter banks. The key difference between the two approaches is that 
the subsampling at the end of every scale of the transform as used in 
the Mallat algorithm is not performed in the <I>algorithm a trous</I>, and the 
filters, which are the same at every scale in the Mallat algorithm, change 
for every scale. Specifically, the <I>algorithm a trous</I> calls for the insertion 
of "holes" ("trous" in French) between each filter tap; that is, the filters 
used in each scale of the <I>algorithm a trous</I> decomposition are the filters 
of the previous scale upsampled by a factor of 2. <P>
Shensa points out that 
the Mallat and  <I>a trous</I> implementations are very closely related;  in 
fact, it is possible to obtain the coefficients for the Mallat algorithm 
by subsampling, or decimating, the coefficients resulting from the <I>algorithm 
a trous</I>, except possibly at the matrix boundaries when symmetric extension 
is used. This observation leads to an "alternative" implementation of the 
<I>algorithm a trous</I>, and it is this implementation that is used here in 
<B>QccWAVWaveletRedundantDWT2D()</B>. This alternative implementation of the <I>algorithm 
a trous</I> eliminates the above-mentioned symmetric-boundary inconsistencies; 
in addition, the alternative implementation permits the direct use of 
lifting instead of filter banks for improved computation efficiency.  
<H2><A NAME="sect4" HREF="#toc4">RETURN 
VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE ALSO </A></H2>
<B><A HREF="QccWAVWaveletRedundantDWT1D.3.html">QccWAVWaveletRedundantDWT1D</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletDWT2D.3.html">QccWAVWaveletDWT2D</B>(3)</A>
, <B><A HREF="QccWAVWaveletInverseDWT2D.3.html">QccWAVWaveletInverseDWT2D</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 
<P>
M. Holschneider, R. Kronland-Martinet, J. Morlet, and P. Tchamitchian, "A Real-Time 
Algorithm for Signal Analysis with the Help of the Wavelet Transform," 
in <I>Wavelets: Time-Frequency Methods and Phase Space</I>, Berlin: Springer-Verlag, 
pp. 286-297, 1989. <P>
P. Dutilleux, "An Implementation of the Algorithm A Trous 
to Compute the Wavelet Transform," in <I>Wavelets: Time-Frequency Methods 
and Phase Space</I>, Berlin: Springer-Verlag, pp. 298-304, 1989. <P>
M. J. Shensa, "The 
Discrete Wavelet Transform: Wedding the A Trous and Mallat Algorithms," 
<I>IEEE Trans. Signal Processing</I>, vol. 40, no. 10, pp. 2464-2482, Oct. 1998.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR 
</A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">NOTES</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
