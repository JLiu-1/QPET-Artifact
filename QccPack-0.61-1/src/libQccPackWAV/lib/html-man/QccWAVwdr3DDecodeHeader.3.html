<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVwdr3DDecodeHeader.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVwdr3DEncode, QccWAVwdr3DDecode - encode/decode an image cube 
using the 3D-WDR algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVwdr3DEncode(const 
QccIMGImageCube *</B><I>image_cube</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
QccBitBuffer *</B><I>output_buffer</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  <P>
<B>int QccWAVwdr3DDecodeHeader(QccBitBuffer 
*</B><I>input_buffer</I><B>, int *</B><I>transform_type</I><B>, int *</B><I>temporal_num_levels</I><B>, int *</B><I>spatial_num_levels</I><B>, 
int *</B><I>num_frames</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int 
*</B><I>max_coefficient_bits</I><B>);</B>  <P>
<B>int QccWAVwdr3DDecode(QccBitBuffer *</B><I>input_buffer</I><B>, 
QccIMGImageCube *</B><I>image_cube</I><B>, const QccIMGImageCube *</B><I>mask</I><B>, int </B><I>transform_type</I><B>, 
int </B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
double </B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_bit</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVwdr3DEncode()</B> encodes an image cube, <I>image_cube</I>, using 
a 3D generalization of the WDR algorithm. The original WDR algorithm was 
developed for 2D images by Tian and Wells; it was latter extended to 3D 
by Rucker and Fowler. In essence, the 3D-WDR algorithm involves a 3D DWT 
followed by  a progressive "bitplane" coding of the wavelet coefficients 
involving a form of runlength coding of significance information. <P>
<I>image_cube</I> 
is the image cube to be coded and <I>output_buffer</I> is the output bitstream. 
<I>output_buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> type and opened via a prior 
call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccWAVwdr3DEncode</B>() supports the use of both 
wavelet-packet and dyadic wavelet-transform decompositions. If <I>transform_type</I> 
is <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B>, a dyadic DWT is used; if <I>transform_type</I> 
is <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B>, a wavelet-packet DWT is used. <I>temporal_num_levels</I> 
and <I>spatial_num_levels</I> give the number of levels of wavelet decomposition 
to perform for both transform types; for a dyadic transform, <I>temporal_num_levels</I> 
should equal <I>spatial_num_levels</I>. <I>wavelet</I> is the wavelet to use for decomposition. 
<P>
The bitstream output from the 3D-WDR encoder is embedded, meaning that 
any prefix of the bitstream can be decoded to give a valid  representation 
of the image.  The 3D-WDR encoder essentially produces output bits until 
the number of bits output reaches <I>target_bit_cnt</I>, the desired (target) 
total length of the output bitstream in bits, and then it stops. Note that 
this is the bitstream length in bits, not the rate of the bitstream (which 
would be expressed in bits per voxel). <P>
<B>QccWAVwdr3DEncode()</B> optionally supports 
the use of a shape-adaptive DWT (SA-DWT) rather than the usual DWT. That 
is,  <B>QccWAVwdr3DEncode()</B> can call <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
as the wavelet transform rather than the usual <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
. 
The use of a SA-DWT is indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then 
the usual DWT is used. In the case of a SA-DWT, <I>mask</I>  gives the transparency 
mask which indicates which voxels of the image are non-transparent and 
thus have data that is to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
 
for more details on the calculation of this SA-DWT. The wavelet transform 
is essentially the only component of the 3D-WDR algorithm that is affected 
by the shape-adaptive nature of the processing. That is, transparent regions 
in the image are effectively skipped over when the 3D-WDR algorithm is 
initialized; i.e., transparent coefficients are not added to the lists of 
coefficients when the lists are created. Thus, the transparent coefficients 
are not counted in the calculation of runlengths.  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVwdr3DDecodeHeader()</B> 
decodes the header information  in a bitstream previously produced by 
<B>QccWAVwdr3DEncode()</B>. The input bitstream is <I>input_buffer</I> which must be 
of <B>QCCBITBUFFER_INPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. 
<P>
The header information is returned in <I>transform_type</I> (either <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B> 
or <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B> to indicate a dyadic or wavelet-packet 
transform decomposition, respectively), <I>temporal_num_levels</I> (number of 
levels of wavelet decomposition in the temporal direction), <I>spatial_num_levels</I> 
(number of levels of wavelet decomposition in the spatial directions), 
<I>num_frames</I> (size of the image cube in the temporal direction), <I>num_rows</I> 
(vertical size of image cube), <I>num_cols</I> (horizontal size of image cube), 
<I>image_mean</I> (the mean value of the original image cube), and <I>max_coefficient_bits</I> 
(indicates the precision, in number of bits, of the wavelet coefficient 
with the largest magnitude). <P>
<B>QccWAVwdr3DDecode()</B> decodes the bitstream 
<I>input_buffer</I>, producing the reconstructed image cube, <I>image_cube</I>. The bitstream 
must already have had its header read by a prior call to <B>QccWAVwdr3DDecodeHeader()</B> 
(i.e., you call <B>QccWAVwdr3DDecodeHeader() </B> first and then <B>QccWAVwdr3DDecode()</B>). 
If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, then decoding stops when the end 
of the input bitstream is reached; otherwise, decoding stops when <I>target_num_bits</I> 
from the input bitstream have been decoded. <P>
If a SA-DWT was used in 3D-WDR 
encoding, then the original transparency mask should be passed to  <B>QccWAVwdr3DDecode()</B> 
as <I>mask</I>. That is, <I>mask</I> should be the same transparency mask (untransformed) 
 that was passed to <B>QccWAVwdr3DEncode()</B>. Note that <B>QccWAVwdr3DDecode()</B> 
will transform this <I>mask</I> via a Lazy wavelet transform, and then pass the 
transformed mask to  <B><A HREF="QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DInverseShapeAdaptiveDWT</B>(3)</A>
. 
If the usual, full-volume DWT was used in encoding, then <I>mask</I> should be 
a NULL pointer.  
<H2><A NAME="sect5" HREF="#toc5">SEE ALSO </A></H2>
<B><A HREF="wdrencode3d.1.html">wdrencode3d</B>(1)</A>
, <B><A HREF="wdrdecode3d.1.html">wdrdecode3d</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3D.3.html">QccWAVSubbandPyramid3D</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DShapeAdaptiveDWT.3.html">QccWAVSubbandPyramid3DShapeAdaptiveDWT</B>(3)</A>
, 
<B><A HREF="QccWAVwdrEncode.3.html">QccWAVwdrEncode</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 J. Tian and 
R. O. Wells, Jr., "Embedded Image Coding Using Wavelet Difference Reduction", 
in <I>Wavelet Image and Video Compression</I>,<I></I> P. N. Topiwala, Ed., pp. 289-302, Kluwer 
Academic Publishers, Norwell, MA, 1998. <P>
  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Written by Justin Rucker 
based on the 2D-WDR implementation by Yufei Yuan. <P>
 Copyright (C) 1997-2016 
 James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
