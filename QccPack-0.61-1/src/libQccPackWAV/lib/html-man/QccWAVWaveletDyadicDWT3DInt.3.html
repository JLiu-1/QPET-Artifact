<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletDyadicDWT3DInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletDyadicDWT3DInt, QccWAVWaveletInverseDyadicDWT3DInt 
-  integer-valued separable dyadic 3D discrete wavelet transform and inverse 
transform for a 3D signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVWaveletDyadicDWT3DInt(QccVolumeInt 
</B><I>volume</I><B>, int </B><I>num_frames</I><B>, int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>origin_frame</I><B>, 
int </B><I>origin_row</I><B>, int </B><I>origin_col</I><B>, int </B><I>subsample_pattern_frame</I><B>, int </B><I>subsample_pattern_row</I><B>, 
int </B><I>subsample_pattern_col</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B> 
 <P>
<B>int QccWAVWaveletInverseDyadicDWT3DInt(QccVolumeInt </B><I>volume</I><B>, int </B><I>num_frames</I><B>, 
int </B><I>num_rows</I><B>, int </B><I>num_cols</I><B>, int </B><I>origin_frame</I><B>, int </B><I>origin_row</I><B>, int </B><I>origin_col</I><B>, 
int </B><I>subsample_pattern_frame</I><B>, int </B><I>subsample_pattern_row</I><B>, int </B><I>subsample_pattern_col</I><B>, 
int </B><I>num_scales</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletDyadicDWT3DInt()</B> 
performs an integer-valued separable dyadic 3D discrete wavelet transform 
(DWT) of a three-dimensional signal, <I>volume</I>, which is represented as a 
volume of <I>num_frames</I> frames, <I>num_rows</I> rows, and <I>num_cols</I> columns. <I>origin_frame</I>, 
<I>origin_row</I>, and <I>origin_col</I> indicates the frame, row, and column indices, 
respectively, of the upper corner of the image cube. Usually, one assumes 
that the upper corner of the image cube is indexed as (0, 0, 0) - in this 
case,  <I>origin_frame</I>, <I>origin_row</I>, and <I>origin_col</I> would all be zero. <I>num_scales</I> 
gives the number of scales, or levels, of the decomposition. <B>QccWAVWaveletDyadicDWT3DInt()</B> 
implements a dyadic, or octave, decomposition of <I>volume</I>; that is, the 
low-low-low subband (baseband) is recursively decomposed into one lowpass 
band and seven highpass bands for each level of decomposition, each of 
which being one eighth the size of the baseband that was decomposed. <B>QccWAVWaveletDyadicDWT3DInt()</B> 
calls <B><A HREF="QccWAVWaveletAnalysis3DInt.3.html">QccWAVWaveletAnalysis3DInt</B>(3)</A>
 for each level of decomposition, using 
the baseband subband for the current level of decomposition as input. As 
a result, the transform recursively decomposes the upper corner of the 
input volume. <I>wavelet</I> must indicate an integer-valued lifting scheme (see 
<B><A HREF="QccWAVLiftingSchemeInteger.3.html">QccWAVLiftingSchemeInteger</B>(3)</A>
). <P>
<B>QccWAVWaveletInverseDyadicDWT3DInt()</B> performs 
the corresponding separable dyadic 3D inverse DWT of <I>volume</I> which is assumed 
to have been produced by <B>QccWAVWaveletDyadicDWT3DInt()</B>. <I>num_scales</I> gives 
the number of levels of decomposition that exist in <I>volume</I>. <B>QccWAVWaveletInverseDyadicDWT3DInt()</B> 
calls <B><A HREF="QccWAVWaveletSynthesis3DInt.3.html">QccWAVWaveletSynthesis3DInt</B>(3)</A>
 for each level of synthesis. <P>
<I>subsample_pattern_frame</I>, 
<I>subsample_pattern_row</I>, and <I>subsample_pattern_col</I> indicate the even- or 
odd-phase subsampling to be used at each level of frame, row, and column 
decomposition. In most applications, even subsampling at all levels is 
desired, in which case  <I>subsample_pattern_frame</I>, <I>subsample_pattern_row</I>, 
and <I>subsample_pattern_col</I> should all be set to zero. In more general settings, 
when some mixture of even- and odd-phase subsampling is desired,  <I>subsample_pattern_frame</I>, 
<I>subsample_pattern_row</I>, and <I>subsample_pattern_col</I> can be integers between 
0 and <I>(2 ^ num_levels) - 1</I>. In these integers, the  <I>j</I>th bit (where <I>j</I> = 1 
is the least-significant bit) indicates whether the <I>j</I>th level of decomposition 
employs even or odd subsampling (0 = even, 1 = odd). For example, if <I>subsample_pattern_row</I> 
is 5, then the first and third row decompositions use odd-phase subsampling, 
while all others use even subsampling. <P>
Use <B><A HREF="QccWAVSubbandPyramid3DIntDWT.3.html">QccWAVSubbandPyramid3DIntDWT</B>(3)</A>
 
and <B><A HREF="QccWAVSubbandPyramid3DIntInverseDWT.3.html">QccWAVSubbandPyramid3DIntInverseDWT</B>(3)</A>
 to perform a separable dyadic 
3D DWT or inverse DWT on a <B>QccWAVSubbandPyramid3DInt</B> data structure (which 
is the recommended way to do it, since the <B>QccWAVSubbandPyramid3DInt</B> structure 
stores the number of levels of decomposition along with the transform 
coefficients).  
<H2><A NAME="sect3" HREF="#toc3">INTEGER-TO-INTEGER WAVELET TRANSFORMS </A></H2>
Transforms generally 
provide perfect reconstruction in that the inverse transform will perfectly 
invert transform coefficients into an exact representation of the original 
signal. However, when implemented in floating-point arithmetic, the potential 
for loss arises due to the limits of finite precision in both the forward 
and inverse transforms. On the other hand, transforms that map integer-valued 
signals into integer-valued transforms coefficients can guarantee perfect 
reconstruction, provided an inverse transform can be found. For this reason, 
lifting schemes, in which inverse transforms are trivial, are favored 
for the implementation of integer-valued wavelet transforms. Typically, 
the general approach proposed by Calderbank <I>et al</I>. is followed wherein 
rounding of floating-point values to integers is performed at each prediction 
and update step in a lifting scheme. Integer versions of several popular 
biorthogonal wavelets were created in this manner by Calderbank <I>et al</I>., 
as well as by Xiong <I>et al</I>. <P>
In traditional floating-point lifting, the prediction 
and update steps are generally followed by a single application of scaling 
by a constant in order to produce the usual unitary normalization. This 
scaling step is somewhat problematic for integer-valued lifting since the 
scaling constant is usually not an integer. In applications wherein unitary 
scaling is not required (e.g., in some applications that process each subband 
completely independently), the scaling step is simply dropped in order 
to implement an integer-valued version of the transform. Alternatively, 
one can append three additional lifting steps to  implement the scaling; 
these additional lifting steps can then be rendered integer-valued via 
appropriate rounding (e.g., Xiong <I>et al</I>.) making the transforms approximately 
normalized. This latter approach of scaling via additional lifting steps 
is employed in the integer-valued lifting schemes implemented in QccPack. 
 
<H2><A NAME="sect4" HREF="#toc4">RETURN VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE 
ALSO </A></H2>
<B><A HREF="QccWAVWaveletAnalysis3DInt.3.html">QccWAVWaveletAnalysis3DInt</B>(3)</A>
, <B><A HREF="QccWAVWaveletSynthesis3DInt.3.html">QccWAVWaveletSynthesis3DInt</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DIntDWT.3.html">QccWAVSubbandPyramid3DIntDWT</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3DIntInverseDWT.3.html">QccWAVSubbandPyramid3DIntInverseDWT</B>(3)</A>
, <B><A HREF="QccWAVWaveletPacketDWT3DInt.3.html">QccWAVWaveletPacketDWT3DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletInversePacketDWT3DInt.3.html">QccWAVWaveletInversePacketDWT3DInt</B>(3)</A>
, <B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, 
<B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, "Lossless 
Image Compression Using Integer to Integer Wavelet Transforms", in <I>Proceedings 
of the International Conference on Image Processing</I>, Lausanne, Switzerland, 
pp. 596-599, September 1997. <P>
 Z. Xiong, X. Wu, S. Cheng, J. Hua, "Lossy-to-Lossless 
Compression of Medical Volumetric Data Using Three-Dimensional Integer 
Wavelet Transforms," <I>IEEE Transactions on Medical Imaging</I>, vol. 22, pp. 
459-470, March 2003. <P>
 I. Daubechies and W. Sweldens, "Factoring Wavelet Transforms 
Into Lifting Steps," <I>J. Fourier Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 1998. 
<P>
 B.-J. Kim, Z. Xiong, and W. A. Pearlman, "Low Bit-Rate Scalable Video Coding 
with 3-D Set Partitioning in Hierarchical Trees (3-D SPIHT)," <I>IEEE Transactions 
on Circuits and Systems for Video Technology</I>, vol. 10, no. 8, pp. 1374-1387, 
December 2000.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
