<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletInverseRedundantDWT1D.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletRedundantDWT1D, QccWAVWaveletInverseRedundantDWT1D, 
QccWAVWaveletRedundantDWT1DSubsample -  redundant discrete wavelet transform 
and inverse transform for a 1D signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccWAVWaveletRedundantDWT1D(const QccVector </B><I>input_signal</I><B>, QccMatrix 
</B><I>output_signals</I><B>, int </B><I>signal_length</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletInverseRedundantDWT1D(const QccMatrix </B><I>input_signals</I><B>, 
QccVector </B><I>output_signal</I><B>, int </B><I>signal_length</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletRedundantDWT1DSubsample(const QccMatrix </B><I>input_signals</I><B>, 
QccVector </B><I>output_signal</I><B>, int </B><I>signal_length</I><B>, int </B><I>num_scales</I><B>, int </B><I>subsample_pattern</I><B>, 
const QccWAVWavelet *</B><I>wavelet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletRedundantDWT1D()</B> 
performs a redundant discrete wavelet transform (RDWT) of a one-dimensional 
signal. <I>num_scales</I> gives the number of scales, or levels, of the decomposition. 
<B>QccWAVWaveletRedundantDWT1D()</B> implements a dyadic decomposition of <I>input_signal</I> 
with oversampling; that is, the lowpass subband is recursively decomposed 
into lowpass and highpass bands for each level of decomposition. Unlike 
the usual critically sampled DWT (as implemented by <B><A HREF="QccWAVWaveletDWT1D.3.html">QccWAVWaveletDWT1D</B>(3)</A>
), 
each subband has the same length as the original <I>input_signal</I>. <P>
The RDWT 
produces  <I>num_scales</I> highpass subbands and one baseband subband, for a 
total of <I>num_scales</I> + 1 subbands. These subbands are returned in <I>output_signals</I> 
which is a matrix with  <I>num_scales + 1</I> rows and  <I>signal_length</I> columns. 
The first row of <I>output_signals</I> contains the baseband signal; subsequent 
rows contain highpass bands of decreasing scale (increasing spatial resolution). 
Sufficient storage space for <I>output_signals</I> must be allocated prior to 
calling <B>QccWAVWaveletRedundantDWT1D()</B>. <P>
<I>wavelet</I> can be either a filter-bank 
or lifting-scheme implementation. <P>
<B>QccWAVWaveletInverseRedundantDWT1D()</B> performs 
the inverse RDWT of <I>input_signals</I>. Sufficient space for <I>output_signal</I> must 
be allocated prior to calling <B>QccWAVWaveletInverseRedundantDWT1D()</B>. <P>
The 
RDWT produces an oversampled DWT transform; that is, an overcomplete expansion 
of the original signal. However, the coefficients of the usual critically 
sampled DWT are amongst the RDWT coefficients. More accurately, there exist 
<I>2</I> ^ num_scales sets of RDWT coefficients that are identical to a critically 
sampled, dyadic DWT. Each one of these <I>2</I> ^ num_scales DWTs differs from 
the others in the subsampling phase choice (even or odd) at each level 
of the transform. <B>QccWAVWaveletRedundantDWT1DSubsample()</B> subsamples the 
coefficients output from <B>QccWAVWaveletRedundantDWT1D()</B> to obtain the coefficients 
for a critically sampled DWT. <I>subsample_pattern</I>, a value from 0 to (<I>2 ^ 
num_scales</I>)<I> - 1</I>,<I></I> indicates which of the <I>2</I> ^ num_scales DWT-coefficient sets 
to choose. <I>num_scales</I> gives the number of levels of decomposition that 
exist in <I>input_signals</I>, which is assumed to be a matrix of <I>num_scales</I> 
+ 1 rows and <I>signal_length</I> columns produced by <B>QccWAVWaveletRedundantDWT1D()</B>. 
Sufficient space for <I>output_signal</I> must be allocated prior to calling 
<B>QccWAVWaveletRedundantDWT1DSubsample()</B>. Calling <B>QccWAVWaveletRedundantDWT1DSubsample()</B> 
with  <I>subsample_pattern</I> = 0 will produce the same coefficients as would 
have been produced by <B>QccWAVWaveletDWT1D().</B> <P>
<B>QccWAVWaveletInverseRedundantDWT1D()</B> 
is the "proper" procedure for inverting the RDWT. That is, <B>QccWAVWaveletInverseRedundantDWT1D()</B> 
performs inverse filtering as well as weighted "averaging" of the transform 
redundancies  to properly reconstruct the original signal from the RDWT 
coefficients. A "quick and dirty" reconstruction is possible, however, 
by subsampling and then inverting using the critically sampled inverse 
DWT, i.e., by calling <B>QccWAVWaveletRedundantDWT1DSubsample()</B> and then <B>QccWAVWaveletInverseDWT1D()</B>. 
Both these approaches to inverting the RDWT will produce the same results 
on unaltered RDWT coefficients; however, should the RDWT coefficients 
be processed in some fashion, say, through quantization, then <B>QccWAVWaveletInverseRedundantDWT1D()</B> 
should be used to invert the transform. Additionally, this subsampling 
approach to inverting the RDWT works only for  <I>subsample_pattern</I> = 0, 
which is the only subsampling pattern whose phase choices match those 
assumed by <B>QccWAVWaveletInverseDWT1D()</B>.  
<H2><A NAME="sect3" HREF="#toc3">NOTES </A></H2>
The notion of an RDWT apparently 
dates back to the work of  Holschneider <I>et al</I>. and Dutilleux who devised 
a redundant transform implemented via the so-called <I>algorithme a trous</I>. 
This filter-bank algorithm is similar to the usual Mallat algorithm for 
the critically sampled DWT in that it implements the wavelet transform 
with filter banks. The key difference between the two approaches is that 
the subsampling at the end of every scale of the transform as used in 
the Mallat algorithm is not performed in the <I>algorithm a trous</I>, and the 
filters, which are the same at every scale in the Mallat algorithm, change 
for every scale. Specifically, the <I>algorithm a trous</I> calls for the insertion 
of "holes" ("trous" in French) between each filter tap; that is, the filters 
used in each scale of the <I>algorithm a trous</I> decomposition are the filters 
of the previous scale upsampled by a factor of 2. <P>
Shensa points out that 
the Mallat and  <I>a trous</I> implementations are very closely related;  in 
fact, it is possible to obtain the coefficients for the Mallat algorithm 
by subsampling, or decimating, the coefficients resulting from the <I>algorithm 
a trous</I>, except possibly at the signal boundaries when symmetric extension 
is used. This observation leads to an "alternative" implementation of the 
<I>algorithm a trous</I>, and it is this implementation that is used here in 
<B>QccWAVWaveletRedundantDWT1D()</B>. This alternative implementation of the <I>algorithm 
a trous</I> eliminates the above-mentioned symmetric-boundary inconsistencies; 
in addition, the alternative implementation permits the direct use of 
lifting instead of filter banks for improved computation efficiency.  
<H2><A NAME="sect4" HREF="#toc4">RETURN 
VALUES </A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect5" HREF="#toc5">SEE ALSO </A></H2>
<B><A HREF="QccWAVWaveletDWT1D.3.html">QccWAVWaveletDWT1D</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletInverseDWT1D.3.html">QccWAVWaveletInverseDWT1D</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
M. Holschneider, 
R. Kronland-Martinet, J. Morlet, and P. Tchamitchian, "A Real-Time Algorithm 
for Signal Analysis with the Help of the Wavelet Transform," in <I>Wavelets: 
Time-Frequency Methods and Phase Space</I>, Berlin: Springer-Verlag, pp. 286-297, 
1989. <P>
P. Dutilleux, "An Implementation of the Algorithm A Trous to Compute 
the Wavelet Transform," in <I>Wavelets: Time-Frequency Methods and Phase Space</I>, 
Berlin: Springer-Verlag, pp. 298-304, 1989. <P>
M. J. Shensa, "The Discrete Wavelet 
Transform: Wedding the A Trous and Mallat Algorithms," <I>IEEE Trans. Signal 
Processing</I>, vol. 40, no. 10, pp. 2464-2482, Oct. 1998.  
<H2><A NAME="sect6" HREF="#toc6">AUTHOR </A></H2>
Copyright (C) 
1997-2016  James E. Fowler <P>
 <P>
 <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">NOTES</A></LI>
<LI><A NAME="toc4" HREF="#sect4">RETURN VALUES</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SEE ALSO</A></LI>
<LI><A NAME="toc6" HREF="#sect6">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
