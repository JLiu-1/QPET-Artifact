<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVwdrEncode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVwdrEncode, QccWAVwdrDecode - encode/decode an image using the 
wavelet-difference-reduction (WDR) algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B> 
 <P>
<B>int QccWAVwdrEncode(const QccIMGImageComponent *</B><I>image</I><B>, const QccIMGImageComponent 
*</B><I>mask</I><B>, QccBitBuffer *</B><I>buffer</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, 
const QccWAVPerceptualWeights *</B><I>perceptual_weights</I><B>, int </B><I>target_bit_cnt</I><B>);</B> 
 <BR>
<B>int QccWAVwdrDecodeHeader(QccBitBuffer *</B><I>buffer</I><B>, int *</B><I>num_levels</I><B>, int 
*</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int *</B><I>max_coefficient_bits</I><B>);</B> 
 <BR>
<B>int QccWAVwdrDecode(QccBitBuffer *</B><I>buffer</I><B>, QccIMGImageComponent *</B><I>image</I><B>, 
const QccIMGImageComponent *</B><I>mask</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>, const QccWAVPerceptualWeights *</B><I>perceptual_weights</I><B>, double </B><I>image_mean</I><B>, 
int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding 
</A></H3>
<P>
<B>QccWAVwdrEncode()</B> encodes an image component, <I>image</I>, using the WDR algorithm 
by Tian and Wells. The WDR algorithm involves a 2D-DWT followed by a progressive 
encoding of the bitplanes of wavelet coefficients. The encoding of each 
bitplane involves significance-map coding and refinement-bits coding. Significance-map 
coding encodes the significance of a wavelet coefficient against a given 
threshold. In WDR, the two-dimensional wavelet pyramid is first mapped into 
a one-dimensional array according to a scanning order. Each entry in the 
array is assigned an index. The difference between the indices of two significant 
coefficients is encoded using index coding. The sign of the significant 
coefficient is also encoded in significance-map coding. The output symbol 
stream of significance-map coding is entropy-encoded using arithmetic coding 
with a 4-symbol context, i.e. <B>0</B>,<B> 1</B>,<B> +</B>,<B> -</B>. <P>
Refinement-bits coding encodes the 
refining bits of significant coefficients detected before the current 
bitplane. The output symbol stream is entropy-encoded using arithmetic coding 
with a 2-symbol context, i.e. <B>0 </B>and<B> 1</B>. <P>
<I>image</I> is the image component to be 
coded, <I>mask</I> is the mask for the image object (see below), <I>buffer</I> is the 
output bitstream following arithmetic coding (must be of <B>QCCBITBUFFER_OUTPUT</B> 
type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
), <I>num_levels</I> 
gives the number of levels of dyadic wavelet decomposition to perform, 
<I>wavelet</I> is the wavelet to use for decomposition, <I>perceptual_weights</I> is 
the optional perceptual weights to employ (see <B><A HREF="QccWAVPerceptualWeights.3.html">QccWAVPerceptualWeights</B>(3)</A>
; 
use <B>NULL</B> for no perceptual weighting). <I>target_bit_cnt</I> is the bit budget 
as an integer. <P>
<B>QccWAVwdrEncode()</B> optionally supports the use of a shape-adaptive 
DWT (SA-DWT) rather than the usual DWT. That is,  <B>QccWAVwdrEncode()</B> can 
call <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 as the wavelet transform 
rather than the usual <B><A HREF="QccWAVSubbandPyramidDWT.3.html">QccWAVSubbandPyramidDWT</B>(3)</A>
. The use of a SA-DWT is 
indicated by a non-NULL <I>mask</I>; if  <I>mask</I> is NULL, then the usual DWT is used. 
In the case of a SA-DWT, <I>mask</I>  gives the transparency mask which indicates 
which pixels of the image are non-transparent and thus have data that is 
to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 for 
more details on the calculation of this SA-DWT. The wavelet transform is 
essentially the only component of the WDR algorithm that is affected by 
the shape-adaptive nature of the processing. That is, transparent regions 
in the image are effectively skipped over when the WDR algorithm is initialized; 
i.e., transparent coefficients are not added to the lists of coefficients 
when the lists are created. Thus, the transparent coefficients are not 
counted in the calculation of runlengths. Note that the concept of shape-adaptive 
coding arose in the recent MPEG-4 standard and was not considered in the 
original work by Tian and Wells.  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVwdrDecodeHeader()</B> decodes 
the header information in the bitstream in the input <I>buffer</I> (which must 
be of <B>QCCBITBUFFER_INPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
). 
The header information is returned in <I>num_levels</I> (number of levels of 
wavelet decomposition), <I>num_rows</I> (vertical size of image), <I>num_cols</I> (horizontal 
size of image), <I>image_mean</I> (the mean value of the original image), and 
<I>max_coefficient_bits</I> (the number of bits used to represent the magnitude 
of the coefficient with largest absolute value). <P>
<B>QccWAVwdrDecode()</B> decodes 
the bitstream <I>buffer</I>, producing the reconstructed image component, <I>image</I>. 
The bitstream must already have had its header read by a prior call to 
<B>QccWAVwdrDecodeHeader()</B> (i.e., you call <B>QccWAVwdrDecodeHeader() </B> first and 
then <B>QccWAVwdrDecode()</B>). If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, then decoding 
stops when the end of the input bitstream is reached; otherwise, decoding 
stops when <I>target_num_bits</I> from the input bitstream have been decoded. 
<P>
If a SA-DWT was used in WDR encoding, then the original transparency mask 
should be passed to  <B>QccWAVwdrDecode()</B> as <I>mask</I>. That is, <I>mask</I> should be 
the same transparency mask (in the spatial domain) that was passed to 
<B>QccWAVwdrEncode()</B>. Note that <B>QccWAVwdrDecode()</B> will transform this <I>mask</I> 
via a Lazy wavelet transform, and then pass the transformed mask to  <B><A HREF="QccWAVSubbandPyramidInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidInverseShapeAdaptiveDWT</B>(3)</A>
. 
If the usual DWT was used in encoding, then <I>mask</I> should be a NULL pointer. 
 
<H2><A NAME="sect5" HREF="#toc5">NOTES </A></H2>
The WDR algorithm as described originally by Tian and Wells does 
not employ perceptual weighting or shape-adaptive coding.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="wdrencode.1.html">wdrencode</B>(1)</A>
, 
<B><A HREF="wdrdecode.1.html">wdrdecode</B>(1)</A>
, <B><A HREF="imgdwt.1.html">imgdwt</B>(1)</A>
, <B><A HREF="imgdist.1.html">imgdist</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccENTArithmeticEncode.3.html">QccENTArithmeticEncode</B>(3)</A>
, 
<B><A HREF="QccENTArithmeticDecode.3.html">QccENTArithmeticDecode</B>(3)</A>
, <B><A HREF="QccWAVPerceptualWeights.3.html">QccWAVPerceptualWeights</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid.3.html">QccWAVSubbandPyramid</B>(3)</A>
, 
<B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 J. Tian and R. O. Wells, Jr., "Embedded 
Image Coding Using Wavelet Difference Reduction", in <I>Wavelet Image and 
Video Compression</I>,<I></I> P. N. Topiwala, Ed., pp. 289-302, Kluwer Academic Publishers, 
Norwell, MA, 1998. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Written by Yufei Yuan &lt;yuanyufei@hotmail.com&gt; 
<P>
 Copyright (C) 1997-2016  James E. Fowler <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">NOTES</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
