<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVWaveletInverseShapeAdaptiveDWT1DInt.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVWaveletShapeAdaptiveDWT1DInt, QccWAVWaveletInverseShapeAdaptiveDWT1DInt 
-  integer-valued shape-adaptive discrete wavelet transform and inverse transform 
for a 1D signal  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVWaveletShapeAdaptiveDWT1DInt(QccVectorInt 
</B><I>signal</I><B>, QccVectorInt </B><I>mask</I><B>, int </B><I>signal_length</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>);</B>  <BR>
<B>int QccWAVWaveletInverseShapeAdaptiveDWT1DInt(QccVectorInt 
</B><I>signal</I><B>, QccVectorInt </B><I>mask</I><B>, int </B><I>signal_length</I><B>, int </B><I>num_scales</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B> performs 
an integer-valued shape-adaptive discrete wavelet transform (SA-DWT) of a 
one-dimensional signal. <I>num_scales</I> gives the number of scales, or levels, 
of the decomposition. <B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B> implements a 
dyadic decomposition of <I>signal</I>; that is, the lowpass subband is recursively 
decomposed into lowpass and highpass bands for each level of decomposition. 
The output of the SA-DWT is returned in <I>signal</I>, overwriting the original 
input signal. The output subbands reside in  <I>signal</I> starting with the lowpass 
subband of the lowest (coarsest) level of decomposition (i.e., the baseband) 
with subsequent highpass subbands of increasing resolution following. <I>wavelet</I> 
must indicate an integer-valued lifting scheme (see <B><A HREF="QccWAVLiftingSchemeInteger.3.html">QccWAVLiftingSchemeInteger</B>(3)</A>
). 
<P>
<I>mask</I> indicates where the original input <I>signal</I> exists. That is,  <I>mask</I> indicates 
the intervals of support in the original input <I>signal</I>. Where <I>mask</I> is less 
than or equal to <B>QCCALPHA_TRANSPARENT</B>, there is no signal, and where <I>mask</I> 
is greater than <B>QCCALPHA_TRANSPARENT</B>, the signal exists and is transformed 
(see <B><A HREF="QccAlpha.3.html">QccAlpha</B>(3)</A>
). Essentially this shape-adaptive transform is performed 
by identifying contiguous non-transparent segments of the input signal, 
and transforming these segments individually with a usual 1D DWT  (via 
a call to <B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
) with appropriate extension at the 
ends of each segment. Each segment is transformed so that the global subsampling 
scheme for the signal is respected; that is, the starting index for each 
segment is determined to be either odd or even based upon its location 
relative to the start of <I>signal</I>, and this determines whether odd or even 
subsampling is used in the DWT of the segment. <P>
The transparency mask is 
transformed (with a Lazy wavelet transform) alongside the signal so that, 
at completion of the transform, <I>mask</I> indicates where valid coefficients, 
i.e., coefficients resulting from non-transparent segments in the input signal, 
reside in the output <I>signal</I>. The transformed mask is returned in <I>mask</I>, 
overwriting the original input mask. <P>
Currently,  <B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B> 
supports only integer-valued biorthogonal wavelets. These may be used with 
symmetric extension only. <P>
Segments within <I>signal</I> may be of any length, 
odd or even. In the case of odd segment length, either the lowpass or highpass 
subband at the next coarser scale will be one sample longer than the other; 
which one is longer depends on whether the segment starts with an even- 
or odd-indexed sample relative to the start of <I>signal</I>. A segment of length 
one, i.e., an isolated signal sample, is somewhat of a degenerate case. <B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B> 
handles a length-1 segment as follows. If the isolated  sample is even-indexed 
relative to the start of <I>signal</I>, then the sample value is placed unchanged 
in the lowpass band. If the isolated sample is odd-index, it is placed unchanged 
in the highpass band. <P>
<B>QccWAVWaveletInverseShapeAdaptiveDWT1DInt()</B> performs 
the inverse SA-DWT of <I>signal</I> which is assumed to have been produced by 
<B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B>. <I>mask</I> should be the corresponding 
Lazy-wavelet transformed mask also produced by <B>QccWAVWaveletShapeAdaptiveDWT1DInt()</B>. 
<I>num_scales</I> gives the number of levels of decomposition that exist in <I>signal</I>. 
 
<H2><A NAME="sect3" HREF="#toc3">SHAPE-ADAPTIVE DWTS </A></H2>
SA-DWTs have been recently included in Version 2 of 
the MPEG-4 standard, wherein they are used for  texture coding of arbitrarily 
shaped still objects. Li and Li (see below) elaborate at length on the 
shape-adaptive DWT used in MPEG-4, and also consider some variants not included 
in the MPEG-4 standard. <P>
The SA-DWT implemented in QccPack differs slightly 
from the transform specified by MPEG-4. The most significant difference 
is in the handling of isolated samples  (i.e., segments with length one). 
In MPEG-4, isolated samples are always placed in the lowpass band regardless 
of the parity of the index of the sample. Another difference is that the 
QccPack SA-DWT can handle boundary-wavelet extension in addition to symmetric 
extension for lifting implementations of wavelets; MPEG-4 uses only symmetric 
extension. Finally, Li and Li describe several SA-DWT variants that are 
currently not implemented in QccPack, namely, SA-DWTs using orthonormal 
wavelets or biorthogonal wavelets with even-length symmetric filters.  
<H2><A NAME="sect4" HREF="#toc4">INTEGER-TO-INTEGER 
WAVELET TRANSFORMS </A></H2>
Transforms generally provide perfect reconstruction 
in that the inverse transform will perfectly invert transform coefficients 
into an exact representation of the original signal. However, when implemented 
in floating-point arithmetic, the potential for loss arises due to the 
limits of finite precision in both the forward and inverse transforms. 
On the other hand, transforms that map integer-valued signals into integer-valued 
transforms coefficients can guarantee perfect reconstruction, provided 
an inverse transform can be found. For this reason, lifting schemes, in 
which inverse transforms are trivial, are favored for the implementation 
of integer-valued wavelet transforms. Typically, the general approach proposed 
by Calderbank <I>et al</I>. is followed wherein rounding of floating-point values 
to integers is performed at each prediction and update step in a lifting 
scheme. Integer versions of several popular biorthogonal wavelets were 
created in this manner by Calderbank <I>et al</I>., as well as by Xiong <I>et al</I>. 
<P>
In traditional floating-point lifting, the prediction and update steps 
are generally followed by a single application of scaling by a constant 
in order to produce the usual unitary normalization. This scaling step 
is somewhat problematic for integer-valued lifting since the scaling constant 
is usually not an integer. In applications wherein unitary scaling is not 
required (e.g., in some applications that process each subband completely 
independently), the scaling step is simply dropped in order to implement 
an integer-valued version of the transform. Alternatively, one can append 
three additional lifting steps to  implement the scaling; these additional 
lifting steps can then be rendered integer-valued via appropriate rounding 
(e.g., Xiong <I>et al</I>.) making the transforms approximately normalized. This 
latter approach of scaling via additional lifting steps is employed in 
the integer-valued lifting schemes implemented in QccPack.  
<H2><A NAME="sect5" HREF="#toc5">RETURN VALUES 
</A></H2>
These routines return 0 on success and 1 on error.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="QccWAVWaveletDWT1DInt.3.html">QccWAVWaveletDWT1DInt</B>(3)</A>
, 
<B><A HREF="QccWAVWaveletInverseDWT1DInt.3.html">QccWAVWaveletInverseDWT1DInt</B>(3)</A>
, <B><A HREF="QccWAVWavelet.3.html">QccWAVWavelet</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 
<P>
S. Li and W. Li, "Shape-Adaptive Discrete Wavelet Transforms for Arbitrarily 
Shaped Visual Object Coding," <I>IEEE Transactions on Circuits and Systems 
for Video Coding</I>, vol. 10, pp. 725-743, August 2000. <P>
 ISO/IEC 14496-2, "Information 
Technology -- Coding of audio-visual objects -- Part 2: Visual,"  <I>MPEG-4 Standard</I>, 
Amendment 1, July 2000. <P>
 A. R. Calderbank, I. Daubechies, W. Sweldens, B.-L. Yeo, 
"Lossless Image Compression Using Integer to Integer Wavelet Transforms", 
in <I>Proceedings of the International Conference on Image Processing</I>, Lausanne, 
Switzerland, pp. 596-599, September 1997. <P>
 Z. Xiong, X. Wu, S. Cheng, J. Hua, 
"Lossy-to-Lossless Compression of Medical Volumetric Data Using Three-Dimensional 
Integer Wavelet Transforms," <I>IEEE Transactions on Medical Imaging</I>, vol. 
22, pp. 459-470, March 2003. <P>
 I. Daubechies and W. Sweldens, "Factoring Wavelet 
Transforms Into Lifting Steps," <I>J. Fourier Anal. Appl.</I>, vol. 4, no. 3, pp. 245-267, 
1998.  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler <P>
 <P>
 <P>
  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">SHAPE-ADAPTIVE DWTS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">INTEGER-TO-INTEGER WAVELET TRANSFORMS</A></LI>
<LI><A NAME="toc5" HREF="#sect5">RETURN VALUES</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
