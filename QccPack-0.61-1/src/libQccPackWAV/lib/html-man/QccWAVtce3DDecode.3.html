<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVtce3DDecode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVtce3DEncode, QccWAVtce3DDecode - encode/decode an image cube 
using the 3D-TCE algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVtce3DEncode(const 
QccIMGImageCube *</B><I>image</I><B>, QccBitBuffer *</B><I>buffer</I><B>, int </B><I>transform_type</I><B>, int 
</B><I>temporal_num_levels</I><B>, int </B><I>spatial_num_levels</I><B>, double </B><I>alpha</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  <P>
<B>int QccWAVtce3DDecodeHeader(QccBitBuffer 
*</B><I>buffer</I><B>, int *</B><I>transform_type</I><B>, int *</B><I>temporal_num_levels</I><B>, int *</B><I>spatial_num_levels</I><B>, 
int *</B><I>num_frames</I><B>, int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int 
*</B><I>max_coefficient_bits</I><B>, double *</B><I>alpha</I><B>);</B>  <P>
<B>int QccWAVtce3DDecode(QccBitBuffer 
*</B><I>buffer</I><B>, QccIMGImageCube *</B><I>image</I><B>, int </B><I>transform_type</I><B>, int </B><I>temporal_num_levels</I><B>, 
int </B><I>spatial_num_levels</I><B>, double </B><I>alpha</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, double 
</B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_bit</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVtce3DEncode()</B> encodes an image cube, <I>image</I>, using a 3D 
generalization of the TCE algorithm. The original TCE algorithm was developed 
for 2D images by Tian and Hemami; it was latter extended to 3D by Zhang 
<I>et al</I>. The TCE (tarp coding using classification to achieve embedding) 
algorithm is based on the tarp algorithm (see  <B><A HREF="QccWAVTarpEncode.3.html">QccWAVTarpEncode</B>(3)</A>
), but 
is designed to provide better rate-distortion performance when used in 
an embedded fashion; i.e., when decoding is performed at a rate less than 
that at which the bitstream was produced. See "ALGORITHM" below for more 
detail. <P>
<I>image</I> is the image cube to be coded and <I>buffer</I> is the output bitstream. 
<I>buffer</I> must be of <B>QCCBITBUFFER_OUTPUT</B> type and opened via a prior call 
to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
<B>QccWAVtce3DEncode</B>() supports the use of both wavelet-packet 
and dyadic wavelet-transform decompositions. If <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B>, 
a dyadic DWT is used; if <I>transform_type</I> is <B>QCCWAVSUBBANDPYRAMID3D_PACKET</B>, 
a wavelet-packet DWT is used. <I>temporal_num_levels</I> and <I>spatial_num_levels</I> 
give the number of levels of wavelet decomposition to perform for both 
transform types; for a dyadic transform, <I>temporal_num_levels</I> should equal 
<I>spatial_num_levels</I>. <I>wavelet</I> is the wavelet to use for decomposition. <P>
The 
3D-TCE algorithm performance is in part through the parameter <I>alpha</I>, a 
value that gives the learning rate of the density-estimation process implemented 
by the tarp filter used in one of the coding passes of the TCE algorithm. 
<P>
The bitstream output from the 3D-TCE encoder is embedded, meaning that 
any prefix of the bitstream can be decoded to give a valid  representation 
of the image.  The 3D-TCE encoder essentially produces output bits until 
the number of bits output reaches <I>target_bit_cnt</I>, the desired (target) 
total length of the output bitstream in bits, and then it stops. Note that 
this is the bitstream length in bits, not the rate of the bitstream (which 
would be expressed in bits per voxel). <P>
 
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVtce3DDecodeHeader()</B> 
decodes the header information  in a bitstream previously produced by 
<B>QccWAVtce3DEncode()</B>. The input bitstream is <I>buffer</I> which must be of <B>QCCBITBUFFER_INPUT</B> 
type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. <P>
The header information 
is returned in <I>transform_type</I> (either <B>QCCWAVSUBBANDPYRAMID3D_DYADIC</B> or 
<B>QCCWAVSUBBANDPYRAMID3D_PACKET</B> to indicate a dyadic or wavelet-packet transform 
decomposition, respectively), <I>temporal_num_levels</I> (number of levels of 
wavelet decomposition in the temporal direction), <I>spatial_num_levels</I> (number 
of levels of wavelet decomposition in the spatial directions), <I>num_frames</I> 
(size of the image cube in the temporal direction), <I>num_rows</I> (vertical 
size of image cube), <I>num_cols</I> (horizontal size of image cube), <I>image_mean</I> 
(the mean value of the original image cube), <I>max_coefficient_bits</I> (indicates 
the precision, in number of bits, of the wavelet coefficient with the 
largest magnitude), and <I>alpha</I> (the value of the learning rate). <P>
<B>QccWAVtce3DDecode()</B> 
decodes the bitstream <I>buffer</I>, producing the reconstructed image cube, 
<I>image</I>. The bitstream must already have had its header read by a prior call 
to <B>QccWAVtce3DDecodeHeader()</B> (i.e., you call <B>QccWAVtce3DDecodeHeader() </B> 
first and then <B>QccWAVtce3DDecode()</B>). If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, 
then decoding stops when the end of the input bitstream is reached; otherwise, 
decoding stops when <I>target_num_bits</I> from the input bitstream have been 
decoded.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
It is widely believed that, in the wavelet domain, 
coefficients  in a local neighborhood capture essential context information, 
such as edges and patterns, and that this information can facilitate compression. 
Many image coders exploit such local information in the form of  adaptive 
entropy coding. Alternatively, tarp filtering (see <B><A HREF="QccWAVtarpEncode.3.html">QccWAVtarpEncode</B>(3)</A>
) 
produces probability estimates through an IIR filtering technique on the 
bitplanes of  the wavelet coefficients.  While providing very good  performance 
when used in a nonembedded manner, the original  tarp coder performs less 
competitively when used in an  embedded manner, in spite of its operation 
on bitplanes. The reason is that  the underlying tarp filter is designed 
to follow a raster-scan encoding order; however, the use of fractional 
bitplanes (see Ordentlich <I>et al</I>.) provides better rate-distortion performance 
for embedding. Such fractional bitplanes require an encoding  order more 
flexible than a simple raster scan.  In the TCE algorithm, coefficients 
are classified according to statistical properties, and the tarp filter 
is run on only the single class on which it tends to generate  accurate 
probability estimates. <P>
In the TCE algorithm, <I>nonzero-parent</I> coefficients 
and <I>run</I> coefficients from the fractional-bitplane approach of Ordentlich 
<I>et al</I>. are combined to form a single class, the <I>zero-run</I> coefficients. For 
each bitplane, the TCE system then performs three passes:  1) adaptive 
arithmetic  coding of bits of <I>nonzero-neighbor</I> coefficients; 2) tarp  filtering 
and non-adaptive  arithmetic coding of <I>zero-run</I> coefficients; and 3) encoding 
of refinement  bits with an adaptive arithmetic coder. The sign bits of 
coefficients are coded when needed with a probability  of 0.5. The encoding/decoding 
ends when the target rate is reached.  Tian and Hemami describe several 
approaches to improving the probability estimate of the tarp filtering 
of the second pass.  
<H2><A NAME="sect6" HREF="#toc6">SEE ALSO </A></H2>
<B><A HREF="tceencode3d.1.html">tceencode3d</B>(1)</A>
, <B><A HREF="tcedecode3d.1.html">tcedecode3d</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid3D.3.html">QccWAVSubbandPyramid3D</B>(3)</A>
, <B><A HREF="QccWAVSubbandPyramid3DDWT.3.html">QccWAVSubbandPyramid3DDWT</B>(3)</A>
, <B><A HREF="QccWAVtceEncode.3.html">QccWAVtceEncode</B>(3)</A>
, 
<B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 <P>
C. Tian and S. S. Hemami, "An Embedded 
Image Coding System Based on Tarp Filter with Classification," in <I>Proceedings 
of the International Conference on Acoustics, Speech, and Signal Processing</I>, 
Montreal, Quebec, Canada, May 2004, vol. 3, pp. 49-52. <P>
 J. Zhang, J. E. Fowler, 
and G. Liu, "Lossy-to-Lossless Compression of Hyperspectral Imagery Using 
3D-TCE and an Integer KLT,"  <I>IEEE Geoscience and Remote Sensing Letters</I>, 
vol. 5, pp. 814-818, October 2008. <P>
 E. Ordentlich, M. Weinberger, and G. Seroussi, 
"A Low-Complexity Modeling Approach for Embedded Coding of Wavelet Coefficients," 
in <I>Proceedings of the IEEE Data Compression Conference</I>, Snowbird, UT, 
March 2002, pp. 23-32. <P>
  
<H2><A NAME="sect7" HREF="#toc7">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler  <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">SEE ALSO</A></LI>
<LI><A NAME="toc7" HREF="#sect7">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
