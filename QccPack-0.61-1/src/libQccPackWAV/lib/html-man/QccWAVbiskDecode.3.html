<!-- manual page source format generated by PolyglotMan v3.0.4, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>QccWAVbiskDecode.3</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
QccWAVbiskEncode, QccWAVbiskDecode - encode/decode an image using 
the BISK algorithm  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>#include "libQccPack.h"</B>  <P>
<B>int QccWAVbiskEncode(const 
QccIMGImageComponent *</B><I>image</I><B>, const QccIMGImageComponent *</B><I>mask</I><B>, int </B><I>num_levels</I><B>, 
int </B><I>target_bit_cnt</I><B>, const QccWAVWavelet *</B><I>wavelet</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>, 
FILE *</B><I>rate_distortion_file</I><B>);</B>  <BR>
 <P>
<B>int QccWAVbiskEncode2(QccWAVSubbandPyramid 
*</B><I>image_subband_pyramid</I><B>, QccWAVSubbandPyramid *</B><I>mask_subband_pyramid</I><B>, double 
</B><I>image_mean</I><B>, int </B><I>target_bit_cnt</I><B>, QccBitBuffer *</B><I>output_buffer</I><B>, FILE *</B><I>rate_distortion_file</I><B>);</B> 
 <BR>
 <P>
<B>int QccWAVbiskDecodeHeader(QccBitBuffer *</B><I>input_buffer</I><B>, int *</B><I>num_levels</I><B>, 
int *</B><I>num_rows</I><B>, int *</B><I>num_cols</I><B>, double *</B><I>image_mean</I><B>, int *</B><I>max_coefficient_bits</I><B>);</B> 
 <BR>
 <P>
<B>int QccWAVbiskDecode(QccBitBuffer *</B><I>input_buffer</I><B>, QccIMGImageComponent 
*</B><I>image</I><B>, const QccIMGImageComponent *</B><I>mask</I><B>, int </B><I>num_levels</I><B>, const QccWAVWavelet 
*</B><I>wavelet</I><B>, double </B><I>image_mean</I><B>, int </B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B> 
 <BR>
 <P>
<B>int QccWAVbiskDecode2(QccBitBuffer *</B><I>input_buffer</I><B>, QccWAVSubbandPyramid 
*</B><I>image_subband_pyramid</I><B>, QccWAVSubbandPyramid *</B><I>mask_subband_pyramid</I><B>, int 
</B><I>max_coefficient_bits</I><B>, int </B><I>target_bit_cnt</I><B>);</B>  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
 
<H3><A NAME="sect3" HREF="#toc3">Encoding </A></H3>
<P>
<B>QccWAVbiskEncode()</B> 
encodes an image component, <I>image</I>, using the BISK algorithm by Fowler. 
An embedded wavelet-based image coder based on the popular bitplane-coding 
paradigm, BISK is designed specifically for the coding of image objects 
with arbitrary shape. While other similar algorithms (e.g., SPECK) employ 
quadtree-based set partitioning to code significance-map information, BISK 
uses a simpler, and more flexible, binary decomposition via <I>k</I>-d trees. Additionally, 
aggressive discarding of transparent regions is implemented by shrinking 
sets to the bounding box of their constituent opaque coefficients before 
further partitioning. See "ALGORITHM" below for more detail. <P>
<I>image</I> is the 
image component to be coded and <I>buffer</I> is the output bitstream. <I>buffer</I> 
must be of <B>QCCBITBUFFER_OUTPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
. 
<P>
<I>num_levels</I> gives the number of levels of dyadic wavelet decomposition 
to perform, and <I>wavelet</I> is the wavelet to use for decomposition. <P>
The bitstream 
output from the BISK encoder is embedded, meaning that any prefix of the 
bitstream can be decoded to give a valid  representation of the image. 
 The BISK encoder essentially produces output bits until the number of 
bits output reaches <I>target_bit_cnt</I>, the desired (target) total length 
of the output bitstream in bits, and then it stops. Note that this is the 
bitstream length in bits, not the rate of the bitstream (which would be 
expressed in bits per pixel). <P>
<B>QccbiskEncode()</B> optionally supports the use 
of a shape-adaptive DWT (SA-DWT) rather than the usual DWT. That is,  <B>QccbiskEncode()</B> 
can call <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 as the wavelet transform 
rather than the usual <B><A HREF="QccWAVSubbandPyramidDWT.3.html">QccWAVSubbandPyramidDWT</B>(3)</A>
. The use of a SA-DWT is 
indicated by a non-<B>NULL</B> <I>mask</I>; if  <I>mask</I> is <B>NULL</B>, then the usual DWT is used. 
In the case of a SA-DWT, <I>mask</I>  gives the transparency mask which indicates 
which pixels of the image are non-transparent and thus have data that is 
to be transformed. Refer to  <B><A HREF="QccWAVSubbandPyramidShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidShapeAdaptiveDWT</B>(3)</A>
 for 
more details on the calculation of this SA-DWT, and see "ALGORITHM" below 
for how the shape-adaptive mask is employed in the BISK algorithm. <P>
<I>rate_distortion_file</I> 
is a pointer to an output file. If this pointer is not <B>NULL</B>, then a rate-distortion 
profile is written to the file while the image is being compressed. Essentially, 
this rate-distortion profile gives numerous points on the operational rate-distortion 
curve of the compressed bitstream produced by <B>QccWAVbiskEncode()</B>; see 
"RATE-DISTORTION PROFILE" below for more details. The file pointed to by 
<I>rate_distortion_file</I> must be opened for writing prior to calling <B>QccWAVbiskEncode()</B>, 
and must be closed after <B>QccWAVbiskEncode()</B> returns. If <I>rate_distortion_file</I> 
is  <B>NULL</B>, no rate-distortion profile is written. <P>
The routine <B>QccWAVbiskEncode2()</B> 
provides an alternative interface to BISK encoding. Specifically, <B>QccWAVbiskEncode2()</B> 
functions indentically to <B>QccWAVbiskEncode()</B> described above, except that 
both the image and optional mask are assumed to have had a DWT applied 
to them prior to calling <B>QccWAVbiskEncode2()</B>. As a consequence, the image 
and mask are passed to <B>QccWAVbiskEncode2()</B> in the wavelet domain as <I>image_subband_pyramid</I> 
and <I>mask_subband_pyramid</I>. We note that most applications should opt for 
<B>QccWAVbiskEncode()</B> rather than <B>QccWAVbiskEncode2()</B>; however, <B>QccWAVbiskEncode()</B> 
is implemented essentially as a call to an appropriate DWT followed by 
a call to <B>QccWAVbiskEncode2()</B>. If  <B>QccWAVbiskEncode2()</B> is used, it is the 
responsibility of the calling routine to perform the appropriate DWT prior 
to calling <B>QccWAVbiskEncode2()</B>.  
<H3><A NAME="sect4" HREF="#toc4">Decoding </A></H3>
<P>
<B>QccWAVbiskDecodeHeader()</B> decodes 
the header information in the bitstream in the input <I>buffer</I> (which must 
be of <B>QCCBITBUFFER_INPUT</B> type and opened via a prior call to <B><A HREF="QccBitBufferStart.3.html">QccBitBufferStart</B>(3)</A>
). 
The header information is returned in <I>num_levels</I> (number of levels of 
wavelet decomposition), <I>num_rows</I> (vertical size of image), <I>num_cols</I> (horizontal 
size of image), <I>image_mean</I> (the mean value of the original image), and 
<I>max_coefficient_bits</I> (the number of bits used to represent the magnitude 
of the coefficient with largest absolute value). <P>
<B>QccWAVbiskDecode()</B> decodes 
the bitstream <I>buffer</I>, producing the reconstructed image component, <I>image</I>. 
The bitstream must already have had its header read by a prior call to 
<B>QccWAVbiskDecodeHeader()</B> (i.e., you call <B>QccWAVbiskDecodeHeader() </B> first 
and then <B>QccWAVbiskDecode()</B>). If <I>target_bit_cnt</I> is <B>QCCENT_ANYNUMBITS</B>, then 
decoding stops when the end of the input bitstream is reached; otherwise, 
decoding stops when <I>target_num_bits</I> from the input bitstream have been 
decoded. <P>
If a SA-DWT was used in BISK encoding, then the original transparency 
mask should be passed to  <B>QccWAVbiskDecode()</B> as <I>mask</I>. That is, <I>mask</I> should 
be the same transparency mask (in the spatial domain) that was passed 
to <B>QccWAVbiskEncode()</B>. Note that <B>QccWAVbiskDecode()</B> will transform this 
<I>mask</I> via a Lazy wavelet transform, and then pass the transformed mask 
to  <B><A HREF="QccWAVSubbandPyramidInverseShapeAdaptiveDWT.3.html">QccWAVSubbandPyramidInverseShapeAdaptiveDWT</B>(3)</A>
. If the usual DWT was 
used in encoding, then <I>mask</I> should be a <B>NULL</B> pointer. <P>
<B>QccWAVbiskDecode2()</B> 
provides the appropriate alternative interface to BISK decoding required 
if encoding was done via <B>QccWAVbiskEncode2()</B>. Essentially,  <B>QccWAVbiskDecode()</B> 
is implemented by a call to <B>QccWAVbiskDecode2()</B> followed by an appropriate 
inverse DWT. If <B>QccWAVbiskDecode2()</B> is used, it is the responsibility of 
the calling to routine to perform the appropriate inverse DWT subsequent 
to the call to <B>QccWAVbiskDecode2()</B>. As noted above, most applications should 
use <B>QccWAVbiskDecode()</B> rather than <B>QccWAVbiskDecode2()</B>.  
<H2><A NAME="sect5" HREF="#toc5">ALGORITHM </A></H2>
The 
BISK algorithm involves a 2D DWT followed by a progressive encoding of 
the bitplanes of wavelet coefficients. As is common with bitplane-based 
embedded coders, the encoder of the BISK algorithm codes significance 
information in a significance pass followed by refinement-bit information 
in a refinement pass. The significance pass determines the significance 
of a wavelet coefficient against a given threshold, while the refinement 
pass codes the bits of those coefficients previously determined to be 
significant. <P>
The unique aspect of the BISK algorithm is in the significance 
pass. In many ways, the BISK algorithm can be considered to be a variant 
of SPECK (Pearlman <I>et al</I>. 2003) designed specifically for improved shape-adaptive 
coding. The BISK coder employs two tactics to this end---aggressive discarding 
of transparent regions from sets after partitioning, and a spatial-partitioning 
structure more flexible than the quadtrees used by SPECK. In quadtree partitioning, 
the significance state of an entire block of coefficients is tested and 
coded, the block is subdivided into four subblocks of approximately equal 
size, and the significance-coding process is repeated recursively on each 
of the subblocks. On the other hand, when processing a given set, the BISK 
coder employs a different partitioning scheme, <I>k</I>-d trees (Bentley 1975) 
rather than quadtrees, to recursively code the significance map. Like quadtrees, 
<I>k</I>-d trees are a recursive spatial partitioning data structure. Unlike quadtrees, 
which subdivide a block into four equally sized subblocks, <I>k</I>-d trees effectuate 
a binary partitioning; that is, blocks are divided in two, rather than 
quarters. Although there are several approaches for selecting the location 
and orientation of the split, we use a simple approach in which blocks 
are divided into approximately equally sized halves, and we alternate 
between splitting horizontally and vertically. <P>
Additionally, to improve 
shape-adaptive coding, the BISK coder "shrinks" each set to the bounding 
box surrounding the opaque coefficients before subdividing the set into 
smaller blocks. <P>
The BISK coder uses only one type of set, rather than having 
S and I sets as in SPECK. Consequently, each subband in the DWT decomposition 
is added to an LIS at the start of the BISK algorithm, whereas the SPECK 
algorithm initializes with only the baseband subband in an LIS.  
<H2><A NAME="sect6" HREF="#toc6">RATE-DISTORTION 
PROFILE </A></H2>
For an embedded coding, such as that produced by the BISK algorithm, 
any prefix of the final compressed bitstream may be decoded to produce 
a reconstruction of the original image. This prefix will have an associated 
distortion which is necessarily greater than or equal to the distortion 
of the full-length bitstream, and a rate that is necessarily less than 
or equal to the rate of the full-length bitstream. These rate and distortion 
values give a single point on the so-called operational rate-distortion 
curve of the embedded coding; evaluating rate and distortion for a variety 
of prefixes allows one to trace out an approximation to the entire operational 
rate-distortion curve. <P>
It is computationally expensive to perform multiple 
truncatations and reconstructions of a bitstream to generate this opertional 
rate-distortion curve as the full decoding algorithm (including inverse 
transform) must be run numerous times. Instead, it is fairly straightforward 
to calculate rate and distortion values while encoding is taking place. 
To do so, the encoder keeps a running estimate of the current mean squared 
error (MSE) as calculated in the wavelet domain. Each time a wavelet coefficient 
is modified while encoding, the encoder adjusts the running MSE estimate 
using the value of the wavelet coefficient as it would be reconstructed 
in the decoder. <P>
In theory, the MSE as calculated by this procedure would 
be exactly the same as the MSE calculated in the original spatial domain, 
providing that an orthonormal wavelet transform is used (a direct consequence 
of Parseval's theorem). However, in practice, the MSE as calculated in the 
wavelet domain using the approach outlined above will differ somewhat 
from the spatial-domain MSE, which is really what is of interest. The first 
discrepancy is due to the fact that, in practice, usually biorthogonal, 
rather than orthonormal, transforms are used for image compression. Using 
"near orthogonal" transforms, such as the popular Cohen-Daubechies-Feauveau 
biorthogonal family, help mitigate this effect, however. Additionally, 
the wavelet-domain MSE calculation ignores the fact that spatial-domain 
pixels are "rounded" to integer values after the inverse wavelet transform 
in the decoder. This, too, should produced only a small deviation, so that 
the wavelet-domain MSE should usually be quite close to the desired spatial-domain 
MSE. However, by calculating MSE in the wavelet-domain, one avoids numerous 
and costly inverse-transform calculations. <P>
In <B>QccWAVbiskEncode()</B>, each time 
a coefficient is modified (in the refinement pass, or when the coefficient 
initially becomes significant in the significance pass), the current wavelet-domain 
MSE estimate, along with the current rate as calculated from the number 
of bits written to the output bitstream thus far, is written to the output 
rate-distortion file, in ASCII. This is a fairly fine sampling of the operational 
rate-distortion curve, typically producing several thousands, or tens of 
thousands, of points on the curve, depending on the final rate of the 
compressed bitstream.  
<H2><A NAME="sect7" HREF="#toc7">SEE ALSO </A></H2>
<B><A HREF="biskencode.1.html">biskencode</B>(1)</A>
, <B><A HREF="biskdecode.1.html">biskdecode</B>(1)</A>
, <B><A HREF="imgdwt.1.html">imgdwt</B>(1)</A>
, 
<B><A HREF="imgdist.1.html">imgdist</B>(1)</A>
, <B><A HREF="QccBitBuffer.3.html">QccBitBuffer</B>(3)</A>
, <B><A HREF="QccENTArithmeticEncode.3.html">QccENTArithmeticEncode</B>(3)</A>
, <B><A HREF="QccENTArithmeticDecode.3.html">QccENTArithmeticDecode</B>(3)</A>
, 
<B><A HREF="QccWAVSubbandPyramid.3.html">QccWAVSubbandPyramid</B>(3)</A>
, <B><A HREF="QccPackWAV.3.html">QccPackWAV</B>(3)</A>
, <B><A HREF="QccPackIMG.3.html">QccPackIMG</B>(3)</A>
, <B><A HREF="QccPack.3.html">QccPack</B>(3)</A>
 <P>
 J. E. 
Fowler, "Shape-Adaptive Coding Using Binary Set Splitting with <I>k</I>-d Trees," 
in <I>Proceedings of the International Conference on Image Processing</I>, Singapore, 
October 2004, to appear. <P>
 W. A. Pearlman, A. Islam, N. Nagaraj, and A. Said, 
"Efficient, Low-Complexity Image Coding With a Set-Partitioning Embedded 
Block Coder," <I>IEEE Transactions on Circuits and Systems for Video Technology</I>, 
to appear, 2003. <P>
 J. L. Bentley, "Multidimensional Binary Search Trees Used 
for Associative Searching," <I>Communications of the ACM</I>, vol. 18, no. 9, pp. 
509-517, September 1975. <P>
  
<H2><A NAME="sect8" HREF="#toc8">AUTHOR </A></H2>
Copyright (C) 1997-2016  James E. Fowler 
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<UL>
<LI><A NAME="toc3" HREF="#sect3">Encoding</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Decoding</A></LI>
</UL>
<LI><A NAME="toc5" HREF="#sect5">ALGORITHM</A></LI>
<LI><A NAME="toc6" HREF="#sect6">RATE-DISTORTION PROFILE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">SEE ALSO</A></LI>
<LI><A NAME="toc8" HREF="#sect8">AUTHOR</A></LI>
</UL>
<p><br><br><a href="http://sourceforge.net/projects/qccpack"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=5992&type=6" width="210" height="62" border="0" alt="Get QccPack at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a></body></html>
